var tipuesearch = {"pages":[{"title":" My Fortran project ","text":"My Fortran project This is my Fortran project! Developer Info Me","tags":"home","loc":"index.html"},{"title":"FokkerPlanck1D – My Fortran project ","text":"type, public :: FokkerPlanck1D Contents Variables enorm v_lim v f i0 alfa2 n h d1 d2 d3 Constructor FokkerPlanck1D Type-Bound Procedures print solve_time_step init_zero_diffusion init_diffusion Components Type Visibility Attributes Name Initial real(kind=dp), public :: enorm = 0 real(kind=dp), public :: v_lim = 0 real(kind=dp), public, allocatable :: v (:) real(kind=dp), public, allocatable :: f (:) integer, public :: i0 = 0 real(kind=dp), public :: alfa2 = 0 integer, public :: n = 0 real(kind=dp), public :: h = 0 real(kind=dp), public, allocatable :: d1 (:) real(kind=dp), public, allocatable :: d2 (:) real(kind=dp), public, allocatable :: d3 (:) Constructor public        interface FokkerPlanck1D public  function FokkerPlanck1D_constructor (e, v_lim, v, f) result(this) Arguments Type Intent Optional Attributes Name real(kind=dp), value :: e real(kind=dp), value :: v_lim real(kind=dp), value :: v (:) real(kind=dp), value :: f (:) Return Value type( FokkerPlanck1D ) Type-Bound Procedures procedure, public :: print => FokkerPlanck1D_print public  subroutine FokkerPlanck1D_print (this) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(in) :: this procedure, public :: solve_time_step => FokkerPlanck1D_solve_time_step public  subroutine FokkerPlanck1D_solve_time_step (this, dt, nt) !!!! grid !!!!!!!!!\n  shift=h*0.1d0 !0.01d0\n!!!!!!!!!!   solve problem   !!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this real(kind=dp), intent(in) :: dt integer, intent(in) :: nt procedure, public :: init_zero_diffusion => FokkerPlanck1D_init_zero_diffusion public  subroutine FokkerPlanck1D_init_zero_diffusion (this) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this procedure, public :: init_diffusion => FokkerPlanck1D_init_diffusion public  subroutine FokkerPlanck1D_init_diffusion (this, dif) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this real(kind=dp), intent(in), dimension(:) :: dif","tags":"","loc":"type\\fokkerplanck1d.html"},{"title":"FluxSurface – My Fortran project ","text":"type, public :: FluxSurface класс магнитной поверхности Contents Variables index r vmax vt ipt vgrid vr_grid diffusion Components Type Visibility Attributes Name Initial integer, public :: index номер магнитной поверхности real(kind=dp), public :: r радиус real(kind=dp), public :: vmax vmax=cltn/vto real(kind=dp), public :: vt наверно тепловая скорость электронов????? vt=fvt(r) integer, public :: ipt размер vgrid real(kind=dp), public, allocatable :: vgrid (:) real(kind=dp), public, allocatable :: vr_grid (:) бываший vrj real(kind=dp), public, allocatable :: diffusion (:) бывший dijk(i,j,k) или dj(i)","tags":"","loc":"type\\fluxsurface.html"},{"title":"debug – My Fortran project","text":"subroutine debug() Arguments None Contents None","tags":"","loc":"proc\\debug.html"},{"title":"currlhcd – My Fortran project","text":"function currlhcd(v, f) result(curs) Arguments Type Intent Optional Attributes Name real(kind=8) :: v (:) real(kind=8) :: f (:) Return Value real(kind=8) Contents","tags":"","loc":"proc\\currlhcd.html"},{"title":"d – My Fortran project","text":"function d(x) Uses maxwell call ddc(d) !      call linf(vvj,ddj,x,d,klo,khi) Arguments Type Intent Optional Attributes Name real(kind=8) :: x Return Value real(kind=8) Contents Common Blocks dddql Common Blocks common /dddql/ Type Attributes Name Initial real(kind=8) :: d0 integer :: jindex integer :: kindex","tags":"","loc":"proc\\d.html"},{"title":"drivencurrent95 – My Fortran project","text":"subroutine drivencurrent95(outj, sigmaj, UPL, NRD, NA1, TIME, TAU, ROC, RTOR, GP2) outj(i)  = LH driven current density, MA/m&#94;2\n   dndt(i)  = d&#94;2Jr1/dt&#94;2/E, MA/m&#94;2/sec&#94;2/(V/m), ~runaway d(el.density)/dt/E\n   djdt(i)  = dJr2/dt, time drivative of runaway current Jr2, MA/m&#94;2/sec\n   outjrun(i)  = LH driven runaway current density, MA/m&#94;2\n   outnerun(i) = runaway electron density/10&#94;19 m&#94;-3 variant\n!!!!!!!!!!! starting LH current calculation !!!!!!!!!!!!!!!!!\npositive spectrum:\nnegative spectrum:\n!!       write( , ) i,outj(i) Arguments Type Intent Optional Attributes Name real(kind=8) :: outj (NRD) real(kind=8) :: sigmaj (NRD) double precision :: UPL (NRD) integer :: NRD integer :: NA1 double precision :: TIME double precision :: TAU double precision :: ROC double precision :: RTOR double precision :: GP2 Contents","tags":"","loc":"proc\\drivencurrent95.html"},{"title":"lhcurrent – My Fortran project","text":"subroutine lhcurrent(outj, ohj, cuj, cujoh, inpt, ispectr) Uses plasma maxwell rt_parameters implicit real*8 (a-h,o-z)\n  write(*,*)\n  write(*,*)'ccur',ccur,' curdir=',curdir,' nr=',nr\n  write(*,*)'cu_out, MA=',cu_out,' cfull, A=',cfull\n       close(111) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name real(kind=8) :: outj (*) real(kind=8) :: ohj (*) real(kind=8) :: cuj real(kind=8) :: cujoh integer :: inpt integer :: ispectr Contents Common Blocks cnew plosh Common Blocks common /cnew/ Type Attributes Name Initial integer :: inew common /plosh/ Type Attributes Name Initial real :: zv1 (100,2) real :: zv2 (100,2)","tags":"","loc":"proc\\lhcurrent.html"},{"title":"currlhcd_old – My Fortran project","text":"subroutine currlhcd_old(i0, v, f, f0, curs, curs0) Arguments Type Intent Optional Attributes Name integer :: i0 real(kind=8) :: v (*) real(kind=8) :: f (*) real(kind=8) :: f0 (*) real(kind=8) :: curs real(kind=8) :: curs0 Contents","tags":"","loc":"proc\\currlhcd_old.html"},{"title":"ddc – My Fortran project","text":"subroutine ddc(diffusion) Uses maxwell Arguments Type Intent Optional Attributes Name real(kind=8) :: diffusion Contents Common Blocks testf Common Blocks common /testf/ Type Attributes Name Initial real(kind=8) :: tcur","tags":"","loc":"proc\\ddc.html"},{"title":"qromb – My Fortran project","text":"subroutine qromb(func, a, b, ss) Arguments Type Intent Optional Attributes Name double precision :: func double precision :: a double precision :: b double precision :: ss Contents","tags":"","loc":"proc\\qromb.html"},{"title":"polint – My Fortran project","text":"subroutine polint(xa, ya, n, x, y, dy) Arguments Type Intent Optional Attributes Name double precision :: xa (n) double precision :: ya (n) integer :: n double precision :: x double precision :: y double precision :: dy Contents","tags":"","loc":"proc\\polint.html"},{"title":"trapzd – My Fortran project","text":"subroutine trapzd(func, a, b, s, n) Arguments Type Intent Optional Attributes Name double precision :: func double precision :: a double precision :: b double precision :: s integer :: n Contents","tags":"","loc":"proc\\trapzd.html"},{"title":"fokkerplanck_new – My Fortran project","text":"subroutine fokkerplanck_new(time, TAU) Uses Utils plasma maxwell rt_parameters FokkerPlanck1D_mod Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: time real(kind=8), intent(in) :: TAU Contents Common Blocks dddql Common Blocks common /dddql/ Type Attributes Name Initial real(kind=8) :: d0 integer :: jindex integer :: kindex","tags":"","loc":"proc\\fokkerplanck_new.html"},{"title":"init_diffusion – My Fortran project","text":"subroutine init_diffusion(h, n, vj, dj, d1, d2, d3) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: h integer, intent(in) :: n real(kind=8), intent(in), dimension(:) :: vj real(kind=8), intent(in), dimension(:) :: dj real(kind=8), intent(out), dimension(:) :: d1 real(kind=8), intent(out), dimension(:) :: d2 real(kind=8), intent(out), dimension(:) :: d3 Contents","tags":"","loc":"proc\\init_diffusion.html"},{"title":"fokkerplanck_time_step – My Fortran project","text":"subroutine fokkerplanck_time_step(time, TAU) Uses maxwell rt_parameters xend=vij(i0,j) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: time real(kind=8), intent(in) :: TAU Contents Common Blocks dddql t01 Common Blocks common /dddql/ Type Attributes Name Initial real(kind=8) :: d0 integer :: jindex integer :: kindex common /t01/ Type Attributes Name Initial real :: dijk (101,100,2) real :: vrjnew (101,100,2) integer :: iptnew","tags":"","loc":"proc\\fokkerplanck_time_step.html"},{"title":"prepare_diffusion – My Fortran project","text":"subroutine prepare_diffusion(h, n, iptnew, vrjnew, dijk, d1, d2) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: h integer, intent(in) :: n integer, intent(in) :: iptnew real(kind=8), intent(in), dimension(:) :: vrjnew real(kind=8), intent(in), dimension(:) :: dijk real(kind=8), intent(out), dimension(:) :: d1 real(kind=8), intent(out), dimension(:) :: d2 Contents","tags":"","loc":"proc\\prepare_diffusion.html"},{"title":"init_diffusion – My Fortran project","text":"subroutine init_diffusion(h, n, vj, dj, d1, d2, d3) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: h integer, intent(in) :: n real(kind=8), intent(in), dimension(:) :: vj real(kind=8), intent(in), dimension(:) :: dj real(kind=8), intent(out), dimension(:) :: d1 real(kind=8), intent(out), dimension(:) :: d2 real(kind=8), intent(out), dimension(:) :: d3 Contents","tags":"","loc":"proc\\init_diffusion~2.html"},{"title":"fokkerplanck1D_iter – My Fortran project","text":"subroutine fokkerplanck1D_iter(alfa2, h, n, dt, nt, xend, d1, d2, d3, vj, fj0, out_fj, dfj0) !!!! grid !!!!!!!!!\n  shift=h*0.1d0 !0.01d0\n!!!!!!!!!!   solve problem   !!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: alfa2 real(kind=8), intent(in) :: h integer, intent(in) :: n real(kind=8), intent(in) :: dt integer, intent(in) :: nt real(kind=8), intent(in) :: xend real(kind=8), intent(in) :: d1 (:) real(kind=8), intent(in) :: d2 (:) real(kind=8), intent(in) :: d3 (:) real(kind=8), intent(in) :: vj (:) real(kind=8), intent(inout) :: fj0 (:) real(kind=8), intent(inout) :: out_fj (:) real(kind=8), intent(inout), optional :: dfj0 (:) Contents","tags":"","loc":"proc\\fokkerplanck1d_iter.html"},{"title":"burying_procedure – My Fortran project","text":"subroutine burying_procedure(v, f0, df0) write( , )'#1 j,k,ibeg=',j,k,ibeg\nwrite( , )'#1 v(ibeg)=',vj(ibeg),' f1/f2=',fout1/fout2 Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v (:) real(kind=8), intent(inout) :: f0 (:) real(kind=8), intent(inout), optional :: df0 (:) Contents","tags":"","loc":"proc\\burying_procedure.html"},{"title":"rplusk – My Fortran project","text":"function rplusk(x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=8) :: x real(kind=8) :: dif real(kind=8) :: alfa2 Return Value real(kind=8) Contents","tags":"","loc":"proc\\rplusk.html"},{"title":"rplusk2 – My Fortran project","text":"function rplusk2(x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=8) :: x real(kind=8) :: dif real(kind=8) :: alfa2 Return Value real(kind=8) Contents","tags":"","loc":"proc\\rplusk2.html"},{"title":"rmink – My Fortran project","text":"function rmink(x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=8) :: x real(kind=8) :: dif real(kind=8) :: alfa2 Return Value real(kind=8) Contents","tags":"","loc":"proc\\rmink.html"},{"title":"rmink2 – My Fortran project","text":"function rmink2(x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=8) :: x real(kind=8) :: dif real(kind=8) :: alfa2 Return Value real(kind=8) Contents","tags":"","loc":"proc\\rmink2.html"},{"title":"rs – My Fortran project","text":"function rs(x, alfa2) Arguments Type Intent Optional Attributes Name real(kind=8) :: x real(kind=8) :: alfa2 Return Value real(kind=8) Contents","tags":"","loc":"proc\\rs.html"},{"title":"q – My Fortran project","text":"function q(x) Arguments Type Intent Optional Attributes Name real(kind=8) :: x Return Value real(kind=8) Contents","tags":"","loc":"proc\\q.html"},{"title":"qf – My Fortran project","text":"function qf(x) Arguments Type Intent Optional Attributes Name real(kind=8) :: x Return Value real(kind=8) Contents","tags":"","loc":"proc\\qf.html"},{"title":"k – My Fortran project","text":"function k(x, dif) Arguments Type Intent Optional Attributes Name real(kind=8) :: x real(kind=8) :: dif Return Value real(kind=8) Contents","tags":"","loc":"proc\\k.html"},{"title":"k2 – My Fortran project","text":"function k2(x, dif) Arguments Type Intent Optional Attributes Name real(kind=8) :: x real(kind=8) :: dif Return Value real(kind=8) Contents","tags":"","loc":"proc\\k2.html"},{"title":"kinv – My Fortran project","text":"function kinv(x, dif) Arguments Type Intent Optional Attributes Name real(kind=8) :: x real(kind=8) :: dif Return Value real(kind=8) Contents","tags":"","loc":"proc\\kinv.html"},{"title":"kinv2 – My Fortran project","text":"function kinv2(x, dif) Arguments Type Intent Optional Attributes Name real(kind=8) :: x real(kind=8) :: dif Return Value real(kind=8) Contents","tags":"","loc":"proc\\kinv2.html"},{"title":"savelyev_solver – My Fortran project","text":"subroutine savelyev_solver(alfa2, nt, h, dt, n, ybeg, yend, d1, d2, d3, y) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: alfa2 integer, intent(in) :: nt real(kind=8), intent(in) :: h real(kind=8), intent(in) :: dt integer, intent(in) :: n real(kind=8), intent(in) :: ybeg real(kind=8), intent(in) :: yend real(kind=8), intent(in) :: d1 (n+1) real(kind=8), intent(in) :: d2 (n+1) real(kind=8), intent(in) :: d3 (n+1) real(kind=8), intent(inout) :: y (n) Contents","tags":"","loc":"proc\\savelyev_solver.html"},{"title":"savelyev_abccoef – My Fortran project","text":"subroutine savelyev_abccoef(alfa2, a, b, c, f, y, dt, n, ybeg, yend, xx, h, d1, d2, d3) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: alfa2 real(kind=8), intent(inout) :: a (n) real(kind=8), intent(inout) :: b (n) real(kind=8), intent(inout) :: c (n) real(kind=8), intent(inout) :: f (n) real(kind=8), intent(inout) :: y (n) real(kind=8), intent(in) :: dt integer, intent(in) :: n real(kind=8), intent(in) :: ybeg real(kind=8), intent(in) :: yend real(kind=8), intent(in) :: xx (n+1) real(kind=8), intent(in) :: h real(kind=8), intent(in) :: d1 (n+1) real(kind=8), intent(in) :: d2 (n+1) real(kind=8), intent(in) :: d3 (n+1) Contents","tags":"","loc":"proc\\savelyev_abccoef.html"},{"title":"tridag – My Fortran project","text":"subroutine tridag(a, b, c, r, u, n) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: a (n) real(kind=8), intent(in) :: b (n) real(kind=8), intent(in) :: c (n) real(kind=8), intent(in) :: r (n) real(kind=8), intent(inout) :: u (n) integer, intent(in) :: n Contents","tags":"","loc":"proc\\tridag.html"},{"title":"teplova_khavin_solver – My Fortran project","text":"subroutine teplova_khavin_solver(alfa2, nt, h, dt, n, ybeg, yend, d1, d2, d3, y) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: alfa2 integer, intent(in) :: nt real(kind=8), intent(in) :: h real(kind=8), intent(in) :: dt integer, intent(in) :: n real(kind=8), intent(in) :: ybeg real(kind=8), intent(in) :: yend real(kind=8), intent(in) :: d1 (n+1) real(kind=8), intent(in) :: d2 (n+1) real(kind=8), intent(in) :: d3 (n+1) real(kind=8), intent(inout) :: y (n+2) Contents","tags":"","loc":"proc\\teplova_khavin_solver.html"},{"title":"TK_abcoef – My Fortran project","text":"subroutine TK_abcoef(alfa2, a, b, c, f, y, dt, n, ybeg, yend, xx, h, df) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: alfa2 real(kind=8), intent(inout) :: a (n) real(kind=8), intent(inout) :: b (n) real(kind=8), intent(inout) :: c (n) real(kind=8), intent(inout) :: f (n) real(kind=8), intent(inout) :: y (n+2) real(kind=8), intent(in) :: dt integer, intent(in) :: n real(kind=8), intent(in) :: ybeg real(kind=8), intent(in) :: yend real(kind=8), intent(in) :: xx (n+1) real(kind=8), intent(in) :: h real(kind=8), intent(in) :: df (n+1) Contents","tags":"","loc":"proc\\tk_abcoef.html"},{"title":"write_v_array – My Fortran project","text":"subroutine write_v_array(v, a, time, array_name) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v (:,:) real(kind=8), intent(in) :: a (:,:,:) real(kind=8), intent(in) :: time character(len=*), intent(in) :: array_name Contents","tags":"","loc":"proc\\write_v_array.html"},{"title":"write_x_array – My Fortran project","text":"subroutine write_x_array(x, arr, time, array_name) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: x (:,:) real(kind=8), intent(in) :: arr (:,:) real(kind=8), intent(in) :: time character(len=*), intent(in) :: array_name Contents","tags":"","loc":"proc\\write_x_array.html"},{"title":"write_matrix – My Fortran project","text":"subroutine write_matrix(arr, time, array_name) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: arr (:,:) real(kind=8), intent(in) :: time character(len=*), intent(in) :: array_name Contents","tags":"","loc":"proc\\write_matrix.html"},{"title":"write_array – My Fortran project","text":"subroutine write_array(arr, N, array_name) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: arr (*) integer, intent(in) :: N character(len=*), intent(in) :: array_name Contents","tags":"","loc":"proc\\write_array.html"},{"title":"write_distribution – My Fortran project","text":"subroutine write_distribution(arr, N, time) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: arr (*) integer, intent(in) :: N real(kind=8), intent(in) :: time Contents","tags":"","loc":"proc\\write_distribution.html"},{"title":"FokkerPlanck1D_constructor – My Fortran project","text":"public  function FokkerPlanck1D_constructor(e, v_lim, v, f) result(this) Arguments Type Intent Optional Attributes Name real(kind=dp), value :: e real(kind=dp), value :: v_lim real(kind=dp), value :: v (:) real(kind=dp), value :: f (:) Return Value type( FokkerPlanck1D ) Contents","tags":"","loc":"proc\\fokkerplanck1d_constructor.html"},{"title":"FokkerPlanck1D_print – My Fortran project","text":"public  subroutine FokkerPlanck1D_print(this) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(in) :: this Contents","tags":"","loc":"proc\\fokkerplanck1d_print.html"},{"title":"FokkerPlanck1D_init_zero_diffusion – My Fortran project","text":"public  subroutine FokkerPlanck1D_init_zero_diffusion(this) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this Contents","tags":"","loc":"proc\\fokkerplanck1d_init_zero_diffusion.html"},{"title":"FokkerPlanck1D_init_diffusion – My Fortran project","text":"public  subroutine FokkerPlanck1D_init_diffusion(this, dif) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this real(kind=dp), intent(in), dimension(:) :: dif Contents","tags":"","loc":"proc\\fokkerplanck1d_init_diffusion.html"},{"title":"FokkerPlanck1D_solve_time_step – My Fortran project","text":"public  subroutine FokkerPlanck1D_solve_time_step(this, dt, nt) !!!! grid !!!!!!!!!\n  shift=h*0.1d0 !0.01d0\n!!!!!!!!!!   solve problem   !!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this real(kind=dp), intent(in) :: dt integer, intent(in) :: nt Contents","tags":"","loc":"proc\\fokkerplanck1d_solve_time_step.html"},{"title":"FokkerPlanck1D – My Fortran project","text":"public interface FokkerPlanck1D Contents Module Procedures FokkerPlanck1D_constructor Module Procedures public  function FokkerPlanck1D_constructor (e, v_lim, v, f) result(this) Arguments Type Intent Optional Attributes Name real(kind=dp), value :: e real(kind=dp), value :: v_lim real(kind=dp), value :: v (:) real(kind=dp), value :: f (:) Return Value type( FokkerPlanck1D )","tags":"","loc":"interface\\fokkerplanck1d.html"},{"title":"polin – My Fortran project","text":"public  function polin(k, x) Arguments Type Intent Optional Attributes Name integer :: k real(kind=dp) :: x Return Value doubleprecision Contents","tags":"","loc":"proc\\polin.html"},{"title":"polin1 – My Fortran project","text":"public  function polin1(k, x) Arguments Type Intent Optional Attributes Name integer :: k real(kind=dp) :: x Return Value doubleprecision Contents","tags":"","loc":"proc\\polin1.html"},{"title":"polin2 – My Fortran project","text":"public  function polin2(k, x) Arguments Type Intent Optional Attributes Name integer :: k real(kind=dp) :: x Return Value doubleprecision Contents","tags":"","loc":"proc\\polin2.html"},{"title":"fdf – My Fortran project","text":"public  function fdf(x, c, n, df) Arguments Type Intent Optional Attributes Name real(kind=dp) :: x real(kind=dp) :: c (n) integer :: n real(kind=dp) :: df Return Value doubleprecision Contents","tags":"","loc":"proc\\fdf.html"},{"title":"fdfddf – My Fortran project","text":"public  function fdfddf(x, c, n, df, ddf) Arguments Type Intent Optional Attributes Name real(kind=dp) :: x real(kind=dp) :: c (n) integer :: n real(kind=dp) :: df real(kind=dp) :: ddf Return Value doubleprecision Contents","tags":"","loc":"proc\\fdfddf.html"},{"title":"approx – My Fortran project","text":"public  subroutine approx(x, y, n, f, m, b) Arguments Type Intent Optional Attributes Name real(kind=dp) :: x (n) real(kind=dp) :: y (n) integer :: n real :: f integer :: m real(kind=dp) :: b (*) Contents","tags":"","loc":"proc\\approx.html"},{"title":"ludcmp – My Fortran project","text":"public  subroutine ludcmp(a, n, np, indx, d) Arguments Type Intent Optional Attributes Name real(kind=dp) :: a (np,np) integer :: n integer :: np real(kind=dp) :: indx (n) real :: d Contents","tags":"","loc":"proc\\ludcmp.html"},{"title":"lubksb – My Fortran project","text":"public  subroutine lubksb(a, n, np, indx, b) Arguments Type Intent Optional Attributes Name real(kind=dp) :: a (np,np) integer :: n integer :: np real(kind=dp) :: indx (n) real(kind=dp) :: b (n) Contents","tags":"","loc":"proc\\lubksb.html"},{"title":"chebev – My Fortran project","text":"public  function chebev(a, b, c, m, x) Arguments Type Intent Optional Attributes Name double precision :: a double precision :: b double precision :: c (m) integer :: m double precision :: x Return Value double precision Contents","tags":"","loc":"proc\\chebev.html"},{"title":"chebft1 – My Fortran project","text":"public  subroutine chebft1(a, b, c, n, func) Arguments Type Intent Optional Attributes Name double precision :: a double precision :: b double precision :: c (n) integer :: n double precision :: func Contents","tags":"","loc":"proc\\chebft1.html"},{"title":"chder – My Fortran project","text":"public  subroutine chder(a, b, c, cder, n) Arguments Type Intent Optional Attributes Name double precision :: a double precision :: b double precision :: c (n) double precision :: cder (n) integer :: n Contents","tags":"","loc":"proc\\chder.html"},{"title":"funmaxwell – My Fortran project","text":"public  function funmaxwell(v, dfunmaxwell) Arguments Type Intent Optional Attributes Name real(kind=8) :: v real(kind=8) :: dfunmaxwell Return Value doubleprecision Contents","tags":"","loc":"proc\\funmaxwell.html"},{"title":"fmaxw_classic – My Fortran project","text":"public  function fmaxw_classic(v, alfa2, dfmaxw) Arguments Type Intent Optional Attributes Name real(kind=8) :: v real(kind=8) :: alfa2 real(kind=8) :: dfmaxw Return Value doubleprecision Contents","tags":"","loc":"proc\\fmaxw_classic.html"},{"title":"fmaxw_ext – My Fortran project","text":"public  function fmaxw_ext(v, alfa2, dfmaxw) Arguments Type Intent Optional Attributes Name real(kind=8) :: v real(kind=8) :: alfa2 real(kind=8) :: dfmaxw Return Value doubleprecision Contents","tags":"","loc":"proc\\fmaxw_ext.html"},{"title":"fmaxw – My Fortran project","text":"public  function fmaxw(v, alfa2, dfmaxw) Arguments Type Intent Optional Attributes Name real(kind=8) :: v real(kind=8) :: alfa2 real(kind=8) :: dfmaxw Return Value doubleprecision Contents","tags":"","loc":"proc\\fmaxw.html"},{"title":"psiq – My Fortran project","text":"public  function psiq(v, alfa2) ! psiq=exp(ksiV 2) erfcc(ksiV) exp(-0.25/alfa2) Arguments Type Intent Optional Attributes Name double precision :: v double precision :: alfa2 Return Value doubleprecision Contents","tags":"","loc":"proc\\psiq.html"},{"title":"erfcc – My Fortran project","text":"public  function erfcc(x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision Contents","tags":"","loc":"proc\\erfcc.html"},{"title":"init_vi – My Fortran project","text":"public  subroutine init_vi(vclt, vi) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: vclt real(kind=8), intent(out) :: vi (i0) Contents","tags":"","loc":"proc\\init_vi.html"},{"title":"init_fmaxw_classic – My Fortran project","text":"public  subroutine init_fmaxw_classic(vclt, enorm, fi, dfi) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: vclt real(kind=8), intent(in) :: enorm real(kind=8), intent(out) :: fi (i0) real(kind=8), intent(out) :: dfi (i0) Contents","tags":"","loc":"proc\\init_fmaxw_classic.html"},{"title":"init_fmaxw_ext – My Fortran project","text":"public  subroutine init_fmaxw_ext(vclt, enorm, fi, dfi) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: vclt real(kind=8), intent(in) :: enorm real(kind=8), intent(out) :: fi (i0) real(kind=8), intent(out) :: dfi (i0) Contents","tags":"","loc":"proc\\init_fmaxw_ext.html"},{"title":"fn – My Fortran project","text":"public  function fn(x) Uses spline Arguments Type Intent Optional Attributes Name real :: x Return Value doubleprecision Contents","tags":"","loc":"proc\\fn.html"},{"title":"fvt – My Fortran project","text":"public  function fvt(r) Arguments Type Intent Optional Attributes Name real :: r Return Value doubleprecision Contents","tags":"","loc":"proc\\fvt.html"},{"title":"ft – My Fortran project","text":"public  function ft(x) Uses spline ft=y            ! kev Arguments Type Intent Optional Attributes Name real :: x Return Value doubleprecision Contents","tags":"","loc":"proc\\ft.html"},{"title":"obeom – My Fortran project","text":"public  function obeom(ptet, pa) Uses constants approximation Arguments Type Intent Optional Attributes Name real :: ptet real :: pa Return Value doubleprecision Contents","tags":"","loc":"proc\\obeom.html"},{"title":"ploshad – My Fortran project","text":"public  function ploshad(ptet, pa) Uses constants approximation Arguments Type Intent Optional Attributes Name real :: ptet real :: pa Return Value doubleprecision Contents","tags":"","loc":"proc\\ploshad.html"},{"title":"gaussint – My Fortran project","text":"public  function gaussint(f, a, b, r, eps) Arguments Type Intent Optional Attributes Name real(kind=dp) :: f real(kind=dp) :: a real(kind=dp) :: b real(kind=dp) :: r real(kind=dp) :: eps Return Value real(kind=dp) Contents","tags":"","loc":"proc\\gaussint.html"},{"title":"init_plasma – My Fortran project","text":"public  subroutine init_plasma(NA1, ABC, BTOR, RTOR, UPDWN, GP2, AMETR, RHO, SHIF, ELON, TRIA, MU, NE, TE, TI, ZEF, UPL) Uses approximation chebyshev rt_parameters constants spline variant\n amy=(btor/q) rho (drho/dr) is a function of \"minor radius\" r=rh(i).\n Poloidal magnetic field: B_pol=amy(r)*sqrt(g22/g), where g is\n determinant of 3D metric tensor and g22 is the (22) element of\n the tensor, normalized on ABC&#94;4 and ABC&#94;2, correspondingly. Polinomial approximation of the amy(r): !!!!!!!!!!!!! spline approximation of plasma profiles !!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name integer, intent(in) :: NA1 real(kind=dp), intent(in) :: ABC real(kind=dp), intent(in) :: BTOR real(kind=dp), intent(in) :: RTOR real(kind=dp), intent(in) :: UPDWN real(kind=dp), intent(in) :: GP2 real(kind=dp), dimension(*) :: AMETR real(kind=dp), dimension(*) :: RHO real(kind=dp), dimension(*) :: SHIF real(kind=dp), dimension(*) :: ELON real(kind=dp), dimension(*) :: TRIA real(kind=dp), dimension(*) :: MU real(kind=dp), dimension(*) :: NE real(kind=dp), dimension(*) :: TE real(kind=dp), dimension(*) :: TI real(kind=dp), dimension(*) :: ZEF real(kind=dp), dimension(*) :: UPL Contents","tags":"","loc":"proc\\init_plasma.html"},{"title":"init_parameters – My Fortran project","text":"public  subroutine init_parameters() Uses constants approximation rt_parameters !!!!!!      ptkev=ft(zero)/0.16d-8  !Te in keV\n      ccurnr=pqe pqe 0.333d-9/pme Arguments None Contents None","tags":"","loc":"proc\\init_parameters.html"},{"title":"find_volums_and_surfaces – My Fortran project","text":"public  subroutine find_volums_and_surfaces() Uses constants rt_parameters Arguments None Contents None","tags":"","loc":"proc\\find_volums_and_surfaces.html"},{"title":"read_positive_spectrum – My Fortran project","text":"public  subroutine read_positive_spectrum(file_name, p_in) Arguments Type Intent Optional Attributes Name character :: file_name real(kind=dp) :: p_in Contents","tags":"","loc":"proc\\read_positive_spectrum.html"},{"title":"read_negative_spectrum – My Fortran project","text":"public  subroutine read_negative_spectrum(file_name, p_in) Arguments Type Intent Optional Attributes Name character :: file_name real(kind=dp) :: p_in Contents","tags":"","loc":"proc\\read_negative_spectrum.html"},{"title":"sys_time – My Fortran project","text":"public  function sys_time() Arguments None Return Value real(kind=8) Contents None","tags":"","loc":"proc\\sys_time.html"},{"title":"show_parameters – My Fortran project","text":"public  subroutine show_parameters() Arguments None Contents None","tags":"","loc":"proc\\show_parameters.html"},{"title":"read_parameters – My Fortran project","text":"public  subroutine read_parameters(file_name) !!!!!!!!!!!  read  physical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read parameters for alphas calculation !!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read  numerical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read  options !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read grill parameters and input LH spectrum !!!!!!!!!!!!\n!!!!!!!!!!! checking initial parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name character :: file_name Contents","tags":"","loc":"proc\\read_parameters.html"},{"title":"splne – My Fortran project","text":"public  subroutine splne(x, y, n, y2) Arguments Type Intent Optional Attributes Name real(kind=8) :: x (n) real(kind=8) :: y (n) integer :: n real(kind=8) :: y2 (n) Contents","tags":"","loc":"proc\\splne.html"},{"title":"splnt – My Fortran project","text":"public  subroutine splnt(xa, ya, y2a, n, x, y, dy) Arguments Type Intent Optional Attributes Name real(kind=8) :: xa (n) real(kind=8) :: ya (n) real(kind=8) :: y2a (n) integer :: n real(kind=8) :: x real(kind=8) :: y real(kind=8) :: dy Contents","tags":"","loc":"proc\\splnt.html"},{"title":"dsplnt – My Fortran project","text":"public  subroutine dsplnt(xa, ya, y2a, n, x, y, dy, ddy) Arguments Type Intent Optional Attributes Name real(kind=8) :: xa (n) real(kind=8) :: ya (n) real(kind=8) :: y2a (n) integer :: n real(kind=8) :: x real(kind=8) :: y real(kind=8) :: dy real(kind=8) :: ddy Contents","tags":"","loc":"proc\\dsplnt.html"},{"title":"FokkerPlanck1D_mod – My Fortran project","text":"Uses iso_fortran_env Contents Interfaces FokkerPlanck1D Derived Types FokkerPlanck1D Functions FokkerPlanck1D_constructor Subroutines FokkerPlanck1D_print FokkerPlanck1D_init_zero_diffusion FokkerPlanck1D_init_diffusion FokkerPlanck1D_solve_time_step Interfaces public        interface FokkerPlanck1D public  function FokkerPlanck1D_constructor (e, v_lim, v, f) result(this) Arguments Type Intent Optional Attributes Name real(kind=dp), value :: e real(kind=dp), value :: v_lim real(kind=dp), value :: v (:) real(kind=dp), value :: f (:) Return Value type( FokkerPlanck1D ) Derived Types type, public :: FokkerPlanck1D Components Type Visibility Attributes Name Initial real(kind=dp), public :: enorm = 0 real(kind=dp), public :: v_lim = 0 real(kind=dp), public, allocatable :: v (:) real(kind=dp), public, allocatable :: f (:) integer, public :: i0 = 0 real(kind=dp), public :: alfa2 = 0 integer, public :: n = 0 real(kind=dp), public :: h = 0 real(kind=dp), public, allocatable :: d1 (:) real(kind=dp), public, allocatable :: d2 (:) real(kind=dp), public, allocatable :: d3 (:) Constructor public\n\n                    \n                    function FokkerPlanck1D_constructor (e, v_lim, v, f) Type-Bound Procedures procedure\n                    ,                  public\n                  :: print => FokkerPlanck1D_print Subroutine procedure\n                    ,                  public\n                  :: solve_time_step => FokkerPlanck1D_solve_time_step Subroutine procedure\n                    ,                  public\n                  :: init_zero_diffusion => FokkerPlanck1D_init_zero_diffusion Subroutine procedure\n                    ,                  public\n                  :: init_diffusion => FokkerPlanck1D_init_diffusion Subroutine Functions public  function FokkerPlanck1D_constructor (e, v_lim, v, f) result(this) Arguments Type Intent Optional Attributes Name real(kind=dp), value :: e real(kind=dp), value :: v_lim real(kind=dp), value :: v (:) real(kind=dp), value :: f (:) Return Value type( FokkerPlanck1D ) Subroutines public  subroutine FokkerPlanck1D_print (this) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(in) :: this public  subroutine FokkerPlanck1D_init_zero_diffusion (this) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this public  subroutine FokkerPlanck1D_init_diffusion (this, dif) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this real(kind=dp), intent(in), dimension(:) :: dif public  subroutine FokkerPlanck1D_solve_time_step (this, dt, nt) !!!! grid !!!!!!!!!\n  shift=h*0.1d0 !0.01d0\n!!!!!!!!!!   solve problem   !!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this real(kind=dp), intent(in) :: dt integer, intent(in) :: nt","tags":"","loc":"module\\fokkerplanck1d_mod.html"},{"title":"approximation – My Fortran project","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses iso_fortran_env Contents Functions polin polin1 polin2 fdf fdfddf Subroutines approx ludcmp lubksb Functions public  function polin (k, x) Arguments Type Intent Optional Attributes Name integer :: k real(kind=dp) :: x Return Value doubleprecision public  function polin1 (k, x) Arguments Type Intent Optional Attributes Name integer :: k real(kind=dp) :: x Return Value doubleprecision public  function polin2 (k, x) Arguments Type Intent Optional Attributes Name integer :: k real(kind=dp) :: x Return Value doubleprecision public  function fdf (x, c, n, df) Arguments Type Intent Optional Attributes Name real(kind=dp) :: x real(kind=dp) :: c (n) integer :: n real(kind=dp) :: df Return Value doubleprecision public  function fdfddf (x, c, n, df, ddf) Arguments Type Intent Optional Attributes Name real(kind=dp) :: x real(kind=dp) :: c (n) integer :: n real(kind=dp) :: df real(kind=dp) :: ddf Return Value doubleprecision Subroutines public  subroutine approx (x, y, n, f, m, b) Arguments Type Intent Optional Attributes Name real(kind=dp) :: x (n) real(kind=dp) :: y (n) integer :: n real :: f integer :: m real(kind=dp) :: b (*) public  subroutine ludcmp (a, n, np, indx, d) Arguments Type Intent Optional Attributes Name real(kind=dp) :: a (np,np) integer :: n integer :: np real(kind=dp) :: indx (n) real :: d public  subroutine lubksb (a, n, np, indx, b) Arguments Type Intent Optional Attributes Name real(kind=dp) :: a (np,np) integer :: n integer :: np real(kind=dp) :: indx (n) real(kind=dp) :: b (n)","tags":"","loc":"module\\approximation.html"},{"title":"chebyshev – My Fortran project","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Contents Functions chebev Subroutines chebft1 chder Functions public  function chebev (a, b, c, m, x) Arguments Type Intent Optional Attributes Name double precision :: a double precision :: b double precision :: c (m) integer :: m double precision :: x Return Value double precision Subroutines public  subroutine chebft1 (a, b, c, n, func) Arguments Type Intent Optional Attributes Name double precision :: a double precision :: b double precision :: c (n) integer :: n double precision :: func public  subroutine chder (a, b, c, cder, n) Arguments Type Intent Optional Attributes Name double precision :: a double precision :: b double precision :: c (n) double precision :: cder (n) integer :: n","tags":"","loc":"module\\chebyshev.html"},{"title":"constants – My Fortran project","text":"модуль с математическими и физическими константами Uses iso_fortran_env Contents Variables pi pi2 pi4 piq zero one two tiny tin talfa zalfa xmalfa clt pme pqe xlog c0 c1 xsgs xwtt cnst1 cnst2 Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: pi = 4.d0*datan(1.d0) число Пи = 3.1415.... real(kind=dp), public, parameter :: pi2 = 2.d0*pi real(kind=dp), public, parameter :: pi4 = 4.d0*pi real(kind=dp), public, parameter :: piq = dsqrt(pi) real(kind=dp), public, parameter :: zero = 0.d0 real(kind=dp), public, parameter :: one = 1.d0 real(kind=dp), public, parameter :: two = 2.d0 real(kind=dp), public, parameter :: tiny = 1.d-100 real(kind=dp), public, parameter :: tin = 1d-7 real(kind=dp), public, parameter :: talfa = 3.5d0 alpha particles' birth energy, MeV real(kind=dp), public, parameter :: zalfa = 2.d0 alpha particles' electrical charge real(kind=dp), public, parameter :: xmalfa = 4.d0 alpha particles' atomic mass real(kind=dp), public, parameter :: clt = 3.0d+10 скорость света real(kind=dp), public, parameter :: pme = 9.11e-28 real(kind=dp), public, parameter :: pqe = 4.803e-10 real(kind=dp), public, parameter :: xlog = 16.d0+dlog(16.d0) real(kind=dp), public, parameter :: c0 = dsqrt(pi4*pqe**2/pme) real(kind=dp), public, parameter :: c1 = pqe/pme/clt real(kind=dp), public, parameter :: xsgs = 1d+13 real(kind=dp), public, parameter :: xwtt = 1d-7 real(kind=dp), public, parameter :: cnst1 = 0.2965924106d-6 cnst1=(m_e/m_p)**2, CGS real(kind=dp), public, parameter :: cnst2 = 0.359680922d-35 cnst2=(m_e/e)**2,  CGS","tags":"","loc":"module\\constants.html"},{"title":"FluxSurface_mod – My Fortran project","text":"все что связанно с магнитными поверхностями Uses iso_fortran_env Contents Derived Types FluxSurface Derived Types type, public :: FluxSurface класс магнитной поверхности Components Type Visibility Attributes Name Initial integer, public :: index номер магнитной поверхности real(kind=dp), public :: r радиус real(kind=dp), public :: vmax vmax=cltn/vto real(kind=dp), public :: vt наверно тепловая скорость электронов????? vt=fvt(r) integer, public :: ipt размер vgrid real(kind=dp), public, allocatable :: vgrid (:) real(kind=dp), public, allocatable :: vr_grid (:) бываший vrj real(kind=dp), public, allocatable :: diffusion (:) бывший dijk(i,j,k) или dj(i)","tags":"","loc":"module\\fluxsurface_mod.html"},{"title":"maxwell – My Fortran project","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses constants iso_fortran_env Contents Variables i0 vij fij0 fij dfij dij enorm fst Functions funmaxwell fmaxw_classic fmaxw_ext fmaxw psiq erfcc Subroutines init_vi init_fmaxw_classic init_fmaxw_ext Variables Type Visibility Attributes Name Initial integer, public, parameter :: i0 = 1002 real(kind=dp), public :: vij (i0,100) real(kind=dp), public :: fij0 (i0,100,2) real(kind=dp), public :: fij (i0,100,2) real(kind=dp), public :: dfij (i0,100,2) real(kind=dp), public :: dij (i0,100,2) real(kind=dp), public :: enorm (100) real(kind=dp), public :: fst (100) Functions public  function funmaxwell (v, dfunmaxwell) Arguments Type Intent Optional Attributes Name real(kind=8) :: v real(kind=8) :: dfunmaxwell Return Value doubleprecision public  function fmaxw_classic (v, alfa2, dfmaxw) Arguments Type Intent Optional Attributes Name real(kind=8) :: v real(kind=8) :: alfa2 real(kind=8) :: dfmaxw Return Value doubleprecision public  function fmaxw_ext (v, alfa2, dfmaxw) Arguments Type Intent Optional Attributes Name real(kind=8) :: v real(kind=8) :: alfa2 real(kind=8) :: dfmaxw Return Value doubleprecision public  function fmaxw (v, alfa2, dfmaxw) Arguments Type Intent Optional Attributes Name real(kind=8) :: v real(kind=8) :: alfa2 real(kind=8) :: dfmaxw Return Value doubleprecision public  function psiq (v, alfa2) ! psiq=exp(ksiV 2) erfcc(ksiV) exp(-0.25/alfa2) Arguments Type Intent Optional Attributes Name double precision :: v double precision :: alfa2 Return Value doubleprecision public  function erfcc (x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision Subroutines public  subroutine init_vi (vclt, vi) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: vclt real(kind=8), intent(out) :: vi (i0) public  subroutine init_fmaxw_classic (vclt, enorm, fi, dfi) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: vclt real(kind=8), intent(in) :: enorm real(kind=8), intent(out) :: fi (i0) real(kind=8), intent(out) :: dfi (i0) public  subroutine init_fmaxw_ext (vclt, enorm, fi, dfi) Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: vclt real(kind=8), intent(in) :: enorm real(kind=8), intent(out) :: fi (i0) real(kind=8), intent(out) :: dfi (i0)","tags":"","loc":"module\\maxwell.html"},{"title":"plasma – My Fortran project","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses iso_fortran_env Contents Variables ngrid nspl tcur rm b_tor0 b_tor r0 z0 rh1 con tem temi zeff afld rh rha drhodr delta ell gamm amy tet1 tet2 xmi cnye cnyi xsz vt0 cnstvc ww cltn vperp cnstal zza zze valfa vpmax vk sk ipsy ncoef cdl cly cgm cmy coeffs y2dn y2tm y2tmi y2zeff ncheb chebne chebdne chebddne Functions fn fvt ft obeom ploshad gaussint Subroutines init_plasma init_parameters find_volums_and_surfaces Variables Type Visibility Attributes Name Initial integer, public :: ngrid ASTRA radial grid number integer, public :: nspl ASTRA radial grid number real(kind=dp), public :: tcur время (придумать название для переменной получше) real(kind=dp), public :: rm minor radius in mid-plane, cm real(kind=dp), public :: b_tor0 временно нужно две переменных, тоже нужно исправить real(kind=dp), public :: b_tor временно нужно две переменных, тоже нужно исправить real(kind=dp), public :: r0 real(kind=dp), public :: z0 real(kind=dp), public :: rh1 real(kind=dp), public, dimension(:), allocatable :: con real(kind=dp), public, dimension(:), allocatable :: tem real(kind=dp), public, dimension(:), allocatable :: temi real(kind=dp), public, dimension(:), allocatable :: zeff real(kind=dp), public, dimension(:), allocatable :: afld real(kind=dp), public, dimension(:), allocatable :: rh real(kind=dp), public, dimension(:), allocatable :: rha real(kind=dp), public, dimension(:), allocatable :: drhodr real(kind=dp), public, dimension(:), allocatable :: delta real(kind=dp), public, dimension(:), allocatable :: ell real(kind=dp), public, dimension(:), allocatable :: gamm real(kind=dp), public, dimension(:), allocatable :: amy real(kind=dp), public :: tet1 бывший common /a0a2/ real(kind=dp), public :: tet2 бывший common /a0a2/ real(kind=dp), public :: xmi real(kind=dp), public :: cnye real(kind=dp), public :: cnyi real(kind=dp), public :: xsz real(kind=dp), public :: vt0 real(kind=dp), public :: cnstvc real(kind=dp), public :: ww real(kind=dp), public :: cltn real(kind=dp), public :: vperp (50,100) real(kind=dp), public :: cnstal real(kind=dp), public :: zza real(kind=dp), public :: zze real(kind=dp), public :: valfa real(kind=dp), public :: vpmax real(kind=dp), public :: vk (100) real(kind=dp), public :: sk (100) integer, public, parameter :: ipsy = 5 ipsy = number of polinomial decomposition coefficients\nused for interpolation of Zakharov's moments. integer, public, parameter :: ncoef = 5 ipsy = number of polinomial decomposition coefficients\nused for interpolation of Zakharov's moments. real(kind=dp), public, dimension(ipsy) :: cdl real(kind=dp), public, dimension(ipsy) :: cly real(kind=dp), public, dimension(ipsy) :: cgm real(kind=dp), public, dimension(ipsy) :: cmy real(kind=dp), public, dimension(ipsy) :: coeffs real(kind=dp), public :: y2dn (501) бывший common /a0l3/ real(kind=dp), public :: y2tm (501) бывший common /a0l3/ real(kind=dp), public :: y2tmi (501) бывший common /a0l3/ real(kind=dp), public :: y2zeff (501) бывший common /a0l5/ integer, public :: ncheb real(kind=dp), public :: chebne (50) бывший common/ne_cheb real(kind=dp), public :: chebdne (50) бывший common/ne_cheb real(kind=dp), public :: chebddne (50) бывший common/ne_cheb Functions public  function fn (x) Arguments Type Intent Optional Attributes Name real :: x Return Value doubleprecision public  function fvt (r) Arguments Type Intent Optional Attributes Name real :: r Return Value doubleprecision public  function ft (x) ft=y            ! kev Arguments Type Intent Optional Attributes Name real :: x Return Value doubleprecision public  function obeom (ptet, pa) Arguments Type Intent Optional Attributes Name real :: ptet real :: pa Return Value doubleprecision public  function ploshad (ptet, pa) Arguments Type Intent Optional Attributes Name real :: ptet real :: pa Return Value doubleprecision public  function gaussint (f, a, b, r, eps) Arguments Type Intent Optional Attributes Name real(kind=dp) :: f real(kind=dp) :: a real(kind=dp) :: b real(kind=dp) :: r real(kind=dp) :: eps Return Value real(kind=dp) Subroutines public  subroutine init_plasma (NA1, ABC, BTOR, RTOR, UPDWN, GP2, AMETR, RHO, SHIF, ELON, TRIA, MU, NE, TE, TI, ZEF, UPL) variant\n amy=(btor/q) rho (drho/dr) is a function of \"minor radius\" r=rh(i).\n Poloidal magnetic field: B_pol=amy(r)*sqrt(g22/g), where g is\n determinant of 3D metric tensor and g22 is the (22) element of\n the tensor, normalized on ABC&#94;4 and ABC&#94;2, correspondingly. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: NA1 real(kind=dp), intent(in) :: ABC real(kind=dp), intent(in) :: BTOR real(kind=dp), intent(in) :: RTOR real(kind=dp), intent(in) :: UPDWN real(kind=dp), intent(in) :: GP2 real(kind=dp), dimension(*) :: AMETR real(kind=dp), dimension(*) :: RHO real(kind=dp), dimension(*) :: SHIF real(kind=dp), dimension(*) :: ELON real(kind=dp), dimension(*) :: TRIA real(kind=dp), dimension(*) :: MU real(kind=dp), dimension(*) :: NE real(kind=dp), dimension(*) :: TE real(kind=dp), dimension(*) :: TI real(kind=dp), dimension(*) :: ZEF real(kind=dp), dimension(*) :: UPL public  subroutine init_parameters () !!!!!!      ptkev=ft(zero)/0.16d-8  !Te in keV\n      ccurnr=pqe pqe 0.333d-9/pme Arguments None public  subroutine find_volums_and_surfaces () Arguments None","tags":"","loc":"module\\plasma.html"},{"title":"spectrum1D – My Fortran project","text":"Uses iso_fortran_env Contents Variables ispl plaun ynzm0 pm0 Subroutines read_positive_spectrum read_negative_spectrum Variables Type Visibility Attributes Name Initial integer, public :: ispl real(kind=dp), public :: plaun real(kind=dp), public :: ynzm0 (1001) real(kind=dp), public :: pm0 (1001) Subroutines public  subroutine read_positive_spectrum (file_name, p_in) Arguments Type Intent Optional Attributes Name character :: file_name real(kind=dp) :: p_in public  subroutine read_negative_spectrum (file_name, p_in) Arguments Type Intent Optional Attributes Name character :: file_name real(kind=dp) :: p_in","tags":"","loc":"module\\spectrum1d.html"},{"title":"Utils – My Fortran project","text":"Contents Functions sys_time Functions public  function sys_time () Arguments None Return Value real(kind=8)","tags":"","loc":"module\\utils.html"},{"title":"rt_parameters – My Fortran project","text":"Uses iso_fortran_env Contents Variables freq xmi1 zi1 xmi2 zi2 dni2 xmi3 zi3 dni3 itend0 energy factor dra kv nr hmin1 rrange eps hdrob cleft cright cdel rbord pchm pabs0 pgiter ni1 ni2 niterat nmaxm maxstep2 maxstep4 ipri iw ismth ismthalf ismthout inew itor i_pol zplus zminus ntet nnz Subroutines show_parameters read_parameters Variables Type Visibility Attributes Name Initial real(kind=dp), public :: freq Freq,     RF frequency, GHz real(kind=dp), public :: xmi1 Mi1/Mp,  relative mass of ions 1 real(kind=dp), public :: zi1 charge of ions 1 real(kind=dp), public :: xmi2 Mi2/Mp,  relative mass of ions 2 real(kind=dp), public :: zi2 charge of ions 2 real(kind=dp), public :: dni2 0.03   Ni2/Ni1, relative density of ions 2 real(kind=dp), public :: xmi3 Mi3/Mp,  relative mass of ions 3 real(kind=dp), public :: zi3 charge of ions 3 real(kind=dp), public :: dni3 Ni3/Ni1, relative density of ions 3 !!!!!!!!!!!  parameters for alphas calculations !!! integer, public :: itend0 itend0,   if = 0, no alphas real(kind=dp), public :: energy energy,   max. perp. energy of alphas (MeV) real(kind=dp), public :: factor factor,   factor in alpha source real(kind=dp), public :: dra dra,      relative alpha source broadening (dr/a) integer, public :: kv kv,       V_perp  greed number !!!!!!!!!!! numerical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!! integer, public :: nr nr,  radial grid number  <= 505 real(kind=dp), public :: hmin1 hmin1, rel.(hr) min. step in the Fast comp. mode, <1.d0 real(kind=dp), public :: rrange rrange,   rel.(hr) size of a 'turning' point region, <1.d0 real(kind=dp), public :: eps eps,      accuracy real(kind=dp), public :: hdrob hdrob,    h4 correction, real(kind=dp), public :: cleft cleft,    left Vz plato border shift (<1) real(kind=dp), public :: cright cright,   right Vz plato border shift (>1) real(kind=dp), public :: cdel cdel,     (left part)/(Vz plato size) real(kind=dp), public :: rbord rbord,    relative radius of reflection, <1. real(kind=dp), public :: pchm pchm,     threshold between 'strong' and weak' absorption, <1. real(kind=dp), public :: pabs0 pabs,     part of remaining power interp. as absorption real(kind=dp), public :: pgiter pgiter,   relative accuracy to stop iterations integer, public :: ni1 ni1,      grid number in the left part of Vz plato integer, public :: ni2 ni2,      grid number in the right part of Vz plato integer, public :: niterat niterat,  maximal number of iterations integer, public :: nmaxm (4) nmaxm(1), permitted reflections at 0 iteration\nnmaxm(2), permitted reflections at 1 iteration\nnmaxm(3), permitted reflections at 2 iteration\nnmaxm(4), permitted reflections at 3 iteration integer, public :: maxstep2 maxstep2, maximal steps' number in Fast comp. mode integer, public :: maxstep4 maxstep4, maximal steps' number in Slow comp. mode !!!!!!!!!!!  options !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! integer, public :: ipri ipri, printing output monitoring: 0,1,2,3,4 integer, public :: iw iw, initial mode (slow=1, fast=-1) integer, public :: ismth ismth, if=0, no smoothing in Ne(rho),Te(rho),Ti(rho) integer, public :: ismthalf ismthalf,  if=0, no smoothing in D_alpha(vperp) integer, public :: ismthout ismthout,  if=0, no smoothing in output profiles integer, public :: inew inew=0 for usual tokamak&Ntor_grill; 1 or 2 for g' in ST&Npol_grill integer, public :: itor itor,      +-1, Btor direction in right coord{drho,dteta,dfi} integer, public :: i_pol ipol,      +-1, Bpol direction in right coord{drho,dteta,dfi} !!!!!!!!!!!  grill parameters and input LH spectrum !!!!!!!!!!!! real(kind=dp), public :: zplus Zplus,    upper grill corner in centimeters real(kind=dp), public :: zminus Zminus,   lower grill corner in centimeters integer, public :: ntet ntet,     theta grid number integer, public :: nnz nnz,      N_phi grid number Subroutines public  subroutine show_parameters () Arguments None public  subroutine read_parameters (file_name) !!!!!!!!!!!  read  physical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read parameters for alphas calculation !!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read  numerical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read  options !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read grill parameters and input LH spectrum !!!!!!!!!!!!\n!!!!!!!!!!! checking initial parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name character :: file_name","tags":"","loc":"module\\rt_parameters.html"},{"title":"spline – My Fortran project","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Contents Subroutines splne splnt dsplnt Subroutines public  subroutine splne (x, y, n, y2) Arguments Type Intent Optional Attributes Name real(kind=8) :: x (n) real(kind=8) :: y (n) integer :: n real(kind=8) :: y2 (n) public  subroutine splnt (xa, ya, y2a, n, x, y, dy) Arguments Type Intent Optional Attributes Name real(kind=8) :: xa (n) real(kind=8) :: ya (n) real(kind=8) :: y2a (n) integer :: n real(kind=8) :: x real(kind=8) :: y real(kind=8) :: dy public  subroutine dsplnt (xa, ya, y2a, n, x, y, dy, ddy) Arguments Type Intent Optional Attributes Name real(kind=8) :: xa (n) real(kind=8) :: ya (n) real(kind=8) :: y2a (n) integer :: n real(kind=8) :: x real(kind=8) :: y real(kind=8) :: dy real(kind=8) :: ddy","tags":"","loc":"module\\spline.html"},{"title":"a_FP1D_mod.f90 – My Fortran project","text":"Contents Modules FokkerPlanck1D_mod Source Code a_FP1D_mod.f90 Source Code module FokkerPlanck1D_mod ! the module name defines the namespace use , intrinsic :: iso_fortran_env , only : sp => real32 , dp => real64 implicit none type FokkerPlanck1D !- solver of FP eq !integer          :: direction = 0 !- direction real ( dp ) :: enorm = 0 !- электрическое поле real ( dp ) :: v_lim = 0 !- верхняя граница скорости электронов real ( dp ), allocatable :: v (:) !- сетка скоростей real ( dp ), allocatable :: f (:) !- распределение integer :: i0 = 0 !- size of distribution grid real ( dp ) :: alfa2 = 0 !- поле со знаком integer :: n = 0 !- size of local grid real ( dp ) :: h = 0 !- step of local grid real ( dp ), allocatable :: d1 (:), d2 (:), d3 (:) !- диффузия contains procedure :: print => FokkerPlanck1D_print procedure :: solve_time_step => FokkerPlanck1D_solve_time_step procedure :: init_zero_diffusion => FokkerPlanck1D_init_zero_diffusion procedure :: init_diffusion => FokkerPlanck1D_init_diffusion end type FokkerPlanck1D interface FokkerPlanck1D module procedure :: FokkerPlanck1D_constructor end interface FokkerPlanck1D contains function FokkerPlanck1D_constructor ( e , v_lim , v , f ) result ( this ) !- конструктор для FokkerPlanck1D implicit none type ( FokkerPlanck1D ) :: this real ( dp ), value :: e , v_lim , v (:), f (:) integer :: n real ( dp ) :: h real ( dp ), parameter :: h0 = 0.1d0 !this%inst_field1 = cmplx(0.,0.) this % enorm = abs ( e ) this % v_lim = v_lim this % v = v this % f = f this % i0 = size ( v ) this % alfa2 = e n = v_lim / h0 - 1 h = v_lim / dble ( n + 1 ) if ( h . gt . h0 ) then n = n + 1 h = v_lim / dble ( n + 1 ) end if this % n = n this % h = h end function FokkerPlanck1D_constructor subroutine FokkerPlanck1D_print ( this ) class ( FokkerPlanck1D ), intent ( in ) :: this print * , 'e = ' , this % enorm , 'i0 =' , this % i0 end subroutine FokkerPlanck1D_print subroutine FokkerPlanck1D_init_zero_diffusion ( this ) implicit none class ( FokkerPlanck1D ), intent ( inout ) :: this integer :: n n = this % n allocate ( this % d1 ( n + 1 ), this % d2 ( n + 1 ), this % d3 ( n + 1 )) this % d1 (:) = 0 d0 this % d2 (:) = 0 d0 this % d3 (:) = 0 d0 end subroutine FokkerPlanck1D_init_zero_diffusion subroutine FokkerPlanck1D_init_diffusion ( this , dif ) !- инициализация диффузии для схемы савельева implicit none class ( FokkerPlanck1D ), intent ( inout ) :: this integer :: n real ( dp ), dimension (:), intent ( in ) :: dif real ( dp ), dimension (:), allocatable :: xx real ( dp ) h integer :: i0 integer i , klo , khi , ierr , klo1 , khi1 integer klo2 , klo3 , khi2 , khi3 , ierr1 , ierr2 , ierr3 n = this % n h = this % h allocate ( this % d1 ( n + 1 ), this % d2 ( n + 1 ), this % d3 ( n + 1 )) i0 = this % i0 allocate ( xx ( n + 1 )) do i = 1 , n + 1 xx ( i ) = h / 2.d0 + h * dble ( i - 1 ) !+shift end do do i = 1 , n + 1 call lock ( this % v , i0 , xx ( i ), klo1 , khi1 , ierr1 ) call lock ( this % v , i0 , xx ( i ) - h / 2 d0 , klo2 , khi2 , ierr2 ) call lock ( this % v , i0 , xx ( i ) + h / 2 d0 , klo3 , khi3 , ierr3 ) if ( ierr1 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo1=' , klo1 , 'khi1=' , khi1 , 'i=' , i write ( * , * ) 'vj(1)=' , this % v ( 1 ), ' vj(i0)=' , this % v ( i0 ) pause stop end if if ( ierr2 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo2=' , klo2 , 'khi2=' , khi2 , 'i=' , i write ( * , * ) 'vj(1)=' , this % v ( 1 ), ' vj(i0)=' , this % v ( i0 ) pause stop end if if ( ierr3 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo3=' , klo3 , 'khi3=' , khi3 , 'i=' , i write ( * , * ) 'vj(1)=' , this % v ( 1 ), ' vj(i0)=' , this % v ( i0 ) pause stop end if this % d1 ( i ) = dif ( klo1 ) this % d2 ( i ) = dif ( klo2 ) this % d3 ( i ) = dif ( klo3 ) end do end subroutine FokkerPlanck1D_init_diffusion subroutine FokkerPlanck1D_solve_time_step ( this , dt , nt ) implicit none class ( FokkerPlanck1D ), intent ( inout ) :: this integer , intent ( in ) :: nt real ( dp ), intent ( in ) :: dt !real*8, intent (inout), optional :: dfj0(:) real ( dp ), parameter :: zero = 0.d0 real ( dp ) y ( this % n + 2 ), x ( this % n + 2 ) real ( dp ), dimension (:), allocatable :: fj , dfj , givi integer i , ii , it , ibeg , klo , khi , ierr , klo1 , khi1 real ( dp ) shift , ybeg , yend , tend , dff interface subroutine savelyev_solver ( alfa2 , nt , h , dt , n , ybeg , yend , d1 , d2 , d3 , y ) implicit none real * 8 , intent ( in ) :: alfa2 integer , intent ( in ) :: nt , n real * 8 , intent ( in ) :: h , dt real * 8 , intent ( in ) :: ybeg , yend real * 8 , intent ( in ) :: d1 ( n + 1 ), d2 ( n + 1 ), d3 ( n + 1 ) real * 8 , intent ( inout ) :: y ( n ) end subroutine subroutine burying_procedure ( v , f0 , df0 ) ! процедура закапывания implicit none real * 8 , intent ( in ) :: v (:) real * 8 , intent ( inout ) :: f0 (:) real * 8 , intent ( inout ), optional :: df0 (:) end subroutine end interface !!!!!! grid !!!!!!!!! !!  shift=h*0.1d0 !0.01d0 do i = 1 , this % n + 2 x ( i ) = this % h * dble ( i - 1 ) !+shift end do do i = 1 , this % n + 1 call lock ( this % v , this % i0 , x ( i + 1 ), klo , khi , ierr ) if ( ierr . eq . 1 ) then write ( * , * ) 'lock error #1 in finction fokkerplanck' write ( * , * ) 'j=' , 123 , ' v=' , x ( i + 1 ) write ( * , * ) 'vj(1)=' , this % v ( 1 ), ' vj(i0)=' , this % v ( this % i0 ) pause stop end if call linf ( this % v , this % f , x ( i + 1 ), y ( i ), klo , khi ) end do ybeg = this % f ( 1 ) !boundary conditions yend = this % f ( this % i0 ) !zero !print *, ' yend =', yend !!!!!!!!!!!!   solve problem   !!!!!!!!!!!!!!!!!!!!!!!!!! call savelyev_solver ( this % alfa2 , nt , this % h , dt , this % n , ybeg , yend , this % d1 , this % d2 , this % d3 , y ) !call teplova_khavin_solver(this%alfa2, nt, this%h, dt, this%n, ybeg, yend, this%d1,this%d2,this%d3, y) allocate ( fj ( this % n + 2 )) fj ( 1 ) = ybeg fj ( this % n + 2 ) = yend do i = 1 , this % n fj ( i + 1 ) = y ( i ) end do do i = 2 , this % i0 - 1 if ( this % v ( i ). lt . this % v_lim ) then call lock ( x , this % n + 2 , this % v ( i ), klo , khi , ierr ) if ( ierr . eq . 1 ) then write ( * , * ) 'lock error #2 in finction fokkerplanck' write ( * , * ) 'j=' , 123 , ' vij=' , this % v ( i ) write ( * , * ) 'x(1)=' , x ( 1 ), ' x(n+2)=' , x ( this % n + 2 ) pause stop end if call linf ( x , fj , this % v ( i ), this % f ( i ), klo , khi ) else this % f ( i ) = zero end if end do deallocate ( fj ) !if (present(dfj0)) then ! call burying_procedure(vj, fj0, dfj0) !else !  call burying_procedure(vj, fj0) !end if end subroutine FokkerPlanck1D_solve_time_step end module FokkerPlanck1D_mod","tags":"","loc":"sourcefile\\a_fp1d_mod.f90.html"},{"title":"debug.f – My Fortran project","text":"Contents Subroutines debug Source Code debug.f Source Code subroutine debug implicit none double precision LINEAV double precision CHORDN integer NTRUN include 'for/parameter.inc' include 'for/const.inc' include 'for/status.inc' include 'for/outcmn.inc' include 'for/timeoutput.inc' !print *, \"time=\", time CHORDN = LINEAV ( 1 ) NTRUN = NTIMES call TYPDSP_EXT ( 0 , CHORDN , NTRUN , TTOUT , TOUT ) end subroutine","tags":"","loc":"sourcefile\\debug.f.html"},{"title":"drivencurrent95.f90 – My Fortran project","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Contents Functions currlhcd d Subroutines drivencurrent95 lhcurrent currlhcd_old ddc qromb polint trapzd Source Code drivencurrent95.f90 Source Code subroutine drivencurrent95 ( outj , sigmaj , UPL , NRD , NA1 , TIME , TAU , ROC , RTOR , GP2 ) !! ****************************************************************** !!   outj(i)  = LH driven current density, MA/m&#94;2 !!   dndt(i)  = d&#94;2Jr1/dt&#94;2/E, MA/m&#94;2/sec&#94;2/(V/m), ~runaway d(el.density)/dt/E !!   djdt(i)  = dJr2/dt, time drivative of runaway current Jr2, MA/m&#94;2/sec !!   outjrun(i)  = LH driven runaway current density, MA/m&#94;2 !!   outnerun(i) = runaway electron density/10&#94;19 m&#94;-3 !! ****************************************************************** implicit none ! variables imported from ASTRA integer NRD ! NRD     501 - Maximum size of the radial grid integer NA1 ! NA1     Edge grid point number: ROC=RHO(NA1) double precision TIME , TAU , RTOR , ROC , GP2 double precision UPL ( NRD ) ! real * 8 outj ( NRD ), sigmaj ( NRD ), afld ( NRD ), dtau integer i , inpt , ispectr real * 8 , dimension (:), allocatable :: outjp , outjm , ohjp , ohjm real * 8 dt , cup , cup0 , cum , cum0 , cp , cm , cp0 , cm0 , aiint real * 8 , parameter :: zero = 0.d0 , eps = 1.d-2 ! inpt = NA1 allocate ( outjp ( inpt ), outjm ( inpt ), ohjp ( inpt ), ohjm ( inpt )) do i = 1 , inpt afld ( i ) = UPL ( i ) / RTOR / GP2 !!variant end do ! !!!!!!!!!!!!! starting LH current calculation !!!!!!!!!!!!!!!!! outj = zero outjp = zero outjm = zero ohjp = zero ohjm = zero cup = zero cum = zero cp = zero cm = zero cup0 = zero cum0 = zero cp0 = zero cm0 = zero ! !!positive spectrum: ispectr = 1 call lhcurrent ( outjp , ohjp , cup , cup0 , inpt , ispectr ) if ( cup0 . ne . zero ) then cp0 = aiint ( ohjp , roc ) if ( cp0 . ne . zero ) then do i = 1 , inpt ohjp ( i ) = cup0 * ohjp ( i ) / cp0 end do end if end if if ( cup . ne . zero ) then cp = aiint ( outjp , roc ) if ( cp . ne . zero ) then do i = 1 , inpt outjp ( i ) = cup * outjp ( i ) / cp end do end if end if !!negative spectrum: ispectr =- 1 call lhcurrent ( outjm , ohjm , cum , cum0 , inpt , ispectr ) if ( cum0 . ne . zero ) then cm0 = aiint ( ohjm , roc ) if ( cm0 . ne . zero ) then do i = 1 , inpt ohjm ( i ) = cum0 * ohjm ( i ) / cm0 end do end if end if if ( cum . ne . zero ) then cm = aiint ( outjm , roc ) if ( cm . ne . zero ) then do i = 1 , inpt outjm ( i ) = cum * outjm ( i ) / cm end do end if end if do i = 1 , inpt outj ( i ) = outjp ( i ) + outjm ( i ) sigmaj ( i ) = zero if ( dabs ( afld ( i )). gt . eps ) then sigmaj ( i ) = ( ohjp ( i ) + ohjm ( i )) / afld ( i ) end if !!!!       write(*,*) i,outj(i) end do ! write ( * , * ) 'time=' , time write ( * , * ) 'cup=' , cup , ' cp=' , cp write ( * , * ) 'cum=' , cum , ' cm=' , cm write ( * , * ) 'cup0=' , cup0 , ' cp0=' , cp0 write ( * , * ) 'cum0=' , cum0 , ' cm0=' , cm0 write ( * , * ) 'sigma driven current, MA=' , cp0 + cm0 write ( * , * ) 'driven current, MA=' , cup + cum write ( * , * ) ! call fokkerplanck_new ( time , TAU ) ! deallocate ( outjp , outjm , ohjp , ohjm ) ! end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine lhcurrent ( outj , ohj , cuj , cujoh , inpt , ispectr ) !!      implicit real*8 (a-h,o-z) use plasma , only : rh , rh1 , fvt , sk use maxwell use rt_parameters , only : nr implicit none real * 8 outj ( * ), ohj ( * ), cuj , cujoh , curs , curs0 , curdir real * 8 currn , pqe , vt0 , ccur , cfull , cfull0 real * 8 r , pn , fn1 , fn2 , fnr , fnrr , vt , vto !,rh1 integer klo , khi , ierr , nrr , i , j , inpt , ispectr , ismthout !common /a0ab/ nr !real*8 y2dn,y2tm,y2tmi !common /a0l3/ y2dn(501),y2tm(501),y2tmi(501) integer inew common / cnew / inew !est !sav2008 real * 8 zv1 , zv2 , fout common / plosh / zv1 ( 100 , 2 ), zv2 ( 100 , 2 ) !,sk(100) integer k !parameter(i0=1002) !real*8 vij,fij0,fij,dfij,dij,enorm,fst !common/lh/ vij(i0,100), fij0(i0,100,2), fij(i0,100,2), dfij(i0,100,2), dij(i0,100,2), enorm(100), fst(100) real * 8 , dimension (:), allocatable :: vj , fj , fj0 , cur , cur0 , currnt , rxx , wrk parameter ( ismthout = 1 ) interface function currlhcd ( v , f ) result ( curs ) implicit none real * 8 v (:), f (:) real * 8 curs end function end interface allocate ( vj ( i0 ), fj ( i0 ), fj0 ( i0 ), cur ( nr ), cur0 ( nr ), currnt ( nr + 2 ), rxx ( nr + 2 ), wrk ( nr + 2 )) !--------------------------------------------------- ! initial constants !--------------------------------------------------- pqe = 4.803e-10 vt0 = fvt ( zero ) ccur = pqe * vt0 * 0.333d-9 curdir =- dble ( ispectr ) ! cfull = zero cfull0 = zero k = ( 3 - ispectr ) / 2 do j = 1 , nr do i = 1 , i0 vj ( i ) = vij ( i , j ) !Vpar/Vt fj0 ( i ) = fij0 ( i , j , k ) fj ( i ) = fij ( i , j , k ) - fij0 ( i , j , k ) end do r = dble ( j ) / dble ( nr + 1 ) if ( inew . eq . 0 ) then !vardens pn = fn1 ( r , fnr ) else pn = fn2 ( r , fnr , fnrr ) end if vt = fvt ( r ) vto = vt / vt0 curs = currlhcd ( vj , fj ) cur ( j ) = curs * pn * ccur * curdir * vto !Ampere/cm2 cfull = cfull + cur ( j ) * sk ( j ) curs0 = currlhcd ( vj , fj0 ) cur0 ( j ) = curs0 * pn * ccur * curdir * vto !Ampere/cm2 cfull0 = cfull0 + cur0 ( j ) * sk ( j ) end do cuj = cfull * 1 d - 6 !driven current, MA cujoh = cfull0 * 1 d - 6 !driven current, MA !!      write(*,*) !!      write(*,*)'ccur',ccur,' curdir=',curdir,' nr=',nr !!      write(*,*)'cu_out, MA=',cu_out,' cfull, A=',cfull !!           close(111) !      pause !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! currn = cur ( 1 ) ! Jstoped, A/cm&#94;2 currnt ( 1 ) = currn * 1.d-2 ! Jstoped, MA/m&#94;2 rxx ( 1 ) = zero do j = 1 , nr rxx ( j + 1 ) = dble ( j ) / dble ( nr + 1 ) currn = cur ( j ) ! Jstopped, A/cm&#94;2 currnt ( j + 1 ) = currn * 1.d-2 ! Jstoped, MA/m&#94;2 end do nrr = nr + 2 rxx ( nrr ) = 1.d0 currnt ( nr + 2 ) = zero ! if ( ismthout . ne . 0 ) then do i = 1 , nrr wrk ( i ) = currnt ( i ) end do call fsmoth4 ( rxx , wrk , nrr , currnt ) end if ! rh ( 1 ) = rh1 if ( rh ( inpt ). gt . 1 d0 ) rh ( inpt ) = 1.d0 do j = 1 , inpt call lock2 ( rxx , nrr , rh ( j ), klo , khi , ierr ) if ( ierr . ne . 0 ) then write ( * , * ) 'lock2 error in current profile for ASTRA' write ( * , * ) 'ierr=' , ierr , ' j=' , j , ' rh(j)=' , rh ( j ) write ( * , * ) 'rxx(1)=' , rxx ( 1 ), ' rxx(nrr)=' , rxx ( nrr ) pause end if call linf ( rxx , currnt , rh ( j ), fout , klo , khi ) outj ( j ) = fout end do rh ( 1 ) = zero !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! currn = cur0 ( 1 ) ! Jstoped, A/cm&#94;2 currnt ( 1 ) = currn * 1.d-2 ! Jstoped, MA/m&#94;2 rxx ( 1 ) = zero do j = 1 , nr rxx ( j + 1 ) = dble ( j ) / dble ( nr + 1 ) currn = cur0 ( j ) ! Jstopped, A/cm&#94;2 currnt ( j + 1 ) = currn * 1.d-2 ! Jstoped, MA/m&#94;2 end do nrr = nr + 2 rxx ( nrr ) = 1.d0 currnt ( nr + 2 ) = zero ! if ( ismthout . ne . 0 ) then do i = 1 , nrr wrk ( i ) = currnt ( i ) end do call fsmoth4 ( rxx , wrk , nrr , currnt ) end if ! rh ( 1 ) = rh1 if ( rh ( inpt ). gt . 1 d0 ) rh ( inpt ) = 1.d0 do j = 1 , inpt call lock2 ( rxx , nrr , rh ( j ), klo , khi , ierr ) if ( ierr . ne . 0 ) then write ( * , * ) '#2 lock2 error in current profile for ASTRA' write ( * , * ) 'ierr=' , ierr , ' j=' , j , ' rh(j)=' , rh ( j ) write ( * , * ) 'rxx(1)=' , rxx ( 1 ), ' rxx(nrr)=' , rxx ( nrr ) pause end if call linf ( rxx , currnt , rh ( j ), fout , klo , khi ) ohj ( j ) = fout end do rh ( 1 ) = zero !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! deallocate ( vj , fj , fj0 , cur , cur0 , currnt , rxx , wrk ) end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! function currlhcd ( v , f ) result ( curs ) implicit none real * 8 v (:), f (:) real * 8 curs integer i0 , k real * 8 vl , vr , fl , fr curs = 0.d0 i0 = size ( v ) do k = 1 , i0 - 1 vl = v ( k ) vr = v ( k + 1 ) fl = f ( k ) fr = f ( k + 1 ) curs = curs + ( fl * vl + fr * vr ) / 2 d0 * ( vr - vl ) end do end subroutine currlhcd_old ( i0 , v , f , f0 , curs , curs0 ) implicit none integer i0 , k real * 8 v ( * ), f ( * ), f0 ( * ), curs , curs0 real * 8 vl , vr , fl , fr , zero parameter ( zero = 0.d0 ) curs = zero curs0 = zero do k = 1 , i0 - 1 vl = v ( k ) vr = v ( k + 1 ) fl = f ( k ) fr = f ( k + 1 ) curs = curs + ( fl * vl + fr * vr ) / 2 d0 * ( vr - vl ) fl = f0 ( k ) fr = f0 ( k + 1 ) curs0 = curs0 + ( fl * vl + fr * vr ) / 2 d0 * ( vr - vl ) end do end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine ddc ( diffusion ) use maxwell implicit none common / testf / tcur integer ntau , tc , koltoch , i , j , k , klo real * 8 curtime , tcur real * 16 tau0 , spacing , curtime0 parameter ( tau0 = 3.000990745207882E-002 ) !common/lh/dij(1002,100,2) real * 8 b , b1 , b2 , d , diffusion !      real*8,dimension(:),allocatable:: diffusion integer i1 , iunit6 b1 = 0 b2 = 60 j = 10 k = 1 !      allocate (diffusion(500)) ! write(*,*)'time=',tcur ! do tc=1,koltoch !       spacing=0.008/koltoch !       curtime=tau0+spacing*tc!-0.0002 !      curtime0=curtime+0.000000001 !      if((tcur-curtime)*(tcur-curtime0).lt.zero) then !       if((tcur-0.0301)*(tcur-0.0302).lt.zero) then !       open(iunit6,file='lhcd/distribution/ddc.dat',position=\"append\") !      do i1=1,500 !      b=b1+(b2/500)*(i1-1) !      diffusion(i1)=d(b) !       do i=1,1001 !        write(iunit6,*) i, diffusion !       end do !      write(iunit6,*) !       close(iunit6) !       end if ! end do ! !     deallocate(diffusion) end real * 8 function d ( x ) use maxwell implicit none !integer i0 !parameter(i0=1002) !real*8 vij,fij0,fij,dfij,dij,enorm,fst !common/lh/vij(i0,100),fij0(i0,100,2),fij(i0,100,2),dfij(i0,100,2),dij(i0,100,2),enorm(100),fst(100) real * 8 , dimension (:), allocatable :: vvj , ddj integer klo , khi , ierr real * 8 d0 , x integer jindex , kindex , k , j , i common / dddql / d0 , jindex , kindex d = zero if ( d0 . eq . zero ) return j = jindex if ( x . ge . vij ( i0 , j )) return k = kindex allocate ( vvj ( i0 ), ddj ( i0 )) !      write(*,*)'function d(x): k=',k,' j=',j do i = 1 , i0 vvj ( i ) = vij ( i , j ) ddj ( i ) = dij ( i , j , k ) end do call lock ( vvj , i0 , x , klo , khi , ierr ) if ( ierr . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , j , ' v=' , x write ( * , * ) 'vj(1)=' , vvj ( 1 ), ' vj(i0)=' , vvj ( i0 ) pause stop end if d = ddj ( klo ) !!\tcall ddc(d) !!!      call linf(vvj,ddj,x,d,klo,khi) ! !      write(*,*)'klo=',klo,' khi=',khi !      write(*,*)'vj(klo)=',vvj(klo),' vj(khi)=',vvj(khi) !      write(*,*)'x=',x,' d=',d ! deallocate ( vvj , ddj ) end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine qromb ( func , a , b , ss ) implicit none integer jmax , jmaxp , k , km double precision a , b , func , ss , eps external func parameter ( eps = 1.d-6 , jmax = 200 , jmaxp = jmax + 1 , k = 5 , km = k - 1 ) !u    uses polint,trapzd integer j double precision dss , h ( jmaxp ), s ( jmaxp ) h ( 1 ) = 1.d0 do 11 j = 1 , jmax call trapzd ( func , a , b , s ( j ), j ) if ( j . ge . k ) then call polint ( h ( j - km ), s ( j - km ), k , 0.d0 , ss , dss ) if ( abs ( dss ). le . eps * abs ( ss )) return endif s ( j + 1 ) = s ( j ) h ( j + 1 ) = 0.25d0 * h ( j ) 11 continue pause 'too many steps in qromb' end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine polint ( xa , ya , n , x , y , dy ) implicit none integer n , nmax double precision dy , x , y , xa ( n ), ya ( n ) parameter ( nmax = 10 ) integer i , m , ns double precision den , dif , dift , ho , hp , w , c ( nmax ), d ( nmax ) ns = 1 dif = abs ( x - xa ( 1 )) do 11 i = 1 , n dift = abs ( x - xa ( i )) if ( dift . lt . dif ) then ns = i dif = dift endif c ( i ) = ya ( i ) d ( i ) = ya ( i ) 11 continue y = ya ( ns ) ns = ns - 1 do 13 m = 1 , n - 1 do 12 i = 1 , n - m ho = xa ( i ) - x hp = xa ( i + m ) - x w = c ( i + 1 ) - d ( i ) den = ho - hp if ( den . eq . 0.d0 ) pause 'failure in polint' den = w / den d ( i ) = hp * den c ( i ) = ho * den 12 continue if ( 2 * ns . lt . n - m ) then dy = c ( ns + 1 ) else dy = d ( ns ) ns = ns - 1 endif y = y + dy 13 continue return end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine trapzd ( func , a , b , s , n ) implicit none integer n double precision a , b , s , func external func integer it , j double precision del , sum , tnm , x if ( n . eq . 1 ) then s = 0.5d0 * ( b - a ) * ( func ( a ) + func ( b )) else it = 2 ** ( n - 2 ) tnm = it del = ( b - a ) / tnm x = a + 0.5d0 * del sum = 0.d0 do 11 j = 1 , it sum = sum + func ( x ) x = x + del 11 continue s = 0.5d0 * ( s + ( b - a ) * sum / tnm ) endif return end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!","tags":"","loc":"sourcefile\\drivencurrent95.f90.html"},{"title":"fokkerplanck_new.f90 – My Fortran project","text":"calculation of distribution functions at time t1=t+dtau !! Contents Subroutines fokkerplanck_new init_diffusion Source Code fokkerplanck_new.f90 Source Code !! calculation of distribution functions at time t1=t+dtau !! subroutine fokkerplanck_new ( time , TAU ) use FokkerPlanck1D_mod use Utils use rt_parameters use maxwell use plasma , only : fvt implicit none type ( FokkerPlanck1D ) fp_test real * 8 , intent ( in ) :: time , TAU real * 8 t , dtstep , dtau !integer nr !common /a0ab/ nr integer , parameter :: ntau = 10 !integer i0 !parameter(i0=1002) !real*8 vij,fij0,fij,dfij,dij,enorm,fst !common/lh/vij(i0,100),fij0(i0,100,2),fij(i0,100,2),dfij(i0,100,2), dij(i0,100,2),enorm(100),fst(100) integer n , i , j , it , nt , k real * 8 xend , h , dt real * 8 znak , alfa2 , dt0 , h0 , r !common/ef/ alfa2 real * 8 d0 integer jindex , kindex common / dddql / d0 , jindex , kindex parameter ( dt0 = 0.1d0 , h0 = 0.1d0 ) real time1 , time2 interface subroutine write_distribution ( arr , N , time ) implicit none real * 8 , intent ( in ) :: arr ( * ) integer , intent ( in ) :: N real * 8 , intent ( in ) :: time end subroutine write_distribution subroutine write_matrix ( arr , time , array_name ) implicit none real * 8 , intent ( in ) :: arr (:,:) real * 8 , intent ( in ) :: time character ( len =* ), intent ( in ) :: array_name end subroutine write_matrix subroutine write_v_array ( v , a , time , array_name ) implicit none real * 8 , intent ( in ) :: v (:,:) real * 8 , intent ( in ) :: a (:,:,:) real * 8 , intent ( in ) :: time character ( len =* ), intent ( in ) :: array_name end subroutine end interface dtstep = TAU / dble ( ntau ) !seconds print * , 'fokkerplanck_new' write ( * , * ) 'time=' , time , ' dt=' , dtstep time1 = sys_time () do j = 1 , nr jindex = j ! common/dddql/ dtau = dtstep * fst ( j ) nt = 1 if ( dtau . gt . dt0 ) then nt = 1 + dtau / dt0 end if dt = dtau / nt r = dble ( j ) / dble ( nr + 1 ) xend = 3.d10 / fvt ( r ) do k = 1 , 2 znak = 2.d0 * dble ( k ) - 3.d0 fp_test = FokkerPlanck1D ( znak * enorm ( j ), xend , vij (:, j ), fij0 (:, j , k )) call fp_test % init_zero_diffusion do i = 1 , ntau call fp_test % solve_time_step ( dt , nt ) !call fokkerplanck1D_iter(alfa2, h, n, dt, nt, xend, d1, d2, d3, vij(:,j), fij0(:,j,k), out_fj) end do fij0 (:, j , k ) = fp_test % f fp_test = FokkerPlanck1D ( znak * enorm ( j ), xend , vij (:, j ), fij (:, j , k )) call fp_test % init_diffusion ( dij (:, j , k )) do i = 1 , ntau call fp_test % solve_time_step ( dt , nt ) !call fokkerplanck1D_iter(alfa2, h, n, dt, nt, xend, d1, d2, d3, vij(:,j), fij(:,j,k),out_fj, dfij(:,j,k)) end do fij (:, j , k ) = fp_test % f end do call write_distribution ( fij0 (:, j , 2 ), i0 , time ) !call write_distribution(out_fj, n, time) end do write ( * , * ) 'fokkerplanck nr= ' , nr , ' ntau =' , ntau , 'nt =' , nt call write_v_array ( vij , fij0 (:, 1 : nr ,:), time , 'maxwell' ) call write_v_array ( vij , dij (:, 1 : nr ,:), time , 'diffusion' ) !call write_matrix(dij(1:i0,1:nr,1), time, 'diffusion') time2 = sys_time () - time1 print * , 'fokkerplanck_new eval time: ' , time2 end subroutine init_diffusion ( h , n , vj , dj , d1 , d2 , d3 ) ! инициализация диффузии для схемы савельева implicit none integer , intent ( in ) :: n real * 8 , intent ( in ) :: h real * 8 , dimension (:), intent ( in ) :: vj , dj real * 8 , dimension (:), intent ( out ) :: d1 , d2 , d3 real * 8 , dimension (:), allocatable :: xx integer :: i0 integer i , klo , khi , ierr , klo1 , khi1 integer klo2 , klo3 , khi2 , khi3 , ierr1 , ierr2 , ierr3 i0 = size ( vj ) allocate ( xx ( n + 1 )) do i = 1 , n + 1 xx ( i ) = h / 2.d0 + h * dble ( i - 1 ) !+shift end do do i = 1 , n + 1 call lock ( vj , i0 , xx ( i ), klo1 , khi1 , ierr1 ) call lock ( vj , i0 , xx ( i ) - h / 2 d0 , klo2 , khi2 , ierr2 ) call lock ( vj , i0 , xx ( i ) + h / 2 d0 , klo3 , khi3 , ierr3 ) if ( ierr1 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo1=' , klo1 , 'khi1=' , khi1 , 'i=' , i write ( * , * ) 'vj(1)=' , vj ( 1 ), ' vj(i0)=' , vj ( i0 ) pause stop end if if ( ierr2 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo2=' , klo2 , 'khi2=' , khi2 , 'i=' , i write ( * , * ) 'vj(1)=' , vj ( 1 ), ' vj(i0)=' , vj ( i0 ) pause stop end if if ( ierr3 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo3=' , klo3 , 'khi3=' , khi3 , 'i=' , i write ( * , * ) 'vj(1)=' , vj ( 1 ), ' vj(i0)=' , vj ( i0 ) pause stop end if d1 ( i ) = dj ( klo1 ) d2 ( i ) = dj ( klo2 ) d3 ( i ) = dj ( klo3 ) end do end subroutine","tags":"","loc":"sourcefile\\fokkerplanck_new.f90.html"},{"title":"fokkerplanck_time_step.f90 – My Fortran project","text":"calculation of distribution functions at time t1 = t + TAU !! Contents Subroutines fokkerplanck_time_step prepare_diffusion init_diffusion Source Code fokkerplanck_time_step.f90 Source Code !! calculation of distribution functions at time t1 = t + TAU !! subroutine fokkerplanck_time_step ( time , TAU ) use rt_parameters use maxwell implicit none real * 8 , intent ( in ) :: time , TAU real * 8 t , dtstep , dtau !integer nr !common /a0ab/ nr integer , parameter :: ntau = 10 !integer i0 !parameter(i0=1002) !real*8 vij,fij0,fij,dfij,dij,enorm,fst !common/lh/vij(i0,100),fij0(i0,100,2),fij(i0,100,2),dfij(i0,100,2), dij(i0,100,2),enorm(100),fst(100) integer n , i , j , it , nt , k real * 8 xend , h , dt real * 8 , allocatable :: d1 (:), d2 (:), d3 (:) real * 8 , allocatable :: out_fj (:) real * 8 znak , alfa2 , dt0 , h0 , r , fvt !common/ef/ alfa2 real * 8 d0 integer jindex , kindex common / dddql / d0 , jindex , kindex parameter ( dt0 = 0.1d0 , h0 = 0.1d0 ) integer iptnew real * 8 dijk , vrjnew common / t01 / dijk ( 101 , 100 , 2 ), vrjnew ( 101 , 100 , 2 ), iptnew interface subroutine fokkerplanck1D_iter ( alfa2 , h , n , dt , nt , xend , d1 , d2 , d3 , vj , fj0 , out_fj , dfj0 ) implicit none real * 8 , intent ( in ) :: alfa2 integer , intent ( in ) :: n , nt real * 8 , intent ( in ) :: h , dt , xend real * 8 , intent ( in ) :: d1 (:), d2 (:), d3 (:), vj (:) real * 8 , intent ( inout ) :: fj0 (:) real * 8 , intent ( inout ) :: out_fj (:) real * 8 , intent ( inout ), optional :: dfj0 (:) end subroutine fokkerplanck1D_iter subroutine init_diffusion ( h , n , vj , dj , d1 , d2 , d3 ) implicit none integer , intent ( in ) :: n real * 8 , intent ( in ) :: h real * 8 , dimension (:), intent ( in ) :: vj , dj real * 8 , dimension (:), intent ( out ) :: d1 , d2 , d3 end subroutine init_diffusion subroutine prepare_diffusion ( h , n , iptnew , vrjnew , dijk , d1 , d2 ) ! для версии чанга купера implicit none integer , intent ( in ) :: n real * 8 , intent ( in ) :: h integer , intent ( in ) :: iptnew real * 8 , dimension (:), intent ( in ) :: vrjnew , dijk real * 8 , dimension (:), intent ( out ) :: d1 , d2 end subroutine subroutine write_distribution ( arr , N , time ) implicit none real * 8 , intent ( in ) :: arr ( * ) integer , intent ( in ) :: N real * 8 , intent ( in ) :: time end subroutine write_distribution subroutine write_matrix ( arr , time , array_name ) implicit none real * 8 , intent ( in ) :: arr (:,:) real * 8 , intent ( in ) :: time character ( len =* ), intent ( in ) :: array_name end subroutine write_matrix subroutine write_v_array ( v , a , time , array_name ) implicit none real * 8 , intent ( in ) :: v (:,:) real * 8 , intent ( in ) :: a (:,:,:) real * 8 , intent ( in ) :: time character ( len =* ), intent ( in ) :: array_name end subroutine end interface dtstep = TAU / dble ( ntau ) !seconds print * , 'fokkerplanck_new' write ( * , * ) 'time=' , time , ' dt=' , dtstep ! do i = 1 , ntau write ( * , * ) 'fokkerplanck N' , i , 'of' , ntau do k = 1 , 2 kindex = k ! common/dddql/ znak = 2.d0 * dble ( k ) - 3.d0 do j = 1 , nr jindex = j ! common/dddql/ dtau = dtstep * fst ( j ) nt = 1 if ( dtau . gt . dt0 ) then nt = 1 + dtau / dt0 end if dt = dtau / nt r = dble ( j ) / dble ( nr + 1 ) xend = 3.d10 / fvt ( r ) !!        xend=vij(i0,j) n = xend / h0 - 1 h = xend / dble ( n + 1 ) if ( h . gt . h0 ) then n = n + 1 h = xend / dble ( n + 1 ) end if !print *, k, j, n, h allocate ( out_fj ( n + 2 )) allocate ( d1 ( n + 1 ), d2 ( n + 1 ), d3 ( n + 1 )) d1 (:) = 0 d0 d2 (:) = 0 d0 d3 (:) = 0 d0 !d0=zero             ! common/dddql/ alfa2 = znak * enorm ( j ) ! common/ef/ call fokkerplanck1D_iter ( alfa2 , h , n , dt , nt , xend , d1 , d2 , d3 , vij (:, j ), fij0 (:, j , k ), out_fj ) !d0=1.d0             ! common/dddql/ alfa2 = znak * enorm ( j ) ! common/ef/ !call init_diffusion(h, n, vij(:,j), dij(:,j,k), d1, d2, d3) call prepare_diffusion ( h , n , iptnew , vrjnew (:, j , k ), dijk (:, j , k ), d1 , d2 ) call fokkerplanck1D_iter ( alfa2 , h , n , dt , nt , xend , d1 , d2 , d3 , vij (:, j ), fij (:, j , k ), out_fj , dfij (:, j , k )) deallocate ( d1 , d2 , d3 ) if ( i > 9 . and . k == 2 ) then call write_distribution ( fij0 (:, j , k ), i0 , time ) !call write_distribution(out_fj, n, time) end if deallocate ( out_fj ) end do !stop end do end do call write_v_array ( vij , fij0 (:, 1 : nr ,:), time , 'maxwell' ) call write_v_array ( vij , dij (:, 1 : nr ,:), time , 'diffusion' ) !call write_matrix(dij(1:i0,1:nr,1), time, 'diffusion') end subroutine prepare_diffusion ( h , n , iptnew , vrjnew , dijk , d1 , d2 ) ! для версии чанга купера implicit none integer , intent ( in ) :: n real * 8 , intent ( in ) :: h integer , intent ( in ) :: iptnew real * 8 , dimension (:), intent ( in ) :: vrjnew , dijk real * 8 , dimension (:), intent ( out ) :: d1 , d2 real * 8 , dimension (:), allocatable :: xx integer i , klo , khi , ierr , klo1 , khi1 allocate ( xx ( n + 1 )) do i = 1 , n + 1 xx ( i ) = h / 2.d0 + h * dble ( i - 1 ) !+shift end do D2 = dijk (:) do i = 1 , n + 1 if ( xx ( i ). gt . vrjnew ( iptnew )) then D1 ( i ) = 0 d0 else call lock ( vrjnew (:), iptnew , xx ( i ), klo , khi , ierr ) if ( ierr . eq . 1 ) then write ( * , * ) 'lock error in finction d(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'vj(1)=' , vrjnew ( 1 ), ' vj(i0)=' , vrjnew ( iptnew ) pause stop end if call polint ( vrjnew ( klo ), dijk ( klo ), 2 , xx ( i ), D1 ( i ), ierr ) !           D1(i)=dij(klo,j,k) if ( D1 ( i ). lt . 0 d0 ) then write ( * , * ) 'diff is  negative; check drivencurrent 558' write ( * , * ) 'xx(i)=' , xx ( i ), 'D1(i)=' , D1 ( i ) pause stop endif endif enddo end subroutine subroutine init_diffusion ( h , n , vj , dj , d1 , d2 , d3 ) implicit none integer , intent ( in ) :: n real * 8 , intent ( in ) :: h real * 8 , dimension (:), intent ( in ) :: vj , dj real * 8 , dimension (:), intent ( out ) :: d1 , d2 , d3 real * 8 , dimension (:), allocatable :: xx integer :: i0 integer i , klo , khi , ierr , klo1 , khi1 integer klo2 , klo3 , khi2 , khi3 , ierr1 , ierr2 , ierr3 i0 = size ( vj ) allocate ( xx ( n + 1 )) do i = 1 , n + 1 xx ( i ) = h / 2.d0 + h * dble ( i - 1 ) !+shift end do do i = 1 , n + 1 call lock ( vj , i0 , xx ( i ), klo1 , khi1 , ierr1 ) call lock ( vj , i0 , xx ( i ) - h / 2 d0 , klo2 , khi2 , ierr2 ) call lock ( vj , i0 , xx ( i ) + h / 2 d0 , klo3 , khi3 , ierr3 ) if ( ierr1 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo1=' , klo1 , 'khi1=' , khi1 , 'i=' , i write ( * , * ) 'vj(1)=' , vj ( 1 ), ' vj(i0)=' , vj ( i0 ) pause stop end if if ( ierr2 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo2=' , klo2 , 'khi2=' , khi2 , 'i=' , i write ( * , * ) 'vj(1)=' , vj ( 1 ), ' vj(i0)=' , vj ( i0 ) pause stop end if if ( ierr3 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo3=' , klo3 , 'khi3=' , khi3 , 'i=' , i write ( * , * ) 'vj(1)=' , vj ( 1 ), ' vj(i0)=' , vj ( i0 ) pause stop end if d1 ( i ) = dj ( klo1 ) d2 ( i ) = dj ( klo2 ) d3 ( i ) = dj ( klo3 ) end do end subroutine","tags":"","loc":"sourcefile\\fokkerplanck_time_step.f90.html"},{"title":"fokkerplank1D.f90 – My Fortran project","text":"Contents Subroutines fokkerplanck1D_iter burying_procedure Source Code fokkerplank1D.f90 Source Code subroutine fokkerplanck1D_iter ( alfa2 , h , n , dt , nt , xend , d1 , d2 , d3 , vj , fj0 , out_fj , dfj0 ) implicit none real * 8 , intent ( in ) :: alfa2 integer , intent ( in ) :: n , nt real * 8 , intent ( in ) :: h , dt , xend real * 8 , intent ( in ) :: d1 (:), d2 (:), d3 (:), vj (:) real * 8 , intent ( inout ) :: fj0 (:) real * 8 , intent ( inout ) :: out_fj (:) real * 8 , intent ( inout ), optional :: dfj0 (:) integer :: i0 real * 8 , parameter :: zero = 0.d0 real * 8 y ( n + 2 ), x ( n + 2 ) real * 8 , dimension (:), allocatable :: fj , dfj , givi integer i , ii , it , ibeg , klo , khi , ierr , klo1 , khi1 real * 8 shift , ybeg , yend , tend , dff interface subroutine savelyev_solver ( alfa2 , nt , h , dt , n , ybeg , yend , d1 , d2 , d3 , y ) implicit none real * 8 , intent ( in ) :: alfa2 integer , intent ( in ) :: nt , n real * 8 , intent ( in ) :: h , dt real * 8 , intent ( in ) :: ybeg , yend real * 8 , intent ( in ) :: d1 ( n + 1 ), d2 ( n + 1 ), d3 ( n + 1 ) real * 8 , intent ( inout ) :: y ( n ) end subroutine subroutine burying_procedure ( v , f0 , df0 ) ! процедура закапывания implicit none real * 8 , intent ( in ) :: v (:) real * 8 , intent ( inout ) :: f0 (:) real * 8 , intent ( inout ), optional :: df0 (:) end subroutine end interface i0 = size ( vj ) !!!!!! grid !!!!!!!!! !!  shift=h*0.1d0 !0.01d0 do i = 1 , n + 2 x ( i ) = h * dble ( i - 1 ) !+shift end do do i = 1 , n + 1 call lock ( vj , i0 , x ( i + 1 ), klo , khi , ierr ) if ( ierr . eq . 1 ) then write ( * , * ) 'lock error #1 in finction fokkerplanck' write ( * , * ) 'j=' , 123 , ' v=' , x ( i + 1 ) write ( * , * ) 'vj(1)=' , vj ( 1 ), ' vj(i0)=' , vj ( i0 ) pause stop end if call linf ( vj , fj0 , x ( i + 1 ), y ( i ), klo , khi ) end do ybeg = fj0 ( 1 ) !boundary conditions yend = fj0 ( i0 ) !zero !print *, ' yend =', yend !!!!!!!!!!!!   solve problem   !!!!!!!!!!!!!!!!!!!!!!!!!! !call savelyev_solver(alfa2, nt, h, dt, n, ybeg, yend, d1,d2,d3, y) call teplova_khavin_solver ( alfa2 , nt , h , dt , n , ybeg , yend , d1 , d2 , d3 , y ) allocate ( fj ( n + 2 )) fj ( 1 ) = ybeg fj ( n + 2 ) = yend do i = 1 , n fj ( i + 1 ) = y ( i ) end do out_fj (:) = fj (:) !call write_distribution(fj, n, 0.1999d0) do i = 2 , i0 - 1 if ( vj ( i ). lt . xend ) then call lock ( x , n + 2 , vj ( i ), klo , khi , ierr ) if ( ierr . eq . 1 ) then write ( * , * ) 'lock error #2 in finction fokkerplanck' write ( * , * ) 'j=' , 123 , ' vij=' , vj ( i ) write ( * , * ) 'x(1)=' , x ( 1 ), ' x(n+2)=' , x ( n + 2 ) pause stop end if call linf ( x , fj , vj ( i ), fj0 ( i ), klo , khi ) else fj0 ( i ) = zero end if end do deallocate ( fj ) if ( present ( dfj0 )) then ! call burying_procedure(vj, fj0, dfj0) else !  call burying_procedure(vj, fj0) end if end subroutine fokkerplanck1D_iter subroutine burying_procedure ( v , f0 , df0 ) ! процедура закапывания implicit none real * 8 , intent ( in ) :: v (:) real * 8 , intent ( inout ) :: f0 (:) real * 8 , intent ( inout ), optional :: df0 (:) integer i , ii , i0 , ibeg real * 8 , allocatable :: f (:), df (:) real * 8 fout1 , fout2 i0 = size ( f0 ) allocate ( f ( i0 ), df ( i0 )) f (:) = f0 (:) df (:) = 0 d0 do i = 2 , i0 - 1 df ( i ) = 0.5d0 * ( f ( i + 1 ) - f ( i - 1 )) / v ( 2 ) end do df ( 1 ) = 0 d0 df ( i0 ) = ( f ( i0 ) - f ( i0 - 1 )) / v ( 2 ) !   сдвиг расределения вправо. зачем-то ??? ii = 0 ibeg = 0 do i = i0 - 1 , 1 , - 1 if ( df ( i ). gt . 0 d0 ) then !          write(*,*) '#1 positive derivs' !          write(*,*) '#1 df>0: i,j,k=',i,j,k !          write(*,*) '#1 dfj(i),i,j,k=',dfj(i),i,j,k !          write(*,*) f0 ( i ) = f0 ( i + 1 ) if ( present ( df0 )) then df0 ( i ) = df0 ( i + 1 ) end if ii = i end if if ( f0 ( i ). lt . f0 ( i + 1 )) then f0 ( i ) = f0 ( i + 1 ) if ( present ( df0 )) then df0 ( i ) = df0 ( i + 1 ) end if ii = i end if end do if ( ibeg . gt . 0 ) then call integral ( ibeg , i0 , v , f , fout1 ) f (:) = f0 (:) if ( present ( df0 )) then df (:) = df0 (:) end if call integral ( ibeg , i0 , v , f , fout2 ) f0 ( ibeg : i0 ) = f ( ibeg : i0 ) * fout1 / fout2 if ( present ( df0 )) then df0 ( ibeg : i0 ) = df ( ibeg : i0 ) * fout1 / fout2 end if !!      write(*,*)'#1 j,k,ibeg=',j,k,ibeg !!      write(*,*)'#1 v(ibeg)=',vj(ibeg),' f1/f2=',fout1/fout2 end if deallocate ( f , df ) ibeg = ii end subroutine","tags":"","loc":"sourcefile\\fokkerplank1d.f90.html"},{"title":"savelyev_solver.f90 – My Fortran project","text":"!!!!! -- fill abc matrix\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Contents Functions rplusk rplusk2 rmink rmink2 rs q qf k k2 kinv kinv2 Subroutines savelyev_solver savelyev_abccoef tridag Source Code savelyev_solver.f90 Source Code subroutine savelyev_solver ( alfa2 , nt , h , dt , n , ybeg , yend , d1 , d2 , d3 , y ) ! разностная схема Савельева для уравнения Фоккера-Планка implicit none real * 8 , intent ( in ) :: alfa2 integer , intent ( in ) :: nt , n real * 8 , intent ( in ) :: h , dt real * 8 , intent ( in ) :: ybeg , yend real * 8 , intent ( in ) :: d1 ( n + 1 ), d2 ( n + 1 ), d3 ( n + 1 ) real * 8 , intent ( inout ) :: y ( n ) integer i , it real * 8 xx ( n + 1 ), a ( n ), b ( n ), c ( n ), f ( n ) do i = 1 , n + 1 xx ( i ) = h / 2.d0 + h * dble ( i - 1 ) !+shift end do do it = 1 , nt call savelyev_abccoef ( alfa2 , a , b , c , f , y , dt , n , ybeg , yend , xx , h , d1 , d2 , d3 ) call tridag ( a , b , c , f , y , n ) end do end subroutine !!!!!!! -- fill abc matrix subroutine savelyev_abccoef ( alfa2 , a , b , c , f , y , dt , n , ybeg , yend , xx , h , d1 , d2 , d3 ) implicit none real * 8 , intent ( in ) :: alfa2 real * 8 , intent ( inout ) :: a ( n ), b ( n ), c ( n ), f ( n ), y ( n ) real * 8 , intent ( in ) :: dt integer , intent ( in ) :: n real * 8 , intent ( in ) :: ybeg , yend , h real * 8 , intent ( in ) :: xx ( n + 1 ) real * 8 , intent ( in ) :: d1 ( n + 1 ), d2 ( n + 1 ), d3 ( n + 1 ) integer i , iunit , iunit2 real * 8 a1 ( n ), b1 ( n ), c1 ( n ), f1 ( n ), a2 ( n ), b2 ( n ), c2 ( n ), f2 ( n ) real * 8 kinv , rs , rmink , rplusk , q , qf , r1 , rmink2 , rplusk2 , kinv2 real * 8 r , kappa , sum , bmin , bplus , sum2 , sum3 , sum4 real * 8 dc , as ( n + 1 ), k , k2 , d external kinv , rs , rmink , rplusk , q , kinv2 , rmink2 , rplusk2 , d sum = ( kinv ( xx ( 1 ) - h / 2 d0 , d2 ( 1 ), alfa2 ) + kinv ( xx ( 1 ) + h / 2 d0 , d3 ( 1 ), alfa2 )) * h / 2 d0 as ( 1 ) = h / sum sum = ( kinv ( xx ( 2 ) - h / 2 d0 , d2 ( 2 ), alfa2 ) + kinv ( xx ( 2 ) + h / 2 d0 , d3 ( 2 ), alfa2 )) * h / 2 d0 as ( 2 ) = h / sum r = h / 2 d0 * dabs ( rs ( xx ( 1 ) + h / 2 d0 , d3 ( 1 ), alfa2 )) / k ( xx ( 1 ) + h / 2 d0 , d3 ( 1 )) kappa = 1 d0 / ( 1 d0 + r ) sum = ( rmink ( xx ( 1 ), d1 ( 1 ), alfa2 ) + rmink ( xx ( 2 ), d1 ( 2 ), alfa2 )) * h / 2 d0 bmin = sum / h sum = ( rplusk ( xx ( 1 ), d1 ( 1 ), alfa2 ) + rplusk ( xx ( 2 ), d1 ( 2 ), alfa2 )) * h / 2 d0 bplus = sum / h sum = qf ( xx ( 2 )) - qf ( xx ( 1 )) dc = sum / h a ( 1 ) = as ( 1 ) * ( kappa / h ** 2 - bmin / h ) c ( 1 ) = as ( 2 ) * ( kappa / h ** 2 + bplus / h ) b ( 1 ) = - ( 1 d0 / dt + a ( 1 ) + c ( 1 ) + dc ) f ( 1 ) = - y ( 1 ) / dt - a ( 1 ) * ybeg do i = 2 , n sum = ( kinv ( xx ( i + 1 ) - h / 2 d0 , d2 ( i + 1 )) + kinv ( xx ( i + 1 ) + h / 2 d0 , d3 ( i + 1 ))) sum = sum * h / 2 d0 as ( i + 1 ) = h / sum r = h / 2 d0 * dabs ( rs ( xx ( i ) + h / 2 d0 , alfa2 )) / k ( xx ( i ) + h / 2 d0 , d3 ( i )) kappa = 1 d0 / ( 1 d0 + r ) sum = ( rmink ( xx ( i ), d1 ( i ), alfa2 ) + rmink ( xx ( i + 1 ), d1 ( i + 1 ), alfa2 )) * h / 2 d0 bmin = sum / h sum = ( rplusk ( xx ( i ), d1 ( i ), alfa2 ) + rplusk ( xx ( i + 1 ), d1 ( i + 1 ), alfa2 )) * h / 2 d0 bplus = sum / h sum = qf ( xx ( i + 1 )) - qf ( xx ( i )) dc = sum / h a ( i ) = as ( i ) * ( kappa / h ** 2 - bmin / h ) c ( i ) = as ( i + 1 ) * ( kappa / h ** 2 + bplus / h ) b ( i ) = - ( 1 d0 / dt + a ( i ) + c ( i ) + dc ) f ( i ) = - y ( i ) / dt end do f ( n ) = f ( n ) - c ( n ) * yend a ( 1 ) = 0 d0 c ( n ) = 0 d0 end real * 8 function rplusk ( x , dif , alfa2 ) implicit none integer iunit real * 8 x , k , rs , dif , d , razn real * 8 alfa2 rplusk = 0.5d0 * ( rs ( x , alfa2 ) + dabs ( rs ( x , alfa2 ))) / k ( x , dif ) end real * 8 function rplusk2 ( x , dif , alfa2 ) implicit none integer iunit real * 8 x , k2 , rs , dif , d , razn real * 8 alfa2 rplusk2 = 0.5d0 * ( rs ( x , alfa2 ) + dabs ( rs ( x , alfa2 ))) / k2 ( x , dif ) end real * 8 function rmink ( x , dif , alfa2 ) implicit none integer iunit real * 8 x , k , rs , dif , d , razn real * 8 alfa2 rmink = 0.5d0 * ( rs ( x , alfa2 ) - dabs ( rs ( x , alfa2 ))) / k ( x , dif ) end real * 8 function rmink2 ( x , dif , alfa2 ) implicit none integer iunit real * 8 x , k2 , rs , dif , d , razn real * 8 alfa2 rmink2 = 0.5d0 * ( rs ( x , alfa2 ) - dabs ( rs ( x , alfa2 ))) / k2 ( x , dif ) end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! real * 8 function rs ( x , alfa2 ) implicit none real * 8 x real * 8 alfa2 !common/ef/ alfa2 rs = 1 d0 / x ** 2 - alfa2 end real * 8 function q ( x ) implicit none real * 8 x q = 2 d0 / x ** 3 end real * 8 function qf ( x ) implicit none real * 8 x qf =- 1 d0 / x ** 2 end real * 8 function k ( x , dif ) implicit none integer iunit real * 8 x , dif , d , razn k = dif + 1 d0 / x ** 3 end real * 8 function k2 ( x , dif ) implicit none integer iunit real * 8 x , dif , d , razn k2 = d ( x ) + 1 d0 / x ** 3 end real * 8 function kinv ( x , dif ) implicit none integer iunit real * 8 x , dif , razn , d kinv = x ** 3 / ( dif * x ** 3 + 1 d0 ) end real * 8 function kinv2 ( x , dif ) implicit none integer iunit real * 8 x , dif , razn , d , kino kinv2 = x ** 3 / ( d ( x ) * x ** 3 + 1 d0 ) end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine tridag ( a , b , c , r , u , n ) implicit none integer , intent ( in ) :: n real * 8 , intent ( in ) :: a ( n ), b ( n ), c ( n ), r ( n ) real * 8 , intent ( inout ) :: u ( n ) integer , parameter :: nmax = 1000000 integer j real * 8 bet , gam ( nmax ) if ( b ( 1 ). eq . 0.d0 ) pause 'tridag: rewrite equations' bet = b ( 1 ) u ( 1 ) = r ( 1 ) / bet do j = 2 , n gam ( j ) = c ( j - 1 ) / bet bet = b ( j ) - a ( j ) * gam ( j ) if ( bet . eq . 0.d0 ) then write ( * , * ) 'b(j)=' , b ( j ), 'a(j)=' , a ( j ), 'gam(j)=' , gam ( j ) pause 'tridag failed' end if u ( j ) = ( r ( j ) - a ( j ) * u ( j - 1 )) / bet end do do j = n - 1 , 1 , - 1 u ( j ) = u ( j ) - gam ( j + 1 ) * u ( j + 1 ) end do end subroutine","tags":"","loc":"sourcefile\\savelyev_solver.f90.html"},{"title":"teplova_khavin_solver.f90 – My Fortran project","text":"Contents Subroutines teplova_khavin_solver TK_abcoef Source Code teplova_khavin_solver.f90 Source Code subroutine teplova_khavin_solver ( alfa2 , nt , h , dt , n , ybeg , yend , d1 , d2 , d3 , y ) ! схема Ченга-Купера для уравнения Фоккера-Планка implicit none real * 8 , intent ( in ) :: alfa2 integer , intent ( in ) :: nt , n real * 8 , intent ( in ) :: h , dt real * 8 , intent ( in ) :: ybeg , yend real * 8 , intent ( in ) :: d1 ( n + 1 ), d2 ( n + 1 ), d3 ( n + 1 ) real * 8 , intent ( inout ) :: y ( n + 2 ) integer i , it , iz real * 8 xx ( n + 1 ), a ( n ), b ( n ), c ( n ), f ( n ) real * 8 y1 ( n ) interface subroutine TK_abcoef ( alfa2 , A , B , C , f , Y , dt , n , ybeg , yend , xx , h , df ) implicit none real * 8 , intent ( in ) :: alfa2 real * 8 , intent ( inout ) :: a ( n ), b ( n ), c ( n ), f ( n ), y ( n + 2 ) integer , intent ( in ) :: n real * 8 , intent ( in ) :: dt , ybeg , yend , h real * 8 , intent ( in ) :: xx ( n + 1 ) real * 8 , intent ( in ) :: df ( n + 1 ) end subroutine subroutine tridag ( a , b , c , r , u , n ) implicit none integer , intent ( in ) :: n real * 8 , intent ( in ) :: a ( n ), b ( n ), c ( n ), r ( n ) real * 8 , intent ( inout ) :: u ( n ) end subroutine end interface !print *, 'TK abc n = ', n do i = 1 , n + 1 xx ( i ) = h / 2.d0 + h * dble ( i - 1 ) !+shift end do do i = 1 , n y1 ( i ) = y ( i + 1 ) end do do it = 1 , nt !call ABCcoef(a,b,c,f,y1,dt,n,ybeg,yend,x,xx,h,D1) call TK_abcoef ( alfa2 , a , b , c , f , y1 , dt , n , ybeg , yend , xx , h , d1 ) call tridag ( a , b , c , f , y1 , n ) !do i=1,n !    if (y1(i).lt.0.d0) then !        if (y1(i) > epsilon(y1(i))) then !            y1(i)=0.d0 !        else !            write(*,*) n, i, 'y(i)=',y1(i),' lt negative epsilon=',epsilon(y1(i)) !            !pause !            !stop !        endif !    endif !enddo iz = n do i = 1 , n if ( y1 ( i ). lt . epsilon ( yend )) then iz = i !print *, epsilon(yend) !print *, iz, n, yend, y1(i) exit endif enddo do i = iz , n y1 ( i ) = yend enddo end do do i = 1 , n y ( i + 1 ) = y1 ( i ) end do end subroutine ! -- subroutine TK_abcoef ( alfa2 , A , B , C , f , Y , dt , n , ybeg , yend , xx , h , df ) implicit none real * 8 , intent ( in ) :: alfa2 real * 8 , intent ( inout ) :: a ( n ), b ( n ), c ( n ), f ( n ), y ( n + 2 ) integer , intent ( in ) :: n real * 8 , intent ( in ) :: dt , ybeg , yend , h real * 8 , intent ( in ) :: xx ( n + 1 ) real * 8 , intent ( in ) :: df ( n + 1 ) integer i real * 8 z , r , tmp1 , tmp2 , tmp3 r = dt / h do i = 1 , n tmp1 = dlt ( xx ( i ), h , df ( i ), alfa2 ) * B1 ( xx ( i ), alfa2 ) A ( i ) =- r * ( C1 ( xx ( i ), df ( i )) / h - tmp1 ) tmp2 = C1 ( xx ( i + 1 ), df ( i + 1 )) / h - dlt ( xx ( i + 1 ), h , df ( i + 1 ), alfa2 ) * B1 ( xx ( i + 1 ), alfa2 ) tmp3 = ( 1.d0 - dlt ( xx ( i ), h , df ( i ), alfa2 )) * B1 ( xx ( i ), alfa2 ) B ( i ) = r * ( tmp2 + tmp3 + C1 ( xx ( i ), df ( i )) / h ) + 1.d0 tmp1 = ( 1.d0 - dlt ( xx ( i + 1 ), h , df ( i + 1 ), alfa2 )) * B1 ( xx ( i + 1 ), alfa2 ) C ( i ) =- r * ( tmp1 + C1 ( xx ( i + 1 ), df ( i + 1 )) / h ) f ( i ) = Y ( i ) enddo f ( 1 ) = f ( 1 ) - A ( 1 ) * ybeg f ( n ) = f ( n ) - C ( n ) * yend !yend in either way=0 all the time contains function B1 ( xx , alfa2 ) result ( res ) implicit none real * 8 xx , alfa2 , beta , res res = - alfa2 + 1.d0 / ( xx * xx ) end function function C1 ( xx , dif ) result ( res ) implicit none real * 8 xx , dif , res res = dif + 1.d0 / ( xx * xx * xx ) end function function dlt ( xx , h , dif , alfa2 ) result ( res ) implicit none real * 8 res real * 8 xx , h , dif , alfa2 real * 8 w w = h * B1 ( xx , alfa2 ) / C1 ( xx , dif ) res = 1.d0 / w - 1.d0 / ( dexp ( w ) - 1.d0 ) end function end !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc","tags":"","loc":"sourcefile\\teplova_khavin_solver.f90.html"},{"title":"write_distribution.f90 – My Fortran project","text":"Contents Subroutines write_v_array write_x_array write_matrix write_array write_distribution Source Code write_distribution.f90 Source Code subroutine write_v_array ( v , a , time , array_name ) implicit none real * 8 , intent ( in ) :: v (:,:) real * 8 , intent ( in ) :: a (:,:,:) real * 8 , intent ( in ) :: time character ( len =* ), intent ( in ) :: array_name real * 8 , allocatable :: gv (:), ga (:) integer i , N , nshape ( 3 ) character ( 120 ) fname integer , parameter :: iu = 21 if ( MOD ( INT ( time * 100000 ), 10 ) /= 0 ) then return end if nshape = shape ( a ) print * , 'write arr:' , array_name , nshape N = nshape ( 2 ) print * , N write ( fname , '(\"lhcd/\", A,\"/\", f9.7,\".dat\")' ) array_name , time print * , fname open ( iu , file = fname , position = \"append\" ) do i = 1 , N gv = glue_v_axis ( v (:, i )) write ( iu , '(2012(ES22.14))' ) gv (:) deallocate ( gv ) ga = glue_arrays ( a (:, i , 1 ), a (:, i , 2 )) write ( iu , '(2012(ES22.14))' ) ga (:) deallocate ( ga ) end do close ( iu ) contains function glue_v_axis ( a ) result ( g ) implicit none real * 8 , intent ( in ) :: a (:) real * 8 , allocatable :: g (:) integer i , N N = size ( a ) allocate ( g ( - N : N )) g ( - N : - 1 ) = - a ( N : 1 : - 1 ) g ( 1 : N ) = a (:) g ( 0 ) = 0 end function function glue_arrays ( a , b ) result ( g ) implicit none real * 8 , intent ( in ) :: a (:), b (:) real * 8 , allocatable :: g (:) integer i , N N = size ( a ) allocate ( g ( - N : N )) g ( - N : - 1 ) = a ( N : 1 : - 1 ) g ( 1 : N ) = b (:) g ( 0 ) = ( a ( 1 ) + b ( 1 )) / 2 d0 end function end subroutine subroutine write_x_array ( x , arr , time , array_name ) implicit none real * 8 , intent ( in ) :: x (:,:) real * 8 , intent ( in ) :: arr (:,:) real * 8 , intent ( in ) :: time character ( len =* ), intent ( in ) :: array_name integer i , N , nshape ( 2 ) character ( 120 ) fname integer , parameter :: iu = 21 nshape = shape ( arr ) print * , 'write arr:' , array_name , nshape N = nshape ( 2 ) print * , N write ( fname , '(\"lhcd/\", A,\"/xar\", f9.7,\".dat\")' ) array_name , time print * , fname open ( iu , file = fname , position = \"append\" ) do i = 1 , N write ( iu , '(2012(ES22.14))' ) x (: , i ) write ( iu , '(2012(ES22.14))' ) arr (:, i ) end do close ( iu ) end subroutine subroutine write_matrix ( arr , time , array_name ) implicit none real * 8 , intent ( in ) :: arr (:,:) real * 8 , intent ( in ) :: time character ( len =* ), intent ( in ) :: array_name integer i , N , nshape ( 2 ) character ( 120 ) fname integer , parameter :: iu = 21 nshape = shape ( arr ) print * , 'write_matrix:' , array_name , nshape N = nshape ( 1 ) print * , N write ( fname , '(\"lhcd/\", A,\"/\", f9.7,\".dat\")' ) array_name , time print * , fname open ( iu , file = fname , position = \"append\" ) do i = 1 , N write ( iu , ' ( I4.4, 100(ES21.14))' ) i , arr ( i , :) end do close ( iu ) end subroutine subroutine write_array ( arr , N , array_name ) implicit none real * 8 , intent ( in ) :: arr ( * ) integer , intent ( in ) :: N character ( len =* ), intent ( in ) :: array_name integer i integer , parameter :: iunit = 21 character ( 80 ) fname print * , 'write_array:' , array_name , N write ( fname , '(\"lhcd/distribution/\", A,\".dat\")' ) array_name print * , fname open ( iunit , file = fname , position = \"append\" ) do i = 1 , n write ( iunit , * ) i , arr ( i ) end do close ( iunit ) end subroutine subroutine write_distribution ( arr , N , time ) implicit none real * 8 , intent ( in ) :: arr ( * ) integer , intent ( in ) :: N real * 8 , intent ( in ) :: time integer i integer itime integer , parameter :: iunit = 20 character ( 120 ) fname itime = INT ( time * 100000 ) !print *, N, time, itime, MOD(itime, 10) if ( MOD ( itime , 10 ) == 0 ) then write ( fname , '(\"lhcd/distribution/\", f9.7,\".dat\")' ) time !print *, fname open ( iunit , file = fname , position = \"append\" ) do i = 1 , N if ( arr ( i ) > 0 ) then write ( iunit , * ) i , arr ( i ) else exit end if end do close ( iunit ) end if end subroutine","tags":"","loc":"sourcefile\\write_distribution.f90.html"},{"title":"_approximation.f90 – My Fortran project","text":"Contents Modules approximation Source Code _approximation.f90 Source Code module approximation !+ polinomial approximation use , intrinsic :: iso_fortran_env , only : sp => real32 , dp => real64 implicit none contains !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! double precision function polin ( k , x ) implicit none integer k real ( dp ) x polin = 1 d0 if ( k . gt . 1 ) polin = x ** ( k - 1 ) return end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! double precision function polin1 ( k , x ) implicit none integer k real ( dp ) x polin1 = x ** k return end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! double precision function polin2 ( k , x ) implicit none integer k real ( dp ) x polin2 = x ** ( k + 1 ) return end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine approx ( x , y , n , f , m , b ) ! !     y(i)=y(x(i))  the data to be approximated !     n             number of points in the input data !     m             number of coefficients of decomposition !                   over base functions \"f(k,x)\" : !                          y(x)=sum_1&#94;m [b(k)*f(k,x)] !     b(i)          found decomposition coefficients ! implicit real * 8 ( a - h , o - z ) integer , parameter :: np = 20 real ( dp ), parameter :: zero = 0.d0 real ( dp ) a ( np , np ), indx ( np ) real ( dp ) y ( n ), x ( n ), b ( * ) integer i , j , k , m , n if ( m . gt . np ) then write ( * , * ) 'index error subroutine \"approx\"' return end if do j = 1 , m do k = 1 , j a ( k , j ) = zero do i = 1 , n a ( k , j ) = a ( k , j ) + f ( j , x ( i )) * f ( k , x ( i )) end do end do end do do k = 2 , m do j = 1 , k - 1 a ( k , j ) = a ( j , k ) end do end do do k = 1 , m b ( k ) = zero do i = 1 , n b ( k ) = b ( k ) + y ( i ) * f ( k , x ( i )) end do end do call ludcmp ( a , m , np , indx , d ) call lubksb ( a , m , np , indx , b ) end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine ludcmp ( a , n , np , indx , d ) implicit real * 8 ( a - h , o - z ) integer , parameter :: nmax = 501 real ( dp ), parameter :: tiny = 1.d-20 , zero = 0.d0 real ( dp ) a ( np , np ), indx ( n ), vv ( nmax ) integer i , j , k , m , n , np , imax d = 1.d0 do i = 1 , n aamax = zero do j = 1 , n if ( dabs ( a ( i , j )). gt . aamax ) aamax = dabs ( a ( i , j )) end do if ( aamax . eq . zero ) pause 'singular matrix.' vv ( i ) = 1.d0 / aamax end do do j = 1 , n if ( j . gt . 1 ) then do i = 1 , j - 1 sum = a ( i , j ) if ( i . gt . 1 ) then do k = 1 , i - 1 sum = sum - a ( i , k ) * a ( k , j ) end do a ( i , j ) = sum endif end do endif aamax = zero do i = j , n sum = a ( i , j ) if ( j . gt . 1 ) then do k = 1 , j - 1 sum = sum - a ( i , k ) * a ( k , j ) end do a ( i , j ) = sum endif dum = vv ( i ) * dabs ( sum ) if ( dum . ge . aamax ) then imax = i aamax = dum endif end do if ( j . ne . imax ) then do k = 1 , n dum = a ( imax , k ) a ( imax , k ) = a ( j , k ) a ( j , k ) = dum end do d =- d vv ( imax ) = vv ( j ) endif indx ( j ) = imax if ( j . ne . n ) then if ( a ( j , j ). eq . zero ) a ( j , j ) = tiny dum = 1.d0 / a ( j , j ) do i = j + 1 , n a ( i , j ) = a ( i , j ) * dum end do endif end do if ( a ( n , n ). eq . zero ) a ( n , n ) = tiny return end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine lubksb ( a , n , np , indx , b ) implicit real * 8 ( a - h , o - z ) real ( dp ), parameter :: zero = 0.d0 real ( dp ) a ( np , np ), indx ( n ), b ( n ) integer i , j , ii , ll , n , np ii = 0 do i = 1 , n ll = indx ( i ) sum = b ( ll ) b ( ll ) = b ( i ) if ( ii . ne . 0 ) then do j = ii , i - 1 sum = sum - a ( i , j ) * b ( j ) end do else if ( sum . ne . zero ) then ii = i endif b ( i ) = sum end do do i = n , 1 , - 1 sum = b ( i ) if ( i . lt . n ) then do j = i + 1 , n sum = sum - a ( i , j ) * b ( j ) end do endif b ( i ) = sum / a ( i , i ) end do return end double precision function fdf ( x , c , n , df ) real ( dp ) x , c ( n ), df integer n , j real ( dp ) p , dp p = c ( n ) dp = 0.d0 do j = n - 1 , 1 , - 1 dp = dp * x + p p = p * x + c ( j ) end do fdf = p df = dp end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! double precision function fdfddf ( x , c , n , df , ddf ) real ( dp ) x , c ( n ), df , ddf integer n , j real ( dp ) p , dp , ddp p = c ( n ) dp = 0 d0 ddp = 0 d0 do j = n - 1 , 1 , - 1 ddp = ddp * x + 2 d0 * dp dp = dp * x + p p = p * x + c ( j ) end do fdfddf = p df = dp ddf = ddp end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! end module approximation","tags":"","loc":"sourcefile\\_approximation.f90.html"},{"title":"_chebyshev.f90 – My Fortran project","text":"Contents Modules chebyshev Source Code _chebyshev.f90 Source Code module chebyshev implicit none contains SUBROUTINE chebft1 ( a , b , c , n , func ) ! Chebyshev fit: Given a function func, lower and upper limits ! of the interval [a,b], and a maximum degree n, this routine ! computes the n coefficients c(k) such that func(x) approximately = ! SUMM_(k=1)&#94;(k=n)[c(k)*T(k-1)(y)]-c(1)/2, where y and x are related by ! (5.8.10). This routine is to be used with moderately large n ! (e.g., 30 or 50), the array of cs subsequently to be truncated ! at the smaller value m such that c(m+1) and subsequent elements ! are negligible. Parameters: Maximum expected value of n, and ð. implicit none INTEGER n , NMAX DOUBLE PRECISION a , b , c ( n ), func , PI EXTERNAL func PARAMETER ( NMAX = 50 , PI = 3.141592653589793d0 ) INTEGER j , k DOUBLE PRECISION bma , bpa , fac , y , f ( NMAX ) DOUBLE PRECISION sum bma = 0.5d0 * ( b - a ) bpa = 0.5d0 * ( b + a ) do k = 1 , n y = cos ( PI * ( k - 0.5d0 ) / n ) f ( k ) = func ( y * bma + bpa ) end do fac = 2.d0 / n do j = 1 , n sum = 0.d0 do k = 1 , n sum = sum + f ( k ) * cos (( PI * ( j - 1 )) * (( k - 0.5d0 ) / n )) end do c ( j ) = fac * sum end do return END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! FUNCTION chebev ( a , b , c , m , x ) ! Chebyshev evaluation: All arguments are input. ! c(1:m) is an array of Chebyshev coefficients, the first m elements ! of c output from chebft (which must have been called with ! the same a and b). The Chebyshev polynomial evaluated ! and the result is returned as the function value. implicit none INTEGER m DOUBLE PRECISION chebev , a , b , x , c ( m ) INTEGER j DOUBLE PRECISION d , dd , sv , y , y2 if (( x - a ) * ( x - b ). gt . 0.d0 ) pause 'x not in range in chebev' d = 0.d0 dd = 0.d0 y = ( 2.d0 * x - a - b ) / ( b - a ) y2 = 2.d0 * y do j = m , 2 , - 1 sv = d d = y2 * d - dd + c ( j ) dd = sv end do chebev = y * d - dd + 0.5d0 * c ( 1 ) return END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SUBROUTINE chder ( a , b , c , cder , n ) ! Given a,b,c(1:n), as output from routine chebft(), and given n, ! the desired degree of approximation (length of c to be used), ! this routine returns the array cder(1:n), the Chebyshev ! coefficients of the derivative of the function whose coefficients ! are c(1:n). implicit none INTEGER n DOUBLE PRECISION a , b , c ( n ), cder ( n ) INTEGER j DOUBLE PRECISION con cder ( n ) = 0.d0 cder ( n - 1 ) = 2 * ( n - 1 ) * c ( n ) do j = n - 2 , 1 , - 1 cder ( j ) = cder ( j + 2 ) + 2 * j * c ( j + 1 ) end do con = 2.d0 / ( b - a ) do j = 1 , n cder ( j ) = cder ( j ) * con end do return END end module chebyshev","tags":"","loc":"sourcefile\\_chebyshev.f90.html"},{"title":"_constants.f90 – My Fortran project","text":"Contents Modules constants Source Code _constants.f90 Source Code module constants !! модуль с математическими и физическими константами use , intrinsic :: iso_fortran_env , only : sp => real32 , dp => real64 implicit none real ( dp ), parameter :: pi = 4.d0 * datan ( 1.d0 ) !! число Пи = 3.1415.... real ( dp ), parameter :: pi2 = 2.d0 * pi real ( dp ), parameter :: pi4 = 4.d0 * pi real ( dp ), parameter :: piq = dsqrt ( pi ) real ( dp ), parameter :: zero = 0.d0 real ( dp ), parameter :: one = 1.d0 real ( dp ), parameter :: two = 2.d0 real ( dp ), parameter :: tiny = 1.d-100 real ( dp ), parameter :: tin = 1 d - 7 real ( dp ), parameter :: talfa = 3.5d0 !! alpha particles' birth energy, MeV real ( dp ), parameter :: zalfa = 2.d0 !! alpha particles' electrical charge real ( dp ), parameter :: xmalfa = 4.d0 !! alpha particles' atomic mass real ( dp ), parameter :: clt = 3.0d+10 !! скорость света real ( dp ), parameter :: pme = 9.11e-28 real ( dp ), parameter :: pqe = 4.803e-10 real ( dp ), parameter :: xlog = 1 6.d0 + dlog ( 1 6.d0 ) real ( dp ), parameter :: c0 = dsqrt ( pi4 * pqe ** 2 / pme ) real ( dp ), parameter :: c1 = pqe / pme / clt real ( dp ), parameter :: xsgs = 1 d + 13 real ( dp ), parameter :: xwtt = 1 d - 7 real ( dp ), parameter :: cnst1 = 0.2965924106d-6 !! cnst1=(m_e/m_p)**2, CGS real ( dp ), parameter :: cnst2 = 0.359680922d-35 !! cnst2=(m_e/e)**2,  CGS contains end module constants","tags":"","loc":"sourcefile\\_constants.f90.html"},{"title":"_flux_surface_mod.f90 – My Fortran project","text":"Contents Modules FluxSurface_mod Source Code _flux_surface_mod.f90 Source Code module FluxSurface_mod !! все что связанно с магнитными поверхностями use , intrinsic :: iso_fortran_env , only : sp => real32 , dp => real64 type FluxSurface !! класс магнитной поверхности integer :: index !! номер магнитной поверхности real ( dp ) :: r !! радиус real ( dp ) :: vmax !! vmax=cltn/vto real ( dp ) :: vt !! наверно тепловая скорость электронов????? vt=fvt(r) integer :: ipt !! размер vgrid real ( dp ), allocatable :: vgrid (:) !! real ( dp ), allocatable :: vr_grid (:) !! бываший vrj real ( dp ), allocatable :: diffusion (:) !! бывший dijk(i,j,k) или dj(i) !   complex         :: inst_field1 contains !procedure :: set   => set_e !procedure :: print => e_print end type FluxSurface end module FluxSurface_mod","tags":"","loc":"sourcefile\\_flux_surface_mod.f90.html"},{"title":"_maxwell.f90 – My Fortran project","text":"Contents Modules maxwell Source Code _maxwell.f90 Source Code module maxwell use , intrinsic :: iso_fortran_env , only : sp => real32 , dp => real64 use constants , only : zero implicit none integer , parameter :: i0 = 1002 real ( dp ) vij ( i0 , 100 ), fij0 ( i0 , 100 , 2 ), fij ( i0 , 100 , 2 ) real ( dp ) dfij ( i0 , 100 , 2 ), dij ( i0 , 100 , 2 ) real ( dp ) enorm ( 100 ), fst ( 100 ) contains subroutine init_vi ( vclt , vi ) real * 8 , intent ( in ) :: vclt real * 8 , intent ( out ) :: vi ( i0 ) real * 8 vmax integer i vmax = 2.d0 * vclt do i = 1 , i0 vi ( i ) = dble ( i - 1 ) * vmax / dble ( i0 - 1 ) end do end subroutine subroutine init_fmaxw_classic ( vclt , enorm , fi , dfi ) real * 8 , intent ( in ) :: vclt , enorm real * 8 , intent ( out ) :: fi ( i0 ), dfi ( i0 ) real * 8 vi , vmax integer i vmax = 2.d0 * vclt do i = 1 , i0 vi = dble ( i - 1 ) * vmax / dble ( i0 - 1 ) if ( vi < vclt ) then fi ( i ) = fmaxw_classic ( vi , enorm , dfi ( i )) else fi ( i ) = zero dfi ( i ) = zero end if end do end subroutine subroutine init_fmaxw_ext ( vclt , enorm , fi , dfi ) real * 8 , intent ( in ) :: vclt , enorm real * 8 , intent ( out ) :: fi ( i0 ), dfi ( i0 ) real * 8 vi , vmax integer i vmax = 2.d0 * vclt do i = 1 , i0 vi = dble ( i - 1 ) * vmax / dble ( i0 - 1 ) if ( vi < vclt ) then fi ( i ) = fmaxw_ext ( vi , enorm , dfi ( i )) else fi ( i ) = zero dfi ( i ) = zero end if end do end subroutine double precision function funmaxwell ( v , dfunmaxwell ) implicit none real * 8 v , dfunmaxwell , arg , pi2sqrt parameter ( pi2sqrt = 2.506628274631d0 ) arg =- 0.5d0 * v ** 2 funmaxwell = dexp ( arg ) / pi2sqrt dfunmaxwell =- v * funmaxwell end double precision function fmaxw_classic ( v , alfa2 , dfmaxw ) implicit none real * 8 v , alfa2 , dfmaxw real * 8 arg , alfa , api , b , psiq , f , df real * 8 pi2sqrt , pisqrt , zero parameter ( pi2sqrt = 2.506628274631d0 , pisqrt = 1.77245385090552d0 ) parameter ( zero = 0.d0 ) arg =- 0.5d0 * v ** 2 * ( 1.d0 + 0.5d0 * alfa2 * v ** 2 ) fmaxw_classic = dexp ( arg ) / pi2sqrt dfmaxw =- v * ( 1.d0 + alfa2 * v ** 2 ) * fmaxw_classic end double precision function fmaxw_ext ( v , alfa2 , dfmaxw ) implicit none real * 8 v , alfa2 , dfmaxw real * 8 arg , alfa , api , b , f , df real * 8 pi2sqrt , pisqrt , zero parameter ( pi2sqrt = 2.506628274631d0 , pisqrt = 1.77245385090552d0 ) parameter ( zero = 0.d0 ) alfa = dsqrt ( alfa2 ) api = 2.d0 * alfa * dexp ( - 0.25d0 / alfa2 ) / pisqrt b = 2.d0 - erfcc ( 0.5d0 / alfa ) + api f = psiq ( v , alfa2 ) fmaxw_ext = ( f + api ) / b / pi2sqrt df =- v * (( 1.d0 - alfa2 * v ** 2 ) * f + api ) dfmaxw = df / b / pi2sqrt end double precision function fmaxw ( v , alfa2 , dfmaxw ) implicit none real * 8 v , alfa2 , dfmaxw real * 8 arg , alfa , api , b , f , df real * 8 pi2sqrt , pisqrt , zero parameter ( pi2sqrt = 2.506628274631d0 , pisqrt = 1.77245385090552d0 ) parameter ( zero = 0.d0 ) if ( alfa2 . le . zero ) then arg =- 0.5d0 * v ** 2 * ( 1.d0 - 0.5d0 * alfa2 * v ** 2 ) fmaxw = dexp ( arg ) / pi2sqrt dfmaxw =- v * ( 1.d0 - alfa2 * v ** 2 ) * fmaxw else alfa = dsqrt ( alfa2 ) api = 2.d0 * alfa * dexp ( - 0.25d0 / alfa2 ) / pisqrt b = 2.d0 - erfcc ( 0.5d0 / alfa ) + api f = psiq ( v , alfa2 ) fmaxw = ( f + api ) / b / pi2sqrt df =- v * (( 1.d0 - alfa2 * v ** 2 ) * f + api ) dfmaxw = df / b / pi2sqrt end if end double precision function psiq ( v , alfa2 ) !!! psiq=exp(ksiV**2)*erfcc(ksiV)*exp(-0.25/alfa2) implicit none double precision v , alfa2 , df double precision x , t , z , f , asymp , alfa , q , u double precision zero , zmax , pisqrt parameter ( zero = 0.d0 , zmax = 1 0.d0 , pisqrt = 1.77245385090552d0 ) alfa = dsqrt ( alfa2 ) q =- 0.25d0 / alfa2 x = 0.5d0 * ( alfa * v ** 2 - 1.d0 / alfa ) z = abs ( x ) if ( z . gt . zmax ) then !asymptotics f = dexp ( q ) * ( 1.d0 - 0.5d0 / z ** 2 + 0.75d0 / z ** 4 - 1 5.d0 / 8.d0 / z ** 6 ) / z / pisqrt else t = 1.d0 / ( 1.d0 + 0.5d0 * z ) f = t * exp ( q - 1.26551223d0 + t * ( 1.00002368d0 + t * (. 37409196 d0 + t * & &(. 09678418 d0 + t * ( - . 18628806 d0 + t * (. 27886807 d0 + t * ( - 1.13520398d0 + t * & &( 1.48851587d0 + t * ( - . 82215223 d0 + t * . 17087277 d0 ))))))))) end if if ( x . lt . zero ) then u =- 0.5d0 * v ** 2 + 0.25d0 * alfa2 * v ** 4 !u=x**2-0.25d0/alfa2 f = 2.d0 * dexp ( u ) - f end if psiq = f return end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! function erfcc ( x ) implicit none double precision erfcc , x double precision t , z , zero , zmax , pisqrt parameter ( zero = 0.d0 , zmax = 1 0.d0 , pisqrt = 1.77245385090552d0 ) z = abs ( x ) if ( z . gt . zmax ) then !asymptotics erfcc = ( 1.d0 - 0.5d0 / z ** 2 + 0.75d0 / z ** 4 - 1 5.d0 / 8.d0 / z ** 6 ) / z / pisqrt erfcc = exp ( - z * z ) * erfcc else t = 1.d0 / ( 1.d0 + 0.5d0 * z ) erfcc = t * exp ( - z * z - 1.26551223d0 + t * ( 1.00002368d0 + t * (. 37409196 d0 + t * & &(. 09678418 d0 + t * ( - . 18628806 d0 + t * (. 27886807 d0 + t * ( - 1.13520398d0 + t * & &( 1.48851587d0 + t * ( - . 82215223 d0 + t * . 17087277 d0 ))))))))) end if if ( x . lt . zero ) erfcc = 2.d0 - erfcc return end end module maxwell","tags":"","loc":"sourcefile\\_maxwell.f90.html"},{"title":"_plasma.f90 – My Fortran project","text":"Contents Modules plasma Source Code _plasma.f90 Source Code module plasma use , intrinsic :: iso_fortran_env , only : sp => real32 , dp => real64 implicit none integer ngrid , nspl !! ASTRA radial grid number real ( dp ) tcur !! время (придумать название для переменной получше) real ( dp ) rm !! minor radius in mid-plane, cm real ( dp ) b_tor0 , b_tor !! временно нужно две переменных, тоже нужно исправить real ( dp ) r0 real ( dp ) z0 real ( dp ) rh1 real ( dp ), dimension (:), allocatable :: con , tem , temi , zeff , afld real ( dp ), dimension (:), allocatable :: rh , rha , drhodr , delta , ell , gamm , amy real ( dp ) tet1 , tet2 !! бывший common /a0a2/ real ( dp ) xmi , cnye , cnyi , xsz , vt0 ! common /a0ef3/ xmi,cnye,cnyi,xsz,vt0 real ( dp ) cnstvc real ( dp ) ww ! common /a0ef2/ ww real ( dp ) cltn ! common /a0ef1/ cltn real ( dp ) vperp ( 50 , 100 ), cnstal , zza , zze , valfa !,kv !common /a0i5/ vperp(50,100),cnstal,zza,zze,valfa!,kv real ( dp ) vpmax real ( dp ) vk ( 100 ), sk ( 100 ) !common /a0i2/ vk(100) integer , parameter :: ipsy = 5 , ncoef = 5 !!   ipsy = number of polinomial decomposition coefficients !!   used for interpolation of Zakharov's moments. real ( dp ), dimension ( ipsy ) :: cdl , cly , cgm , cmy , coeffs real ( dp ) y2dn ( 501 ), y2tm ( 501 ), y2tmi ( 501 ) !! бывший common /a0l3/ real ( dp ) y2zeff ( 501 ) !! бывший common /a0l5/ integer ncheb real ( dp ) chebne ( 50 ), chebdne ( 50 ), chebddne ( 50 ) !! бывший common/ne_cheb contains subroutine init_plasma ( NA1 , ABC , BTOR , RTOR , UPDWN , GP2 , AMETR , RHO , SHIF , ELON , TRIA , MU , NE , TE , TI , ZEF , UPL ) use constants use approximation use rt_parameters use spline use chebyshev implicit none integer , intent ( in ) :: NA1 real ( dp ), intent ( in ) :: ABC , BTOR , RTOR , UPDWN , GP2 real ( dp ), dimension ( * ) :: AMETR , RHO , SHIF , ELON , TRIA , MU , NE , TE , TI , ZEF , UPL integer i , k integer , parameter :: N = 501 real ( dp ) :: znak_tor , znak_pol , fpol , dfmy ngrid = NA1 nspl = ngrid if (. not . allocated ( rh )) then allocate ( rh ( N ), rha ( N ), drhodr ( N ), con ( N ), tem ( N )) allocate ( temi ( N ), zeff ( N ), afld ( N )) allocate ( delta ( N ), ell ( N ), gamm ( N ), amy ( N )) end if do i = 1 , ngrid rh ( i ) = AMETR ( i ) / ABC rha ( i ) = RHO ( i ) / ABC !/ABC instead of /ROC is not a mistake! delta ( i ) = ( SHIF ( 1 ) - SHIF ( i )) / ABC !FRTC Shafr. shift. defin. ell ( i ) = ELON ( i ) gamm ( i ) = rh ( i ) * TRIA ( i ) con ( i ) = NE ( i ) tem ( i ) = TE ( i ) temi ( i ) = TI ( i ) zeff ( i ) = ZEF ( i ) afld ( i ) = UPL ( i ) / RTOR / GP2 !!variant end do !rh(ngrid)=1.d0 rh1 = rh ( 1 ) !saving the first ASTRA radial grid element rh ( 1 ) = 0.0d0 !shifting the first element to zero rha ( 1 ) = 0.0d0 !shifting the first element to zero delta ( 1 ) = 0.0d0 !putting delta(rh=0.)=0. gamm ( 1 ) = 0.0d0 !putting gamm(rh=0.)=0. b_tor0 = 1.d4 * BTOR * RTOR / ( RTOR + SHIF ( 1 )) !B_tor_(magnetic axis), Gauss rm = 1.d2 * ABC !minor radius in mid-plane, cm r0 = 1.d2 * ( RTOR + SHIF ( 1 )) !x-coordinate of the magnetic axis, cm z0 = 1.d2 * UPDWN !z-coordinate of the magnetic axis, cm !   spline approximation of plasma profiles ! !   shift as a function of \"minor radius\": call approx ( rh , delta , ngrid , polin1 , ipsy - 1 , coeffs ) cdl ( 1 ) = 0.0d0 do k = 2 , ipsy cdl ( k ) = coeffs ( k - 1 ) end do !   triangularity as a function of \"minor radius\": call approx ( rh , gamm , ngrid , polin1 , ipsy - 1 , coeffs ) cgm ( 1 ) = 0.0d0 do k = 2 , ipsy cgm ( k ) = coeffs ( k - 1 ) end do !   ellipticity as a function of \"minor radius\": call approx ( rh , ell , ngrid , polin , ipsy , cly ) !  \"poloidal magnetic field\": call diff ( rh , rha , ngrid , drhodr ) do i = 2 , ngrid amy ( i ) = 1.d4 * BTOR * MU ( i ) * rha ( i ) * drhodr ( i ) !print *, amy(i), BTOR, MU(i) end do !print *, '----------------' amy ( 1 ) = 0.d0 !! amy=(btor/q)*rho*(drho/dr) is a function of \"minor radius\" r=rh(i). !! Poloidal magnetic field: B_pol=amy(r)*sqrt(g22/g), where g is !! determinant of 3D metric tensor and g22 is the (22) element of !! the tensor, normalized on ABC&#94;4 and ABC&#94;2, correspondingly. !! !!  Polinomial approximation of the amy(r): !    inpt2=ngrid-3 call approx ( rh , amy , ngrid - 3 , polin1 , ipsy - 1 , coeffs ) cmy ( 1 ) = 0.d0 do k = 2 , ipsy cmy ( k ) = coeffs ( k - 1 ) end do ! зачем-то меняет знак коэффициентов???? znak_tor = dsign ( 1.d0 , dble ( itor )) b_tor = znak_tor * dabs ( b_tor0 ) fpol = fdf ( 1.d0 , cmy , ncoef , dfmy ) znak_pol = dsign ( 1.d0 , dble ( i_pol )) * dsign ( 1.d0 , fpol ) do i = 1 , ncoef cmy ( i ) = znak_pol * cmy ( i ) end do !!!!!!!!!!!!!!! spline approximation of plasma profiles !!!!!!!!!!!!!!!! call splne ( rh , con , nspl , y2dn ) call splne ( rh , tem , nspl , y2tm ) call splne ( rh , zeff , nspl , y2zeff ) call splne ( rh , temi , nspl , y2tmi ) if ( inew . ne . 0 ) then ncheb = 20 call chebft1 ( zero , 1.d0 , chebne , ncheb , fn ) call chder ( zero , 1.d0 , chebne , chebdne , ncheb ) call chder ( zero , 1.d0 , chebdne , chebddne , ncheb ) end if call init_parameters call find_volums_and_surfaces end subroutine subroutine init_parameters use constants use approximation use rt_parameters implicit none real ( dp ) :: xly , xlyp , arg1 , arg2 real ( dp ) :: hr , dn1 , dn2 , dn3 , sss !!! xly = fdf ( one , cly , ncoef , xlyp ) arg1 = ( zplus - z0 ) / ( xly * rm ) arg2 = ( zminus - z0 ) / ( xly * rm ) if ( dabs ( arg1 ). lt . 1.d0 ) then tet1 = dasin ( arg1 ) ! upper grill corner poloidal coordinate else tet1 = 0.5d0 * pi ! upper grill corner poloidal coordinate end if if ( dabs ( arg2 ). lt . 1.d0 ) then tet2 = dasin ( arg2 ) ! lower grill corner poloidal coordinate else tet2 =- 0.5d0 * pi ! lower grill corner poloidal coordinate end if !------------------------------------------------------------ ! calculate constants !--------------------------------------- hr = 1.d0 / dble ( nr + 1 ) dn1 = 1 d0 / ( zi1 + dni2 * zi2 + dni3 * zi3 ) dn2 = dni2 * dn1 dn3 = dni3 * dn1 sss = zi1 ** 2 * dn1 / xmi1 + zi2 ** 2 * dn2 / xmi2 + zi3 ** 2 * dn3 / xmi3 xmi = 183 6.d0 / sss cnstvc = (. 75 d0 * piq * sss / 183 6.d0 ) ** ( 1.d0 / 3.d0 ) ww = freq * pi2 * 1.0d+09 cnye = xlog / pi4 cnyi = dsqrt ( 2 d0 ) / ( 3 d0 * piq ) !%for Vt=sqrt(Te/m) vt0 = fvt ( zero ) !!!!!!!!      ptkev=ft(zero)/0.16d-8  !Te in keV cltn = clt / vt0 xsz = clt / ww / rm !ccur=pqe*vt0*0.333d-9 !!      ccurnr=pqe*pqe*0.333d-9/pme rrange = rrange * hr !ToDo если вызывается несколько раз то будут проблемы valfa = 1.d9 * dsqrt ( 1.91582d0 * talfa / xmalfa ) !  valfa (cgs units) = birth velocity zza = cnst1 * ( zalfa / xmalfa / valfa ) ** 2 * ( clt / valfa ) ** 3 / pi zze = cnst2 * 2.d9 * freq cnstal = ( dsqrt ( cnst1 ) / xmalfa / pi ) * ( zalfa * vt0 / valfa ) ** 2 * clt / valfa vpmax = dsqrt ( energy / talfa ) !  \"vpmax\" in valfa velocity units ! end subroutine subroutine find_volums_and_surfaces use constants use rt_parameters implicit none integer j real ( dp ) hr , rxx , vk0 , sk0 !-------------------------------------------------------- ! find volums and surfaces !-------------------------------------------------------- hr = 1.d0 / dble ( nr + 1 ) vk0 = pi2 * hr * rm ** 3 sk0 = hr * rm ** 2 do j = 1 , nr rxx = hr * dble ( j ) vk ( j ) = vk0 * gaussint ( obeom , zero , pi2 , rxx , eps ) sk ( j ) = sk0 * gaussint ( ploshad , zero , pi2 , rxx , eps ) end do end subroutine double precision function fn ( x ) ! plasma  density,  cm&#94;-3 use spline !      use plasma implicit real * 8 ( a - h , o - z ) !common /a0l3/ y2dn(501),y2tm(501),y2tmi(501) !common /a0l4/ con(501),tem(501),temi(501),nspl parameter ( zero = 0.d0 , alfa = 4.d0 , dr = . 02 d0 ) pa = dabs ( x ) if ( pa . le . rh ( nspl )) then call splnt ( rh , con , y2dn , nspl , pa , y , dy ) else r = pa - rh ( nspl ) y = con ( nspl ) * dexp ( - alfa * ( r / dr ) ** 2 ) end if fn = y * 1.d+13 !cm&#94;-3 end double precision function fvt ( r ) implicit real * 8 ( a - h , o - z ) pt = ft ( r ) fvt = dsqrt ( pt / 9.11d-28 ) end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! double precision function ft ( x ) ! electron temperature, erg use spline !    use plasma implicit real * 8 ( a - h , o - z ) !common /a0l3/ y2dn(501),y2tm(501),y2tmi(501) !common /a0l4/ con(501),tem(501),temi(501),nspl parameter ( zero = 0.d0 , alfa = 4.d0 , dr = . 02 d0 ) pa = dabs ( x ) !#@sav if ( pa . le . rh ( nspl )) then call splnt ( rh , tem , y2tm , nspl , pa , y , dy ) else r = pa - rh ( nspl ) y = tem ( nspl ) * dexp ( - alfa * ( r / dr ) ** 2 ) end if !!      ft=y            ! kev ft = y * 0.16d-8 ! erg end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! double precision function obeom ( ptet , pa ) use constants use approximation !    use plasma implicit real * 8 ( a - h , o - z ) !common /a0befr/ pi,pi2 !common /a0ef1/ cltn !     common /a0k/ cdl(10),cly(10),cgm(10),cmy(10),ncoef parameter ( pa0 = 0.d0 ) xdl = fdf ( pa , cdl , ncoef , xdlp ) xly = fdf ( pa , cly , ncoef , xlyp ) xgm = fdf ( pa , cgm , ncoef , xgmp ) xlyv = xlyp * pa + xly cotet = dcos ( ptet ) sitet = dsin ( ptet ) dxdr =- xdlp + cotet - xgmp * sitet ** 2 dxdt =- ( pa + two * xgm * cotet ) * sitet dzdr = xlyv * sitet dzdt = xly * pa * cotet x0 = r0 / rm - xdl + pa * cotet - xgm * sitet ** 2 dxdrdt =- sitet - two * xgmp * sitet * cotet dzdrdt = xlyv * cotet dxdtdt =- pa * cotet - two * xgm * ( cotet ** 2 - sitet ** 2 ) dzdtdt =- xly * pa * sitet x0t = dxdt !-------------------------------------- ! components of metric tensor !-------------------------------------- g11 = dxdr ** 2 + dzdr ** 2 g22 = dxdt ** 2 + dzdt ** 2 g12 = dxdr * dxdt + dzdr * dzdt g33 = x0 ** 2 xj = ( dzdr * dxdt - dxdr * dzdt ) ** 2 !gg=g11*g22-g12*g12 g = xj * g33 obeom = dsqrt ( g ) end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! double precision function ploshad ( ptet , pa ) use constants use approximation !    use plasma implicit real * 8 ( a - h , o - z ) !common /a0befr/ pi,pi2 !common /a0ef1/ cltn !     common /a0k/ cdl(10),cly(10),cgm(10),cmy(10),ncoef parameter ( pa0 = 0.d0 ) xdl = fdf ( pa , cdl , ncoef , xdlp ) xly = fdf ( pa , cly , ncoef , xlyp ) xgm = fdf ( pa , cgm , ncoef , xgmp ) xlyv = xlyp * pa + xly cotet = dcos ( ptet ) sitet = dsin ( ptet ) dxdr =- xdlp + cotet - xgmp * sitet ** 2 dxdt =- ( pa + two * xgm * cotet ) * sitet dzdr = xlyv * sitet dzdt = xly * pa * cotet x0 = r0 / rm - xdl + pa * cotet - xgm * sitet ** 2 dxdrdt =- sitet - two * xgmp * sitet * cotet dzdrdt = xlyv * cotet dxdtdt =- pa * cotet - two * xgm * ( cotet ** 2 - sitet ** 2 ) dzdtdt =- xly * pa * sitet x0t = dxdt !-------------------------------------- ! components of metric tensor !-------------------------------------- g11 = dxdr ** 2 + dzdr ** 2 g22 = dxdt ** 2 + dzdt ** 2 g12 = dxdr * dxdt + dzdr * dzdt xj = ( dzdr * dxdt - dxdr * dzdt ) ** 2 !gg=g11*g22-g12*g12 ploshad = dsqrt ( xj ) end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! real ( dp ) function gaussint ( f , a , b , r , eps ) implicit none real ( dp ) w ( 12 ), x ( 12 ) real ( dp ) f , a , b , r , eps real ( dp ) aa , bb , c1 , c2 , s8 , s16 , u , y , delta integer i !!      save w,x,const !sav# real ( dp ), parameter :: const = 1.0d-12 data w & / 0.101228536290376 , 0.222381034453374 , 0.313706645877887 , & 0.362683783378362 , 0.027152459411754 , 0.062253523938648 , & 0.095158511682493 , 0.124628971255534 , 0.149595988816577 , & 0.169156519395003 , 0.182603415044924 , 0.189450610455069 / data x & / 0.960289856497536 , 0.796666477413627 , 0.525532409916329 , & 0.183434642495650 , 0.989400934991650 , 0.944575023073233 , & 0.865631202387832 , 0.755404408355003 , 0.617876244402644 , & 0.458016777657227 , 0.281603550779259 , 0.095012509837637 / delta = const * dabs ( a - b ) gaussint = 0 d0 aa = a 5 y = b - aa if ( dabs ( y ). le . delta ) return 2 bb = aa + y c1 = 0.5d0 * ( aa + bb ) c2 = c1 - aa s8 = 0 d0 s16 = 0 d0 do i = 1 , 4 u = x ( i ) * c2 s8 = s8 + w ( i ) * ( f ( c1 + u , r ) + f ( c1 - u , r )) end do do i = 5 , 12 u = x ( i ) * c2 s16 = s16 + w ( i ) * ( f ( c1 + u , r ) + f ( c1 - u , r )) end do s8 = s8 * c2 s16 = s16 * c2 if ( dabs ( s16 - s8 ) . gt . eps * ( 1 d0 + dabs ( s16 ))) go to 4 gaussint = gaussint + s16 aa = bb go to 5 4 y = 0.5d0 * y if ( dabs ( y ) . gt . delta ) go to 2 write ( * , 7 ) gaussint = 0 d0 return 7 format ( 1 x , 'gaussint ... too high accuracy required' ) end end module plasma","tags":"","loc":"sourcefile\\_plasma.f90.html"},{"title":"_spectrum.f90 – My Fortran project","text":"Contents Modules spectrum1D Source Code _spectrum.f90 Source Code module spectrum1D use , intrinsic :: iso_fortran_env , only : sp => real32 , dp => real64 implicit none integer :: ispl !+ size of spectrum real ( dp ) :: plaun !+ power of spectrum real ( dp ) :: ynzm0 ( 1001 ) !+ real ( dp ) :: pm0 ( 1001 ) !+ integer , parameter , private :: HEADER_LENGTH = 53 contains subroutine read_positive_spectrum ( file_name , p_in ) implicit none character ( * ) file_name real ( dp ) :: p_in integer , parameter :: iunit = 20 integer :: i , i1 real ( dp ) :: anz , apz open ( iunit , file = file_name ) do i = 1 , HEADER_LENGTH read ( iunit , * ) end do do i = 1 , 10000 read ( iunit , * ) anz , apz if ( apz . eq . - 8888 8.d0 ) then plaun = p_in * anz !input power in positive spectrum exit end if ynzm0 ( i ) = anz pm0 ( i ) = apz i1 = i end do close ( iunit ) ispl = i1 if ( ispl . gt . 4001 ) stop 'too many points in spectrum' end subroutine read_positive_spectrum subroutine read_negative_spectrum ( file_name , p_in ) implicit none character ( * ) file_name real ( dp ) :: p_in integer , parameter :: iunit = 20 integer :: i , i1 real ( dp ) :: anz , apz open ( iunit , file = file_name ) do i = 1 , HEADER_LENGTH read ( iunit , * ) end do apz = 0.d0 do while ( apz . ne . - 8888 8.d0 ) read ( iunit , * ) anz , apz end do read ( iunit , * ) plaun = p_in * ( 1.d0 - anz ) !input power in negative spectrum if ( plaun > 0.d0 ) then do i = 1 , 10000 read ( iunit , * , end = 10 ) ynzm0 ( i ), pm0 ( i ) i1 = i end do end if 10 close ( iunit ) ispl = i1 if ( ispl . gt . 4001 ) stop 'too many points in spectrum' end subroutine read_negative_spectrum end module spectrum1D","tags":"","loc":"sourcefile\\_spectrum.f90.html"},{"title":"_utils.f90 – My Fortran project","text":"Contents Modules Utils Source Code _utils.f90 Source Code module Utils contains function sys_time () ! ** return system time implicit none real ( 8 ) sys_time integer count , count_rate , count_max call system_clock ( count , count_rate , count_max ) sys_time = count * 1.0 / count_rate return end end  module Utils","tags":"","loc":"sourcefile\\_utils.f90.html"},{"title":"__rt_parameters.f90 – My Fortran project","text":"Contents Modules rt_parameters Source Code __rt_parameters.f90 Source Code module rt_parameters use , intrinsic :: iso_fortran_env , only : sp => real32 , dp => real64 implicit none !   physical parameters real ( dp ) :: freq !! Freq,     RF frequency, GHz real ( dp ) :: xmi1 !!  Mi1/Mp,  relative mass of ions 1 real ( dp ) :: zi1 !! charge of ions 1 real ( dp ) :: xmi2 !! Mi2/Mp,  relative mass of ions 2 real ( dp ) :: zi2 !! charge of ions 2 real ( dp ) :: dni2 !!  0.03   Ni2/Ni1, relative density of ions 2 real ( dp ) :: xmi3 !!  Mi3/Mp,  relative mass of ions 3 real ( dp ) :: zi3 !!  charge of ions 3 real ( dp ) :: dni3 !!  Ni3/Ni1, relative density of ions 3 !!!!!!!!!!!!!  parameters for alphas calculations !!! integer :: itend0 !! itend0,   if = 0, no alphas real ( dp ) :: energy !! energy,   max. perp. energy of alphas (MeV) real ( dp ) :: factor !! factor,   factor in alpha source real ( dp ) :: dra !! dra,      relative alpha source broadening (dr/a) integer :: kv !! kv,       V_perp  greed number !!!!!!!!!!!!! numerical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!! integer :: nr !! nr,  radial grid number  <= 505 real ( dp ) :: hmin1 !! hmin1, rel.(hr) min. step in the Fast comp. mode, <1.d0 real ( dp ) :: rrange !! rrange,   rel.(hr) size of a 'turning' point region, <1.d0 real ( dp ) :: eps !! eps,      accuracy real ( dp ) :: hdrob !! hdrob,    h4 correction, real ( dp ) :: cleft !! cleft,    left Vz plato border shift (<1) real ( dp ) :: cright !! cright,   right Vz plato border shift (>1) real ( dp ) :: cdel !! cdel,     (left part)/(Vz plato size) real ( dp ) :: rbord !! rbord,    relative radius of reflection, <1. real ( dp ) :: pchm !! pchm,     threshold between 'strong' and weak' absorption, <1. real ( dp ) :: pabs0 !! pabs,     part of remaining power interp. as absorption real ( dp ) :: pgiter !! pgiter,   relative accuracy to stop iterations integer :: ni1 !! ni1,      grid number in the left part of Vz plato integer :: ni2 !! ni2,      grid number in the right part of Vz plato integer :: niterat !! niterat,  maximal number of iterations integer :: nmaxm ( 4 ) !! nmaxm(1), permitted reflections at 0 iteration !! nmaxm(2), permitted reflections at 1 iteration !! nmaxm(3), permitted reflections at 2 iteration !! nmaxm(4), permitted reflections at 3 iteration integer :: maxstep2 !! maxstep2, maximal steps' number in Fast comp. mode integer :: maxstep4 !! maxstep4, maximal steps' number in Slow comp. mode !!!!!!!!!!!!!  options !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! integer :: ipri !! ipri, printing output monitoring: 0,1,2,3,4 integer :: iw !! iw, initial mode (slow=1, fast=-1) integer :: ismth !! ismth, if=0, no smoothing in Ne(rho),Te(rho),Ti(rho) integer :: ismthalf !! ismthalf,  if=0, no smoothing in D_alpha(vperp) integer :: ismthout !! ismthout,  if=0, no smoothing in output profiles integer :: inew !! inew=0 for usual tokamak&Ntor_grill; 1 or 2 for g' in ST&Npol_grill integer :: itor !! itor,      +-1, Btor direction in right coord{drho,dteta,dfi} integer :: i_pol !! ipol,      +-1, Bpol direction in right coord{drho,dteta,dfi} !!!!!!!!!!!!!  grill parameters and input LH spectrum !!!!!!!!!!!! real ( dp ) :: zplus !! Zplus,    upper grill corner in centimeters real ( dp ) :: zminus !! Zminus,   lower grill corner in centimeters integer :: ntet !! ntet,     theta grid number integer :: nnz !! nnz,      N_phi grid number contains subroutine show_parameters () print * , \"Freq = \" , freq print * , \"xmi1 = \" , xmi1 print * , \"zi1 = \" , zi1 print * , \"xmi2 = \" , xmi2 print * , \"zi2 = \" , zi2 print * , \"dni2 = \" , dni2 print * , \"---------- grill parameters and input LH spectrum \" print * , \"zplus = \" , zplus print * , \"zminus = \" , zminus print * , \"ntet = \" , ntet print * , \"nnz = \" , nnz end subroutine show_parameters subroutine read_parameters ( file_name ) implicit none integer , parameter :: iunit = 20 character ( * ) file_name print * , file_name open ( iunit , file = file_name ) !!!!!!!!!!!!!  read  physical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! read ( iunit , * ) read ( iunit , * ) freq read ( iunit , * ) xmi1 read ( iunit , * ) zi1 read ( iunit , * ) xmi2 read ( iunit , * ) zi2 read ( iunit , * ) dni2 read ( iunit , * ) xmi3 read ( iunit , * ) zi3 read ( iunit , * ) dni3 !!!!!!!!!!!!!  read parameters for alphas calculation !!!!!!!!!!!!!!!!!!! read ( iunit , * ) read ( iunit , * ) itend0 read ( iunit , * ) energy read ( iunit , * ) factor read ( iunit , * ) dra read ( iunit , * ) kv !!!!!!!!!!!!!  read  numerical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!! read ( iunit , * ) read ( iunit , * ) nr read ( iunit , * ) hmin1 read ( iunit , * ) rrange read ( iunit , * ) eps read ( iunit , * ) hdrob read ( iunit , * ) cleft read ( iunit , * ) cright read ( iunit , * ) cdel read ( iunit , * ) rbord read ( iunit , * ) pchm read ( iunit , * ) pabs0 read ( iunit , * ) pgiter read ( iunit , * ) ni1 read ( iunit , * ) ni2 read ( iunit , * ) niterat read ( iunit , * ) nmaxm ( 1 ) read ( iunit , * ) nmaxm ( 2 ) read ( iunit , * ) nmaxm ( 3 ) read ( iunit , * ) nmaxm ( 4 ) read ( iunit , * ) maxstep2 read ( iunit , * ) maxstep4 !!!!!!!!!!!!!  read  options !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! read ( iunit , * ) read ( iunit , * ) ipri read ( iunit , * ) iw read ( iunit , * ) ismth read ( iunit , * ) ismthalf read ( iunit , * ) ismthout read ( iunit , * ) inew read ( iunit , * ) itor !Btor direction in right-hand {drho,dteta,dfi} read ( iunit , * ) i_pol !Bpol direction in right-hand {drho,dteta,dfi} !!!!!!!!!!!!!  read grill parameters and input LH spectrum !!!!!!!!!!!! read ( iunit , * ) read ( iunit , * ) zplus read ( iunit , * ) zminus read ( iunit , * ) ntet read ( iunit , * ) nnz read ( iunit , * ) close ( iunit ) print * , 'checking initial parameters' !!!!!!!!!!!!! checking initial parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( kv . gt . 50 ) kv = 50 if ( nr . gt . 100 ) nr = 100 if ( ni1 . eq . 0 ) ni1 = 20 if ( ni2 . eq . 0 ) ni2 = 20 if ( ni1 + ni2 . gt . 100 ) then ni1 = 60 ni2 = 40 end if if ( nnz * ntet . gt . 10000 ) then nnz = 250 ntet = 40 pause 'nnz and ntet changed, because nnz*ntet>10000' end if call show_parameters end subroutine read_parameters end module rt_parameters","tags":"","loc":"sourcefile\\__rt_parameters.f90.html"},{"title":"__spline.f90 – My Fortran project","text":"Contents Modules spline Source Code __spline.f90 Source Code module spline implicit none contains subroutine splne ( x , y , n , y2 ) integer , parameter :: nn = 1001 real * 8 , parameter :: zero = 0 d0 integer n real * 8 x ( n ), y ( n ), y2 ( n ), u ( nn ) integer i , k real * 8 p , qn , un , sig if ( n . gt . nn ) stop 'n>nn in splne!' y2 ( 1 ) = zero u ( 1 ) = zero do i = 2 , n - 1 sig = ( x ( i ) - x ( i - 1 )) / ( x ( i + 1 ) - x ( i - 1 )) p = sig * y2 ( i - 1 ) + 2.d0 y2 ( i ) = ( sig - 1.d0 ) / p u ( i ) = ( 6.d0 * (( y ( i + 1 ) - y ( i )) / ( x ( i + 1 ) - x ( i )) - ( y ( i ) - y ( i - 1 )) / ( x ( i ) - x ( i - 1 ))) / ( x ( i + 1 ) - x ( i - 1 )) - sig * u ( i - 1 )) / p end do qn = zero un = zero y2 ( n ) = ( un - qn * u ( n - 1 )) / ( qn * y2 ( n - 1 ) + 1.d0 ) do k = n - 1 , 1 , - 1 y2 ( k ) = y2 ( k ) * y2 ( k + 1 ) + u ( k ) end do return end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine splnt ( xa , ya , y2a , n , x , y , dy ) real * 8 , parameter :: zero = 0 d0 integer n real * 8 xa ( n ), ya ( n ), y2a ( n ) integer k , klo , khi real * 8 x , h , a , b , aa , bb , hh , ax , bx , y , dy klo = 1 khi = n do while ( khi - klo . gt . 1 ) k = ( khi + klo ) / 2 if ( xa ( k ). gt . x ) then khi = k else klo = k endif end do h = xa ( khi ) - xa ( klo ) if ( h . eq . zero ) then write ( * , * ) 'bad x input in splnt(), x=' , x write ( * , * ) 'klo=' , klo , ' kho=' , khi stop end if a = ( xa ( khi ) - x ) / h b = ( x - xa ( klo )) / h aa = a ** 2 bb = b ** 2 hh = h ** 2 / 6 d0 ax =- 1 d0 / h bx =- ax y = a * ya ( klo ) + b * ya ( khi ) + ( a * ( aa - 1 d0 ) * y2a ( klo ) + b * ( bb - 1 d0 ) * y2a ( khi )) * hh dy = ax * ya ( klo ) + bx * ya ( khi ) + ax * (( 3.d0 * aa - 1 d0 ) * y2a ( klo ) - ( 3.d0 * bb - 1 d0 ) * y2a ( khi )) * hh end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine dsplnt ( xa , ya , y2a , n , x , y , dy , ddy ) real * 8 , parameter :: zero = 0 d0 integer n real * 8 xa ( n ), ya ( n ), y2a ( n ) integer k , klo , khi real * 8 x , h , a , b , aa , bb , hh , ax , bx , y , dy , ddy klo = 1 khi = n do while ( khi - klo . gt . 1 ) k = ( khi + klo ) / 2 if ( xa ( k ). gt . x ) then khi = k else klo = k endif end do h = xa ( khi ) - xa ( klo ) if ( h . eq . zero ) then write ( * , * ) 'bad x input in splnt(), x=' , x write ( * , * ) 'klo=' , klo , ' kho=' , khi stop end if a = ( xa ( khi ) - x ) / h b = ( x - xa ( klo )) / h aa = a ** 2 bb = b ** 2 hh = h ** 2 / 6 d0 ax =- 1 d0 / h bx =- ax y = a * ya ( klo ) + b * ya ( khi ) + ( a * ( aa - 1 d0 ) * y2a ( klo ) + b * ( bb - 1 d0 ) * y2a ( khi )) * hh dy = ax * ya ( klo ) + bx * ya ( khi ) + ax * (( 3.d0 * aa - 1 d0 ) * y2a ( klo ) - ( 3.d0 * bb - 1 d0 ) * y2a ( khi )) * hh ddy = 6.d0 * ax * ax * ( a * y2a ( klo ) + b * y2a ( khi )) * hh end end module spline","tags":"","loc":"sourcefile\\__spline.f90.html"}]}