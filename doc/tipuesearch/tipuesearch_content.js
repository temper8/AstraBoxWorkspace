var tipuesearch = {"pages":[{"title":" FRTS project ","text":"FRTS project This is my Fortran project! Код рейтрейсинга Developer Info Popov Lab","tags":"home","loc":"index.html"},{"title":"FokkerPlanck1D – FRTS project ","text":"type, public :: FokkerPlanck1D Contents Variables enorm v_lim v f i0 alfa2 n h d1 d2 d3 Constructor FokkerPlanck1D Type-Bound Procedures print solve_time_step init_zero_diffusion init_diffusion Components Type Visibility Attributes Name Initial real(kind=dp), public :: enorm = 0 real(kind=dp), public :: v_lim = 0 real(kind=dp), public, allocatable :: v (:) real(kind=dp), public, allocatable :: f (:) integer, public :: i0 = 0 real(kind=dp), public :: alfa2 = 0 integer, public :: n = 0 real(kind=dp), public :: h = 0 real(kind=dp), public, allocatable :: d1 (:) real(kind=dp), public, allocatable :: d2 (:) real(kind=dp), public, allocatable :: d3 (:) Constructor public        interface FokkerPlanck1D public  function FokkerPlanck1D_constructor (e, v_lim, v, f) result(this) Arguments Type Intent Optional Attributes Name real(kind=dp), value :: e real(kind=dp), value :: v_lim real(kind=dp), value :: v (:) real(kind=dp), value :: f (:) Return Value type( FokkerPlanck1D ) Type-Bound Procedures procedure, public :: print => FokkerPlanck1D_print public  subroutine FokkerPlanck1D_print (this) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(in) :: this procedure, public :: solve_time_step => FokkerPlanck1D_solve_time_step public  subroutine FokkerPlanck1D_solve_time_step (this, dt, nt) !!!!!!!!!!   solve problem   !!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this real(kind=dp), intent(in) :: dt integer, intent(in) :: nt procedure, public :: init_zero_diffusion => FokkerPlanck1D_init_zero_diffusion public  subroutine FokkerPlanck1D_init_zero_diffusion (this) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this procedure, public :: init_diffusion => FokkerPlanck1D_init_diffusion public  subroutine FokkerPlanck1D_init_diffusion (this, dif) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this real(kind=dp), intent(in), dimension(:) :: dif","tags":"","loc":"type\\fokkerplanck1d.html"},{"title":"spectrum_point – FRTS project ","text":"type, public :: spectrum_point Contents Variables nz ny Ntor Npol power Components Type Visibility Attributes Name Initial real(kind=wp), public :: nz real(kind=wp), public :: ny real(kind=wp), public :: Ntor Ntau=-Ntor real(kind=wp), public :: Npol Ntet=Npol real(kind=wp), public :: power power","tags":"","loc":"type\\spectrum_point.html"},{"title":"spectrum – FRTS project ","text":"type, public :: spectrum Contents Variables size input_power power_ratio max_power sum_power direction data Constructor spectrum Type-Bound Procedures get_positive_part get_negative_part calc_max_power Components Type Visibility Attributes Name Initial integer, public :: size size of spectrum real(kind=wp), public :: input_power power of spectrum real(kind=wp), public :: power_ratio доля входной мощности real(kind=wp), public :: max_power real(kind=wp), public :: sum_power суммарная power integer, public :: direction направление спектра   +1 или -1 или 0 - полный type( spectrum_point ), public, allocatable :: data (:) Constructor public        interface spectrum public  function spectrum_constructor (size) result(this) Arguments Type Intent Optional Attributes Name integer, value :: size Return Value type( spectrum ) Type-Bound Procedures procedure, public :: get_positive_part => get_positive_part_method public  function get_positive_part_method (this) result(spectr) Arguments Type Intent Optional Attributes Name class( spectrum ), intent(in) :: this Return Value type( spectrum ) procedure, public :: get_negative_part => get_negative_part_method public  function get_negative_part_method (this) result(spectr) Arguments Type Intent Optional Attributes Name class( spectrum ), intent(in) :: this Return Value type( spectrum ) procedure, public :: calc_max_power => calc_max_power_method public  subroutine calc_max_power_method (this) Arguments Type Intent Optional Attributes Name class( spectrum ), intent(inout) :: this","tags":"","loc":"type\\spectrum.html"},{"title":"FluxSurface – FRTS project ","text":"type, public :: FluxSurface класс магнитной поверхности Contents Variables index r vmax vt ipt vgrid vr_grid diffusion Components Type Visibility Attributes Name Initial integer, public :: index номер магнитной поверхности real(kind=wp), public :: r радиус real(kind=wp), public :: vmax vmax=cltn/vto real(kind=wp), public :: vt наверно тепловая скорость электронов????? vt=fvt(r) integer, public :: ipt размер vgrid real(kind=wp), public, allocatable :: vgrid (:) real(kind=wp), public, allocatable :: vr_grid (:) бываший vrj real(kind=wp), public, allocatable :: diffusion (:) бывший dijk(i,j,k) или dj(i)","tags":"","loc":"type\\fluxsurface.html"},{"title":"IterationResult – FRTS project ","text":"type, public :: IterationResult Contents Variables number spectr_direction P_launched P_landau P_coll P_alph alphas_power P_fast P_lost P_not_accounted P_landau_strong_absorption P_landau_weak_absorption P_turns efficiency avedens r0 eta_eff residual Type-Bound Procedures print save Components Type Visibility Attributes Name Initial integer, public :: number iteration number 'iteration=',iterat integer, public :: spectr_direction 'ispectr=',ispectr real(kind=wp), public :: P_launched P_launched, MW=',plaun real(kind=wp), public :: P_landau 'P_landau, MW=',ol real(kind=wp), public :: P_coll 'P_coll, MW=',oc real(kind=wp), public :: P_alph 'P_alph, MW=',oa real(kind=wp), public :: alphas_power 'Alphas power, MW=',fuspow real(kind=wp), public :: P_fast real(kind=wp), public :: P_lost real(kind=wp), public :: P_not_accounted real(kind=wp), public :: P_landau_strong_absorption real(kind=wp), public :: P_landau_weak_absorption real(kind=wp), public :: P_turns real(kind=wp), public :: efficiency real(kind=wp), public :: avedens real(kind=wp), public :: r0 real(kind=wp), public :: eta_eff real(kind=wp), public :: residual невязка 'nevyazka=', pchg Type-Bound Procedures procedure, public :: print => iteration_result_print public  subroutine iteration_result_print (this) Arguments Type Intent Optional Attributes Name class( IterationResult ), intent(in) :: this procedure, public :: save => iteration_result_save public  subroutine iteration_result_save (this, time_stamp) save Iteration Result to file Arguments Type Intent Optional Attributes Name class( IterationResult ), intent(in) :: this real(kind=wp), intent(in) :: time_stamp","tags":"","loc":"type\\iterationresult.html"},{"title":"currlhcd – FRTS project","text":"function currlhcd(v, f) result(curs) Arguments Type Intent Optional Attributes Name real(kind=8) :: v (:) real(kind=8) :: f (:) Return Value real(kind=8) Contents","tags":"","loc":"proc\\currlhcd.html"},{"title":"d – FRTS project","text":"function d(x) Uses maxwell call ddc(d) !      call linf(vvj,ddj,x,d,klo,khi) Arguments Type Intent Optional Attributes Name real(kind=8) :: x Return Value real(kind=8) Contents Common Blocks dddql Common Blocks common /dddql/ Type Attributes Name Initial real(kind=8) :: d0 integer :: jindex integer :: kindex","tags":"","loc":"proc\\d.html"},{"title":"drivencurrent95 – FRTS project","text":"subroutine drivencurrent95(outj, sigmaj, UPL, NRD, NA1, TIME, TAU, ROC, RTOR, GP2) Uses FokkerPlanck_module outj(i)  = LH driven current density, MA/m&#94;2\n   dndt(i)  = d&#94;2Jr1/dt&#94;2/E, MA/m&#94;2/sec&#94;2/(V/m), ~runaway d(el.density)/dt/E\n   djdt(i)  = dJr2/dt, time drivative of runaway current Jr2, MA/m&#94;2/sec\n   outjrun(i)  = LH driven runaway current density, MA/m&#94;2\n   outnerun(i) = runaway electron density/10&#94;19 m&#94;-3 variant\n!!!!!!!!!!! starting LH current calculation !!!!!!!!!!!!!!!!!\npositive spectrum:\nnegative spectrum:\n!!       write( , ) i,outj(i) Arguments Type Intent Optional Attributes Name real(kind=8) :: outj (NRD) real(kind=8) :: sigmaj (NRD) double precision :: UPL (NRD) integer :: NRD integer :: NA1 double precision :: TIME double precision :: TAU double precision :: ROC double precision :: RTOR double precision :: GP2 Contents","tags":"","loc":"proc\\drivencurrent95.html"},{"title":"lhcurrent – FRTS project","text":"subroutine lhcurrent(outj, ohj, cuj, cujoh, inpt, ispectr) Uses plasma maxwell rt_parameters implicit real*8 (a-h,o-z)\n  write(*,*)\n  write(*,*)'ccur',ccur,' curdir=',curdir,' nr=',nr\n  write(*,*)'cu_out, MA=',cu_out,' cfull, A=',cfull\n       close(111) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name real(kind=8) :: outj (*) real(kind=8) :: ohj (*) real(kind=8) :: cuj real(kind=8) :: cujoh integer :: inpt integer :: ispectr Contents Common Blocks plosh Common Blocks common /plosh/ Type Attributes Name Initial real :: zv1 (100,2) real :: zv2 (100,2)","tags":"","loc":"proc\\lhcurrent.html"},{"title":"currlhcd_old – FRTS project","text":"subroutine currlhcd_old(i0, v, f, f0, curs, curs0) Arguments Type Intent Optional Attributes Name integer :: i0 real(kind=8) :: v (*) real(kind=8) :: f (*) real(kind=8) :: f0 (*) real(kind=8) :: curs real(kind=8) :: curs0 Contents","tags":"","loc":"proc\\currlhcd_old.html"},{"title":"ddc – FRTS project","text":"subroutine ddc(diffusion) Uses maxwell Arguments Type Intent Optional Attributes Name real(kind=8) :: diffusion Contents Common Blocks testf Common Blocks common /testf/ Type Attributes Name Initial real(kind=8) :: tcur","tags":"","loc":"proc\\ddc.html"},{"title":"qromb – FRTS project","text":"subroutine qromb(func, a, b, ss) Arguments Type Intent Optional Attributes Name double precision :: func double precision :: a double precision :: b double precision :: ss Contents","tags":"","loc":"proc\\qromb.html"},{"title":"polint – FRTS project","text":"subroutine polint(xa, ya, n, x, y, dy) Arguments Type Intent Optional Attributes Name double precision :: xa (n) double precision :: ya (n) integer :: n double precision :: x double precision :: y double precision :: dy Contents","tags":"","loc":"proc\\polint.html"},{"title":"trapzd – FRTS project","text":"subroutine trapzd(func, a, b, s, n) Arguments Type Intent Optional Attributes Name double precision :: func double precision :: a double precision :: b double precision :: s integer :: n Contents","tags":"","loc":"proc\\trapzd.html"},{"title":"polin – FRTS project","text":"public  function polin(k, x) Arguments Type Intent Optional Attributes Name integer :: k real(kind=wp) :: x Return Value real(kind=wp) Contents","tags":"","loc":"proc\\polin.html"},{"title":"polin1 – FRTS project","text":"public  function polin1(k, x) Arguments Type Intent Optional Attributes Name integer :: k real(kind=wp) :: x Return Value real(kind=wp) Contents","tags":"","loc":"proc\\polin1.html"},{"title":"polin2 – FRTS project","text":"public  function polin2(k, x) Arguments Type Intent Optional Attributes Name integer :: k real(kind=wp) :: x Return Value real(kind=wp) Contents","tags":"","loc":"proc\\polin2.html"},{"title":"fdf – FRTS project","text":"public  function fdf(x, c, n, df) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x real(kind=wp) :: c (n) integer :: n real(kind=wp) :: df Return Value real(kind=wp) Contents","tags":"","loc":"proc\\fdf.html"},{"title":"fdfddf – FRTS project","text":"public  function fdfddf(x, c, n, df, ddf) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x real(kind=wp) :: c (n) integer :: n real(kind=wp) :: df real(kind=wp) :: ddf Return Value real(kind=wp) Contents","tags":"","loc":"proc\\fdfddf.html"},{"title":"approx – FRTS project","text":"public  subroutine approx(x, y, n, f, m, b) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x (n) real(kind=wp) :: y (n) integer :: n real :: f integer :: m real(kind=wp) :: b (*) Contents","tags":"","loc":"proc\\approx.html"},{"title":"ludcmp – FRTS project","text":"public  subroutine ludcmp(a, n, np, indx, d) Arguments Type Intent Optional Attributes Name real(kind=wp) :: a (np,np) integer :: n integer :: np real(kind=wp) :: indx (n) real :: d Contents","tags":"","loc":"proc\\ludcmp.html"},{"title":"lubksb – FRTS project","text":"public  subroutine lubksb(a, n, np, indx, b) Arguments Type Intent Optional Attributes Name real(kind=wp) :: a (np,np) integer :: n integer :: np real(kind=wp) :: indx (n) real(kind=wp) :: b (n) Contents","tags":"","loc":"proc\\lubksb.html"},{"title":"chang_cooper_solver – FRTS project","text":"public  subroutine chang_cooper_solver(alfa2, nt, h, dt, n, ybeg, yend, d1, d2, d3, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: alfa2 integer, intent(in) :: nt real(kind=wp), intent(in) :: h real(kind=wp), intent(in) :: dt integer, intent(in) :: n real(kind=wp), intent(in) :: ybeg real(kind=wp), intent(in) :: yend real(kind=wp), intent(in) :: d1 (n+1) real(kind=wp), intent(in) :: d2 (n+1) real(kind=wp), intent(in) :: d3 (n+1) real(kind=wp), intent(inout) :: y (n+2) Contents","tags":"","loc":"proc\\chang_cooper_solver.html"},{"title":"chang_cooper_abcoef – FRTS project","text":"public  subroutine chang_cooper_abcoef(alfa2, a, b, c, f, y, dt, n, ybeg, yend, xx, h, df) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: alfa2 real(kind=wp), intent(inout) :: a (n) real(kind=wp), intent(inout) :: b (n) real(kind=wp), intent(inout) :: c (n) real(kind=wp), intent(inout) :: f (n) real(kind=wp), intent(inout) :: y (n+2) real(kind=wp), intent(in) :: dt integer, intent(in) :: n real(kind=wp), intent(in) :: ybeg real(kind=wp), intent(in) :: yend real(kind=wp), intent(in) :: xx (n+1) real(kind=wp), intent(in) :: h real(kind=wp), intent(in) :: df (n+1) Contents","tags":"","loc":"proc\\chang_cooper_abcoef.html"},{"title":"chebev – FRTS project","text":"public  function chebev(a, b, c, m, x) Arguments Type Intent Optional Attributes Name real(kind=wp) :: a real(kind=wp) :: b real(kind=wp) :: c (m) integer :: m real(kind=wp) :: x Return Value real(kind=wp) Contents","tags":"","loc":"proc\\chebev.html"},{"title":"chebft1 – FRTS project","text":"public  subroutine chebft1(a, b, c, n, func) Arguments Type Intent Optional Attributes Name real(kind=wp) :: a real(kind=wp) :: b real(kind=wp) :: c (n) integer :: n real(kind=wp) :: func Contents","tags":"","loc":"proc\\chebft1.html"},{"title":"chder – FRTS project","text":"public  subroutine chder(a, b, c, cder, n) Arguments Type Intent Optional Attributes Name real(kind=wp) :: a real(kind=wp) :: b real(kind=wp) :: c (n) real(kind=wp) :: cder (n) integer :: n Contents","tags":"","loc":"proc\\chder.html"},{"title":"show_constants – FRTS project","text":"public  subroutine show_constants() Arguments None Contents None","tags":"","loc":"proc\\show_constants.html"},{"title":"show_parameters – FRTS project","text":"public  subroutine show_parameters() Arguments None Contents None","tags":"","loc":"proc\\show_parameters.html"},{"title":"read_parameters – FRTS project","text":"public  subroutine read_parameters(file_name) !!!!!!!!!!!  read  physical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read parameters for alphas calculation !!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read  numerical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read  options !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read grill parameters and input LH spectrum !!!!!!!!!!!!\n!!!!!!!!!!! checking initial parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name character :: file_name Contents","tags":"","loc":"proc\\read_parameters.html"},{"title":"rplusk – FRTS project","text":"public  function rplusk(x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x real(kind=wp) :: dif real(kind=wp) :: alfa2 Return Value real(kind=wp) Contents","tags":"","loc":"proc\\rplusk.html"},{"title":"rplusk2 – FRTS project","text":"public  function rplusk2(x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x real(kind=wp) :: dif real(kind=wp) :: alfa2 Return Value real(kind=wp) Contents","tags":"","loc":"proc\\rplusk2.html"},{"title":"rmink – FRTS project","text":"public  function rmink(x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x real(kind=wp) :: dif real(kind=wp) :: alfa2 Return Value real(kind=wp) Contents","tags":"","loc":"proc\\rmink.html"},{"title":"rmink2 – FRTS project","text":"public  function rmink2(x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x real(kind=wp) :: dif real(kind=wp) :: alfa2 Return Value real(kind=wp) Contents","tags":"","loc":"proc\\rmink2.html"},{"title":"rs – FRTS project","text":"public  function rs(x, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x real(kind=wp) :: alfa2 Return Value real(kind=wp) Contents","tags":"","loc":"proc\\rs.html"},{"title":"qf – FRTS project","text":"public  function qf(x) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x Return Value real(kind=wp) Contents","tags":"","loc":"proc\\qf.html"},{"title":"k2 – FRTS project","text":"public  function k2(x, dif) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x real(kind=wp) :: dif Return Value real(kind=wp) Contents","tags":"","loc":"proc\\k2.html"},{"title":"kinv – FRTS project","text":"public  function kinv(x, dif) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x real(kind=wp) :: dif Return Value real(kind=wp) Contents","tags":"","loc":"proc\\kinv.html"},{"title":"kinv2 – FRTS project","text":"public  function kinv2(x, dif) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x real(kind=wp) :: dif Return Value real(kind=wp) Contents","tags":"","loc":"proc\\kinv2.html"},{"title":"savelyev_solver – FRTS project","text":"public  subroutine savelyev_solver(alfa2, nt, h, dt, n, ybeg, yend, d1, d2, d3, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: alfa2 integer, intent(in) :: nt real(kind=wp), intent(in) :: h real(kind=wp), intent(in) :: dt integer, intent(in) :: n real(kind=wp), intent(in) :: ybeg real(kind=wp), intent(in) :: yend real(kind=wp), intent(in) :: d1 (n+1) real(kind=wp), intent(in) :: d2 (n+1) real(kind=wp), intent(in) :: d3 (n+1) real(kind=wp), intent(inout) :: y (n) Contents","tags":"","loc":"proc\\savelyev_solver.html"},{"title":"savelyev_abccoef – FRTS project","text":"public  subroutine savelyev_abccoef(alfa2, a, b, c, f, y, dt, n, ybeg, yend, xx, h, d1, d2, d3) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: alfa2 real(kind=wp), intent(inout) :: a (n) real(kind=wp), intent(inout) :: b (n) real(kind=wp), intent(inout) :: c (n) real(kind=wp), intent(inout) :: f (n) real(kind=wp), intent(inout) :: y (n) real(kind=wp), intent(in) :: dt integer, intent(in) :: n real(kind=wp), intent(in) :: ybeg real(kind=wp), intent(in) :: yend real(kind=wp), intent(in) :: xx (n+1) real(kind=wp), intent(in) :: h real(kind=wp), intent(in) :: d1 (n+1) real(kind=wp), intent(in) :: d2 (n+1) real(kind=wp), intent(in) :: d3 (n+1) Contents","tags":"","loc":"proc\\savelyev_abccoef.html"},{"title":"tridag – FRTS project","text":"public  subroutine tridag(a, b, c, r, u, n) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (n) real(kind=wp), intent(in) :: b (n) real(kind=wp), intent(in) :: c (n) real(kind=wp), intent(in) :: r (n) real(kind=wp), intent(inout) :: u (n) integer, intent(in) :: n Contents","tags":"","loc":"proc\\tridag.html"},{"title":"splne – FRTS project","text":"public  subroutine splne(x, y, n, y2) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x (n) real(kind=wp) :: y (n) integer :: n real(kind=wp) :: y2 (n) Contents","tags":"","loc":"proc\\splne.html"},{"title":"splnt – FRTS project","text":"public  subroutine splnt(xa, ya, y2a, n, x, y, dy) Arguments Type Intent Optional Attributes Name real(kind=wp) :: xa (n) real(kind=wp) :: ya (n) real(kind=wp) :: y2a (n) integer :: n real(kind=wp) :: x real(kind=wp) :: y real(kind=wp) :: dy Contents","tags":"","loc":"proc\\splnt.html"},{"title":"dsplnt – FRTS project","text":"public  subroutine dsplnt(xa, ya, y2a, n, x, y, dy, ddy) Arguments Type Intent Optional Attributes Name real(kind=wp) :: xa (n) real(kind=wp) :: ya (n) real(kind=wp) :: y2a (n) integer :: n real(kind=wp) :: x real(kind=wp) :: y real(kind=wp) :: dy real(kind=wp) :: ddy Contents","tags":"","loc":"proc\\dsplnt.html"},{"title":"sys_time – FRTS project","text":"public  function sys_time() Arguments None Return Value real(kind=wp) Contents None","tags":"","loc":"proc\\sys_time.html"},{"title":"write_v_array – FRTS project","text":"public  subroutine write_v_array(v, a, time, array_name) сохраняет массивы расределения и скорости Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: v (:,:) real(kind=wp), intent(in) :: a (:,:,:) real(kind=wp), intent(in) :: time character(len=*), intent(in) :: array_name Contents","tags":"","loc":"proc\\write_v_array.html"},{"title":"write_x_array – FRTS project","text":"public  subroutine write_x_array(x, arr, time, array_name) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:,:) real(kind=wp), intent(in) :: arr (:,:) real(kind=wp), intent(in) :: time character(len=*), intent(in) :: array_name Contents","tags":"","loc":"proc\\write_x_array.html"},{"title":"write_matrix – FRTS project","text":"public  subroutine write_matrix(arr, time, array_name) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: arr (:,:) real(kind=wp), intent(in) :: time character(len=*), intent(in) :: array_name Contents","tags":"","loc":"proc\\write_matrix.html"},{"title":"write_array – FRTS project","text":"public  subroutine write_array(arr, N, array_name) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: arr (*) integer, intent(in) :: N character(len=*), intent(in) :: array_name Contents","tags":"","loc":"proc\\write_array.html"},{"title":"write_distribution – FRTS project","text":"public  subroutine write_distribution(arr, N, time) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: arr (*) integer, intent(in) :: N real(kind=wp), intent(in) :: time Contents","tags":"","loc":"proc\\write_distribution.html"},{"title":"FokkerPlanck1D_constructor – FRTS project","text":"public  function FokkerPlanck1D_constructor(e, v_lim, v, f) result(this) Arguments Type Intent Optional Attributes Name real(kind=dp), value :: e real(kind=dp), value :: v_lim real(kind=dp), value :: v (:) real(kind=dp), value :: f (:) Return Value type( FokkerPlanck1D ) Contents","tags":"","loc":"proc\\fokkerplanck1d_constructor.html"},{"title":"FokkerPlanck1D_print – FRTS project","text":"public  subroutine FokkerPlanck1D_print(this) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(in) :: this Contents","tags":"","loc":"proc\\fokkerplanck1d_print.html"},{"title":"FokkerPlanck1D_init_zero_diffusion – FRTS project","text":"public  subroutine FokkerPlanck1D_init_zero_diffusion(this) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this Contents","tags":"","loc":"proc\\fokkerplanck1d_init_zero_diffusion.html"},{"title":"FokkerPlanck1D_init_diffusion – FRTS project","text":"public  subroutine FokkerPlanck1D_init_diffusion(this, dif) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this real(kind=dp), intent(in), dimension(:) :: dif Contents","tags":"","loc":"proc\\fokkerplanck1d_init_diffusion.html"},{"title":"FokkerPlanck1D_solve_time_step – FRTS project","text":"public  subroutine FokkerPlanck1D_solve_time_step(this, dt, nt) !!!!!!!!!!   solve problem   !!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this real(kind=dp), intent(in) :: dt integer, intent(in) :: nt Contents","tags":"","loc":"proc\\fokkerplanck1d_solve_time_step.html"},{"title":"burying_procedure – FRTS project","text":"public  subroutine burying_procedure(v, f0, df0) write( , )'#1 j,k,ibeg=',j,k,ibeg\nwrite( , )'#1 v(ibeg)=',vj(ibeg),' f1/f2=',fout1/fout2 Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v (:) real(kind=8), intent(inout) :: f0 (:) real(kind=8), intent(inout), optional :: df0 (:) Contents","tags":"","loc":"proc\\burying_procedure.html"},{"title":"FokkerPlanck1D – FRTS project","text":"public interface FokkerPlanck1D Contents Module Procedures FokkerPlanck1D_constructor Module Procedures public  function FokkerPlanck1D_constructor (e, v_lim, v, f) result(this) Arguments Type Intent Optional Attributes Name real(kind=dp), value :: e real(kind=dp), value :: v_lim real(kind=dp), value :: v (:) real(kind=dp), value :: f (:) Return Value type( FokkerPlanck1D )","tags":"","loc":"interface\\fokkerplanck1d.html"},{"title":"funmaxwell – FRTS project","text":"public  function funmaxwell(v, dfunmaxwell) Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: dfunmaxwell Return Value doubleprecision Contents","tags":"","loc":"proc\\funmaxwell.html"},{"title":"fmaxw_classic – FRTS project","text":"public  function fmaxw_classic(v, alfa2, dfmaxw) Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: alfa2 real(kind=wp) :: dfmaxw Return Value doubleprecision Contents","tags":"","loc":"proc\\fmaxw_classic.html"},{"title":"fmaxw_ext – FRTS project","text":"public  function fmaxw_ext(v, alfa2, dfmaxw) Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: alfa2 real(kind=wp) :: dfmaxw Return Value doubleprecision Contents","tags":"","loc":"proc\\fmaxw_ext.html"},{"title":"fmaxw – FRTS project","text":"public  function fmaxw(v, alfa2, dfmaxw) Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: alfa2 real(kind=wp) :: dfmaxw Return Value doubleprecision Contents","tags":"","loc":"proc\\fmaxw.html"},{"title":"psiq – FRTS project","text":"public  function psiq(v, alfa2) ! psiq=exp(ksiV 2) erfcc(ksiV) exp(-0.25/alfa2) Arguments Type Intent Optional Attributes Name double precision :: v double precision :: alfa2 Return Value doubleprecision Contents","tags":"","loc":"proc\\psiq.html"},{"title":"erfcc – FRTS project","text":"public  function erfcc(x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision Contents","tags":"","loc":"proc\\erfcc.html"},{"title":"init_vi – FRTS project","text":"public  subroutine init_vi(vclt, vi) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vclt real(kind=wp), intent(out) :: vi (i0) Contents","tags":"","loc":"proc\\init_vi.html"},{"title":"init_fmaxw_classic – FRTS project","text":"public  subroutine init_fmaxw_classic(vclt, enorm, fi, dfi) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vclt real(kind=wp), intent(in) :: enorm real(kind=wp), intent(out) :: fi (i0) real(kind=wp), intent(out) :: dfi (i0) Contents","tags":"","loc":"proc\\init_fmaxw_classic.html"},{"title":"init_fmaxw_ext – FRTS project","text":"public  subroutine init_fmaxw_ext(vclt, enorm, fi, dfi) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vclt real(kind=wp), intent(in) :: enorm real(kind=wp), intent(out) :: fi (i0) real(kind=wp), intent(out) :: dfi (i0) Contents","tags":"","loc":"proc\\init_fmaxw_ext.html"},{"title":"fn – FRTS project","text":"public  function fn(x) Uses constants spline plasma  density,  cm&#94;-3 Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) Contents","tags":"","loc":"proc\\fn.html"},{"title":"fvt – FRTS project","text":"public  function fvt(r) нет описания Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: r Return Value real(kind=wp) Contents","tags":"","loc":"proc\\fvt.html"},{"title":"fn1 – FRTS project","text":"public  function fn1(x, fnp) Uses constants spline plasma density and its derivative Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(out) :: fnp Return Value real(kind=wp) Contents","tags":"","loc":"proc\\fn1.html"},{"title":"fn2 – FRTS project","text":"public  function fn2(r, fnp, fnpp) Uses constants chebyshev plasma density and its first and second derivatives Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: r real(kind=wp), intent(out) :: fnp real(kind=wp), intent(out) :: fnpp Return Value real(kind=wp) Contents","tags":"","loc":"proc\\fn2.html"},{"title":"ft – FRTS project","text":"public  function ft(x) Uses constants spline electron temperature, erg\n     ft=y            ! kev Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) Contents","tags":"","loc":"proc\\ft.html"},{"title":"fti – FRTS project","text":"public  function fti(x) Uses constants spline ion temperature, kev Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) Contents","tags":"","loc":"proc\\fti.html"},{"title":"zefff – FRTS project","text":"public  function zefff(x) Uses constants spline z_effective profile Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) Contents","tags":"","loc":"proc\\zefff.html"},{"title":"obeom – FRTS project","text":"public  function obeom(ptet, pa) Uses approximation constants Arguments Type Intent Optional Attributes Name real :: ptet real :: pa Return Value real(kind=wp) Contents","tags":"","loc":"proc\\obeom.html"},{"title":"ploshad – FRTS project","text":"public  function ploshad(ptet, pa) Uses approximation constants Arguments Type Intent Optional Attributes Name real :: ptet real :: pa Return Value real(kind=wp) Contents","tags":"","loc":"proc\\ploshad.html"},{"title":"gaussint – FRTS project","text":"public  function gaussint(f, a, b, r, eps) что-то про гаусс Arguments Type Intent Optional Attributes Name real(kind=wp) :: f real(kind=wp) :: a real(kind=wp) :: b real(kind=wp) :: r real(kind=wp) :: eps Return Value real(kind=wp) Contents","tags":"","loc":"proc\\gaussint.html"},{"title":"init_plasma – FRTS project","text":"public  subroutine init_plasma(NA1, ABC, BTOR, RTOR, UPDWN, GP2, AMETR, RHO, SHIF, ELON, TRIA, MU, NE, TE, TI, ZEF, UPL) Uses chebyshev rt_parameters approximation constants spline variant\n amy=(btor/q) rho (drho/dr) is a function of \"minor radius\" r=rh(i).\n Poloidal magnetic field: B_pol=amy(r)*sqrt(g22/g), where g is\n determinant of 3D metric tensor and g22 is the (22) element of\n the tensor, normalized on ABC&#94;4 and ABC&#94;2, correspondingly. Polinomial approximation of the amy(r): !!!!!!!!!!!!! spline approximation of plasma profiles !!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name integer, intent(in) :: NA1 real(kind=wp), intent(in) :: ABC real(kind=wp), intent(in) :: BTOR real(kind=wp), intent(in) :: RTOR real(kind=wp), intent(in) :: UPDWN real(kind=wp), intent(in) :: GP2 real(kind=wp), dimension(*) :: AMETR real(kind=wp), dimension(*) :: RHO real(kind=wp), dimension(*) :: SHIF real(kind=wp), dimension(*) :: ELON real(kind=wp), dimension(*) :: TRIA real(kind=wp), dimension(*) :: MU real(kind=wp), dimension(*) :: NE real(kind=wp), dimension(*) :: TE real(kind=wp), dimension(*) :: TI real(kind=wp), dimension(*) :: ZEF real(kind=wp), dimension(*) :: UPL Contents","tags":"","loc":"proc\\init_plasma.html"},{"title":"init_parameters – FRTS project","text":"public  subroutine init_parameters() Uses approximation constants rt_parameters !!!!!!      ptkev=ft(zero)/0.16d-8  !Te in keV\n      ccurnr=pqe pqe 0.333d-9/pme Arguments None Contents None","tags":"","loc":"proc\\init_parameters.html"},{"title":"find_volums_and_surfaces – FRTS project","text":"public  subroutine find_volums_and_surfaces() Uses constants rt_parameters Arguments None Contents None","tags":"","loc":"proc\\find_volums_and_surfaces.html"},{"title":"calc_enorm – FRTS project","text":"public  subroutine calc_enorm() Uses constants maxwell rt_parameters spline fst(j)=pn xlogj c0 4/pi4/vt 3 Arguments None Contents None","tags":"","loc":"proc\\calc_enorm.html"},{"title":"init_maxwell – FRTS project","text":"public  subroutine init_maxwell() Uses constants maxwell rt_parameters spline Arguments None Contents None","tags":"","loc":"proc\\init_maxwell.html"},{"title":"spectrum_constructor – FRTS project","text":"public  function spectrum_constructor(size) result(this) Arguments Type Intent Optional Attributes Name integer, value :: size Return Value type( spectrum ) Contents","tags":"","loc":"proc\\spectrum_constructor.html"},{"title":"get_positive_part_method – FRTS project","text":"public  function get_positive_part_method(this) result(spectr) Arguments Type Intent Optional Attributes Name class( spectrum ), intent(in) :: this Return Value type( spectrum ) Contents","tags":"","loc":"proc\\get_positive_part_method.html"},{"title":"get_negative_part_method – FRTS project","text":"public  function get_negative_part_method(this) result(spectr) Arguments Type Intent Optional Attributes Name class( spectrum ), intent(in) :: this Return Value type( spectrum ) Contents","tags":"","loc":"proc\\get_negative_part_method.html"},{"title":"read_spectrum – FRTS project","text":"public  function read_spectrum(file_name) result(spectr) Arguments Type Intent Optional Attributes Name character(len=*), value :: file_name Return Value type( spectrum ) Contents","tags":"","loc":"proc\\read_spectrum.html"},{"title":"make_spline_approximation – FRTS project","text":"public  function make_spline_approximation(spectr) result(appx_spectr) Uses constants rt_parameters spline approximation of input LH spectrum Arguments Type Intent Optional Attributes Name type( spectrum ), intent(in) :: spectr Return Value type( spectrum ) Contents","tags":"","loc":"proc\\make_spline_approximation.html"},{"title":"calc_max_power_method – FRTS project","text":"public  subroutine calc_max_power_method(this) Uses constants rt_parameters Arguments Type Intent Optional Attributes Name class( spectrum ), intent(inout) :: this Contents","tags":"","loc":"proc\\calc_max_power_method.html"},{"title":"divide_spectrum – FRTS project","text":"public  subroutine divide_spectrum(spectr, pos_spectr, neg_spectr) деление спектра на две части Arguments Type Intent Optional Attributes Name type( spectrum ), intent(in) :: spectr type( spectrum ), intent(out) :: pos_spectr type( spectrum ), intent(out) :: neg_spectr Contents","tags":"","loc":"proc\\divide_spectrum.html"},{"title":"spectrum – FRTS project","text":"public interface spectrum Contents Module Procedures spectrum_constructor Module Procedures public  function spectrum_constructor (size) result(this) Arguments Type Intent Optional Attributes Name integer, value :: size Return Value type( spectrum )","tags":"","loc":"interface\\spectrum.html"},{"title":"create_spectrum – FRTS project","text":"public  function create_spectrum() result(spectr) Uses spectrum_mod rt_parameters Arguments None Return Value type( spectrum ) Contents None","tags":"","loc":"proc\\create_spectrum.html"},{"title":"read_positive_spectrum – FRTS project","text":"public  subroutine read_positive_spectrum(file_name, p_in) Arguments Type Intent Optional Attributes Name character :: file_name real(kind=wp) :: p_in Contents","tags":"","loc":"proc\\read_positive_spectrum.html"},{"title":"read_negative_spectrum – FRTS project","text":"public  subroutine read_negative_spectrum(file_name, p_in) Arguments Type Intent Optional Attributes Name character :: file_name real(kind=wp) :: p_in Contents","tags":"","loc":"proc\\read_negative_spectrum.html"},{"title":"spectrum_approximation – FRTS project","text":"public  subroutine spectrum_approximation(ispectr) Uses constants rt_parameters spline approximation of input LH spectrum Arguments Type Intent Optional Attributes Name integer, intent(in) :: ispectr Contents","tags":"","loc":"proc\\spectrum_approximation.html"},{"title":"copy_to_spectrum_1D – FRTS project","text":"public  subroutine copy_to_spectrum_1D(spectr) Uses spectrum_mod Arguments Type Intent Optional Attributes Name type( spectrum ) :: spectr Contents","tags":"","loc":"proc\\copy_to_spectrum_1d.html"},{"title":"write_spectrum – FRTS project","text":"public  subroutine write_spectrum(ispectr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ispectr Contents","tags":"","loc":"proc\\write_spectrum.html"},{"title":"view – FRTS project","text":"public  subroutine view(tview, iview, nnz, ntet) Uses spectrum1D rt_parameters plasma approximation constants !writing trajectories into a file\n          pintld=-dland(i) (dflf+dfrt)/2d0\n          pdec1=-pdecv df Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: tview integer, intent(in) :: iview integer, intent(in) :: nnz integer, intent(in) :: ntet Contents Common Blocks bcef vth a0ghp Common Blocks common /bcef/ Type Attributes Name Initial real :: ynz real :: ynpopq common /vth/ Type Attributes Name Initial real :: vthc (length) real :: poloidn (length) common /a0ghp/ Type Attributes Name Initial real :: vlf real :: vrt real :: dflf real :: dfrt","tags":"","loc":"proc\\view.html"},{"title":"find_achieved_radial_points – FRTS project","text":"public  subroutine find_achieved_radial_points(nvpt) Uses rt_parameters find achieved radial points jbeg-jend Arguments Type Intent Optional Attributes Name integer, intent(in) :: nvpt Contents","tags":"","loc":"proc\\find_achieved_radial_points.html"},{"title":"dfind – FRTS project","text":"public  subroutine dfind(j, i, v, powpr, pil, pic, pia, df, decv, refr, vlf, vrt, ifast) Uses plasma constants rt_parameters pchgl=powpr*(1.d0-dexp(-2d0*pil))\n   pchgc=powpr*dexp(-2d0*pil)*dabs(-2d0*pic)\n   pchga=powpr*dexp(-2d0*pil)*dabs(-2d0*pia) !        adde=zze (dd/dens(j)) weight\n!        e2perp(i,j)=e2perp(i,j)+adde Arguments Type Intent Optional Attributes Name integer :: j integer :: i real :: v real :: powpr real :: pil real :: pic real :: pia real :: df real :: decv real :: refr real :: vlf real :: vrt integer :: ifast Contents","tags":"","loc":"proc\\dfind.html"},{"title":"fokkerplanck_compute – FRTS project","text":"public  subroutine fokkerplanck_compute(time, TAU) Uses writer_module maxwell Utils FokkerPlanck1D_mod rt_parameters plasma Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: time real(kind=wp), intent(in) :: TAU Contents Common Blocks dddql Common Blocks common /dddql/ Type Attributes Name Initial real(kind=wp) :: d0 integer :: jindex integer :: kindex","tags":"","loc":"proc\\fokkerplanck_compute.html"},{"title":"init_diffusion – FRTS project","text":"public  subroutine init_diffusion(h, n, vj, dj, d1, d2, d3) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: h integer, intent(in) :: n real(kind=wp), intent(in), dimension(:) :: vj real(kind=wp), intent(in), dimension(:) :: dj real(kind=wp), intent(out), dimension(:) :: d1 real(kind=wp), intent(out), dimension(:) :: d2 real(kind=wp), intent(out), dimension(:) :: d3 Contents","tags":"","loc":"proc\\init_diffusion.html"},{"title":"iteration_result_print – FRTS project","text":"public  subroutine iteration_result_print(this) Arguments Type Intent Optional Attributes Name class( IterationResult ), intent(in) :: this Contents","tags":"","loc":"proc\\iteration_result_print.html"},{"title":"iteration_result_save – FRTS project","text":"public  subroutine iteration_result_save(this, time_stamp) save Iteration Result to file Arguments Type Intent Optional Attributes Name class( IterationResult ), intent(in) :: this real(kind=wp), intent(in) :: time_stamp Contents","tags":"","loc":"proc\\iteration_result_save.html"},{"title":"init_iteration – FRTS project","text":"public  subroutine init_iteration() Uses plasma constants current rt_parameters Arguments None Contents None","tags":"","loc":"proc\\init_iteration.html"},{"title":"recalculate_f_for_a_new_mesh – FRTS project","text":"public  subroutine recalculate_f_for_a_new_mesh(ispectr) Uses maxwell rt_parameters plasma constants current recalculate f' for a new mesh\n!         if(vrj(i).gt.vvj(i0)) exit Arguments Type Intent Optional Attributes Name integer, intent(in) :: ispectr Contents","tags":"","loc":"proc\\recalculate_f_for_a_new_mesh.html"},{"title":"rini – FRTS project","text":"public  function rini(xm, tet, xnr, point, hr, ifail) Uses constants rt_parameters spectrum_mod xm=yn dsqrt(g22)         !given yn=(N jpol) at Nfi=0\nyn3=yn*dsqrt(g33)       !if given Nfi at Nteta=0 Arguments Type Intent Optional Attributes Name real(kind=wp) :: xm real(kind=wp) :: tet real(kind=wp) :: xnr type( spectrum_point ) :: point real(kind=wp) :: hr integer :: ifail Return Value real(kind=wp) Contents Common Blocks bcef metrika Common Blocks common /bcef/ Type Attributes Name Initial real(kind=wp) :: ynz real(kind=wp) :: ynpopq common /metrika/ Type Attributes Name Initial real(kind=wp) :: g11 real(kind=wp) :: g12 real(kind=wp) :: g22 real(kind=wp) :: g33 real(kind=wp) :: gg real(kind=wp) :: g real(kind=wp) :: si real(kind=wp) :: co","tags":"","loc":"proc\\rini.html"},{"title":"manager – FRTS project","text":"public  subroutine manager(iterat, iw0, ntet, spectr) Uses trajectory rt_parameters plasma spectrum_mod iterator_mod constants Arguments Type Intent Optional Attributes Name integer :: iterat integer :: iw0 integer :: ntet type( spectrum ) :: spectr Contents Common Blocks abc abcd abcde abcdg acg aef2 ag Common Blocks common /abc/ Type Attributes Name Initial real(kind=wp) :: rzz real(kind=wp) :: tetzz real(kind=wp) :: xmzz integer :: iznzz integer :: iwzz integer :: irszz common /abcd/ Type Attributes Name Initial integer :: irs common /abcde/ Type Attributes Name Initial integer :: izn common /abcdg/ Type Attributes Name Initial integer :: iabsorp common /acg/ Type Attributes Name Initial real(kind=wp) :: pow common /aef2/ Type Attributes Name Initial integer :: icall1 integer :: icall2 common /ag/ Type Attributes Name Initial integer :: inak integer :: lenstor integer :: lfree","tags":"","loc":"proc\\manager.html"},{"title":"kind_module – FRTS project","text":"Uses iso_fortran_env Contents Variables wp Variables Type Visibility Attributes Name Initial integer, public, parameter :: wp = real64 double precision reals","tags":"","loc":"module\\kind_module.html"},{"title":"approximation – FRTS project","text":"polinomial approximation\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses kind_module Contents Functions polin polin1 polin2 fdf fdfddf Subroutines approx ludcmp lubksb Functions public  function polin (k, x) Arguments Type Intent Optional Attributes Name integer :: k real(kind=wp) :: x Return Value real(kind=wp) public  function polin1 (k, x) Arguments Type Intent Optional Attributes Name integer :: k real(kind=wp) :: x Return Value real(kind=wp) public  function polin2 (k, x) Arguments Type Intent Optional Attributes Name integer :: k real(kind=wp) :: x Return Value real(kind=wp) public  function fdf (x, c, n, df) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x real(kind=wp) :: c (n) integer :: n real(kind=wp) :: df Return Value real(kind=wp) public  function fdfddf (x, c, n, df, ddf) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x real(kind=wp) :: c (n) integer :: n real(kind=wp) :: df real(kind=wp) :: ddf Return Value real(kind=wp) Subroutines public  subroutine approx (x, y, n, f, m, b) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x (n) real(kind=wp) :: y (n) integer :: n real :: f integer :: m real(kind=wp) :: b (*) public  subroutine ludcmp (a, n, np, indx, d) Arguments Type Intent Optional Attributes Name real(kind=wp) :: a (np,np) integer :: n integer :: np real(kind=wp) :: indx (n) real :: d public  subroutine lubksb (a, n, np, indx, b) Arguments Type Intent Optional Attributes Name real(kind=wp) :: a (np,np) integer :: n integer :: np real(kind=wp) :: indx (n) real(kind=wp) :: b (n)","tags":"","loc":"module\\approximation.html"},{"title":"chang_cooper_module – FRTS project","text":"Uses kind_module Contents Subroutines chang_cooper_solver chang_cooper_abcoef Subroutines public  subroutine chang_cooper_solver (alfa2, nt, h, dt, n, ybeg, yend, d1, d2, d3, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: alfa2 integer, intent(in) :: nt real(kind=wp), intent(in) :: h real(kind=wp), intent(in) :: dt integer, intent(in) :: n real(kind=wp), intent(in) :: ybeg real(kind=wp), intent(in) :: yend real(kind=wp), intent(in) :: d1 (n+1) real(kind=wp), intent(in) :: d2 (n+1) real(kind=wp), intent(in) :: d3 (n+1) real(kind=wp), intent(inout) :: y (n+2) public  subroutine chang_cooper_abcoef (alfa2, a, b, c, f, y, dt, n, ybeg, yend, xx, h, df) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: alfa2 real(kind=wp), intent(inout) :: a (n) real(kind=wp), intent(inout) :: b (n) real(kind=wp), intent(inout) :: c (n) real(kind=wp), intent(inout) :: f (n) real(kind=wp), intent(inout) :: y (n+2) real(kind=wp), intent(in) :: dt integer, intent(in) :: n real(kind=wp), intent(in) :: ybeg real(kind=wp), intent(in) :: yend real(kind=wp), intent(in) :: xx (n+1) real(kind=wp), intent(in) :: h real(kind=wp), intent(in) :: df (n+1)","tags":"","loc":"module\\chang_cooper_module.html"},{"title":"chebyshev – FRTS project","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses kind_module Contents Functions chebev Subroutines chebft1 chder Functions public  function chebev (a, b, c, m, x) Arguments Type Intent Optional Attributes Name real(kind=wp) :: a real(kind=wp) :: b real(kind=wp) :: c (m) integer :: m real(kind=wp) :: x Return Value real(kind=wp) Subroutines public  subroutine chebft1 (a, b, c, n, func) Arguments Type Intent Optional Attributes Name real(kind=wp) :: a real(kind=wp) :: b real(kind=wp) :: c (n) integer :: n real(kind=wp) :: func public  subroutine chder (a, b, c, cder, n) Arguments Type Intent Optional Attributes Name real(kind=wp) :: a real(kind=wp) :: b real(kind=wp) :: c (n) real(kind=wp) :: cder (n) integer :: n","tags":"","loc":"module\\chebyshev.html"},{"title":"constants – FRTS project","text":"модуль с математическими и физическими константами Uses kind_module Contents Variables zero one two one_third tiny tin pi pi2 pi4 piq talfa zalfa xmalfa clt pme pme_e pqe xlog c0 c1 xsgs xwtt cnst1 cnst2 Subroutines show_constants Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: zero = 0.0_wp real(kind=wp), public, parameter :: one = 1.0_wp real(kind=wp), public, parameter :: two = 2.0_wp real(kind=wp), public, parameter :: one_third = 1.0_wp/3.0_wp real(kind=wp), public, parameter :: tiny = 1.e-100_wp real(kind=wp), public, parameter :: tin = 1e-7_wp real(kind=wp), public, parameter :: pi = acos(-one) число Пи = 3.1415.... real(kind=wp), public, parameter :: pi2 = 2.0_wp*pi real(kind=wp), public, parameter :: pi4 = 4.0_wp*pi real(kind=wp), public, parameter :: piq = sqrt(pi) real(kind=wp), public, parameter :: talfa = 3.5_wp alpha particles' birth energy, MeV real(kind=wp), public, parameter :: zalfa = 2.0_wp alpha particles' electrical charge real(kind=wp), public, parameter :: xmalfa = 4.0_wp alpha particles' atomic mass real(kind=wp), public, parameter :: clt = 3.0e+10_wp скорость света real(kind=wp), public, parameter :: pme = 9.11e-28_wp real(kind=wp), public, parameter :: pme_e = 9.11e-28 real(kind=wp), public, parameter :: pqe = 4.803e-10_wp real(kind=wp), public, parameter :: xlog = 16.0_wp+dlog(16.0_wp) real(kind=wp), public, parameter :: c0 = sqrt(pi4*pqe**2/pme) real(kind=wp), public, parameter :: c1 = pqe/pme/clt real(kind=wp), public, parameter :: xsgs = 1e+13_wp real(kind=wp), public, parameter :: xwtt = 1e-7_wp real(kind=wp), public, parameter :: cnst1 = 0.2965924106e-6_wp cnst1=(m_e/m_p)**2, CGS real(kind=wp), public, parameter :: cnst2 = 0.359680922e-35_wp cnst2=(m_e/e)**2,  CGS Subroutines public  subroutine show_constants () Arguments None","tags":"","loc":"module\\constants.html"},{"title":"rt_parameters – FRTS project","text":"Uses kind_module Contents Variables freq xmi1 zi1 xmi2 zi2 dni2 xmi3 zi3 dni3 itend0 energy factor dra kv nr hmin1 rrange eps hdrob cleft cright cdel rbord pchm pabs0 pgiter ni1 ni2 niterat nmaxm maxstep2 maxstep4 ipri iw ismth ismthalf ismthout inew itor i_pol zplus zminus ntet nnz spectrum_type Subroutines show_parameters read_parameters Variables Type Visibility Attributes Name Initial real(kind=wp), public :: freq Freq,     RF frequency, GHz real(kind=wp), public :: xmi1 Mi1/Mp,  relative mass of ions 1 real(kind=wp), public :: zi1 charge of ions 1 real(kind=wp), public :: xmi2 Mi2/Mp,  relative mass of ions 2 real(kind=wp), public :: zi2 charge of ions 2 real(kind=wp), public :: dni2 0.03   Ni2/Ni1, relative density of ions 2 real(kind=wp), public :: xmi3 Mi3/Mp,  relative mass of ions 3 real(kind=wp), public :: zi3 charge of ions 3 real(kind=wp), public :: dni3 Ni3/Ni1, relative density of ions 3 !!!!!!!!!!!  parameters for alphas calculations !!! integer, public :: itend0 itend0,   if = 0, no alphas real(kind=wp), public :: energy energy,   max. perp. energy of alphas (MeV) real(kind=wp), public :: factor factor,   factor in alpha source real(kind=wp), public :: dra dra,      relative alpha source broadening (dr/a) integer, public :: kv kv,       V_perp  greed number !!!!!!!!!!! numerical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!! integer, public :: nr nr,  radial grid number  <= 505 real(kind=wp), public :: hmin1 hmin1, rel.(hr) min. step in the Fast comp. mode, <1.d0 real(kind=wp), public :: rrange rrange,   rel.(hr) size of a 'turning' point region, <1.d0 real(kind=wp), public :: eps eps,      accuracy real(kind=wp), public :: hdrob hdrob,    h4 correction, real(kind=wp), public :: cleft cleft,    left Vz plato border shift (<1) real(kind=wp), public :: cright cright,   right Vz plato border shift (>1) real(kind=wp), public :: cdel cdel,     (left part)/(Vz plato size) real(kind=wp), public :: rbord rbord,    relative radius of reflection, <1. real(kind=wp), public :: pchm pchm,     threshold between 'strong' and weak' absorption, <1. real(kind=wp), public :: pabs0 pabs,     part of remaining power interp. as absorption real(kind=wp), public :: pgiter pgiter,   relative accuracy to stop iterations integer, public :: ni1 ni1,      grid number in the left part of Vz plato integer, public :: ni2 ni2,      grid number in the right part of Vz plato integer, public :: niterat niterat,  maximal number of iterations integer, public :: nmaxm (4) nmaxm(1), permitted reflections at 0 iteration\nnmaxm(2), permitted reflections at 1 iteration\nnmaxm(3), permitted reflections at 2 iteration\nnmaxm(4), permitted reflections at 3 iteration integer, public :: maxstep2 maxstep2, maximal steps' number in Fast comp. mode integer, public :: maxstep4 maxstep4, maximal steps' number in Slow comp. mode !!!!!!!!!!!  options !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! integer, public :: ipri ipri, printing output monitoring: 0,1,2,3,4 integer, public :: iw iw, initial mode (slow=1, fast=-1) integer, public :: ismth ismth, if=0, no smoothing in Ne(rho),Te(rho),Ti(rho) integer, public :: ismthalf ismthalf,  if=0, no smoothing in D_alpha(vperp) integer, public :: ismthout ismthout,  if=0, no smoothing in output profiles integer, public :: inew inew=0 for usual tokamak&Ntor_grill; 1 or 2 for g' in ST&Npol_grill integer, public :: itor itor,      +-1, Btor direction in right coord{drho,dteta,dfi} integer, public :: i_pol ipol,      +-1, Bpol direction in right coord{drho,dteta,dfi} !!!!!!!!!!!  grill parameters and input LH spectrum !!!!!!!!!!!! real(kind=wp), public :: zplus Zplus,    upper grill corner in centimeters real(kind=wp), public :: zminus Zminus,   lower grill corner in centimeters integer, public :: ntet ntet,     theta grid number integer, public :: nnz nnz,      N_phi grid number integer, public :: spectrum_type spectrum type 1 - 1D, 2 = 2D, 3, scatter Subroutines public  subroutine show_parameters () Arguments None public  subroutine read_parameters (file_name) !!!!!!!!!!!  read  physical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read parameters for alphas calculation !!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read  numerical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read  options !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read grill parameters and input LH spectrum !!!!!!!!!!!!\n!!!!!!!!!!! checking initial parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name character :: file_name","tags":"","loc":"module\\rt_parameters.html"},{"title":"savelyev_solver_module – FRTS project","text":"!!!!! -- fill abc matrix\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses kind_module Contents Functions rplusk rplusk2 rmink rmink2 rs qf k2 kinv kinv2 Subroutines savelyev_solver savelyev_abccoef tridag Functions public  function rplusk (x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x real(kind=wp) :: dif real(kind=wp) :: alfa2 Return Value real(kind=wp) public  function rplusk2 (x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x real(kind=wp) :: dif real(kind=wp) :: alfa2 Return Value real(kind=wp) public  function rmink (x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x real(kind=wp) :: dif real(kind=wp) :: alfa2 Return Value real(kind=wp) public  function rmink2 (x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x real(kind=wp) :: dif real(kind=wp) :: alfa2 Return Value real(kind=wp) public  function rs (x, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x real(kind=wp) :: alfa2 Return Value real(kind=wp) public  function qf (x) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x Return Value real(kind=wp) public  function k2 (x, dif) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x real(kind=wp) :: dif Return Value real(kind=wp) public  function kinv (x, dif) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x real(kind=wp) :: dif Return Value real(kind=wp) public  function kinv2 (x, dif) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x real(kind=wp) :: dif Return Value real(kind=wp) Subroutines public  subroutine savelyev_solver (alfa2, nt, h, dt, n, ybeg, yend, d1, d2, d3, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: alfa2 integer, intent(in) :: nt real(kind=wp), intent(in) :: h real(kind=wp), intent(in) :: dt integer, intent(in) :: n real(kind=wp), intent(in) :: ybeg real(kind=wp), intent(in) :: yend real(kind=wp), intent(in) :: d1 (n+1) real(kind=wp), intent(in) :: d2 (n+1) real(kind=wp), intent(in) :: d3 (n+1) real(kind=wp), intent(inout) :: y (n) public  subroutine savelyev_abccoef (alfa2, a, b, c, f, y, dt, n, ybeg, yend, xx, h, d1, d2, d3) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: alfa2 real(kind=wp), intent(inout) :: a (n) real(kind=wp), intent(inout) :: b (n) real(kind=wp), intent(inout) :: c (n) real(kind=wp), intent(inout) :: f (n) real(kind=wp), intent(inout) :: y (n) real(kind=wp), intent(in) :: dt integer, intent(in) :: n real(kind=wp), intent(in) :: ybeg real(kind=wp), intent(in) :: yend real(kind=wp), intent(in) :: xx (n+1) real(kind=wp), intent(in) :: h real(kind=wp), intent(in) :: d1 (n+1) real(kind=wp), intent(in) :: d2 (n+1) real(kind=wp), intent(in) :: d3 (n+1) public  subroutine tridag (a, b, c, r, u, n) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (n) real(kind=wp), intent(in) :: b (n) real(kind=wp), intent(in) :: c (n) real(kind=wp), intent(in) :: r (n) real(kind=wp), intent(inout) :: u (n) integer, intent(in) :: n","tags":"","loc":"module\\savelyev_solver_module.html"},{"title":"spline – FRTS project","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses kind_module Contents Subroutines splne splnt dsplnt Subroutines public  subroutine splne (x, y, n, y2) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x (n) real(kind=wp) :: y (n) integer :: n real(kind=wp) :: y2 (n) public  subroutine splnt (xa, ya, y2a, n, x, y, dy) Arguments Type Intent Optional Attributes Name real(kind=wp) :: xa (n) real(kind=wp) :: ya (n) real(kind=wp) :: y2a (n) integer :: n real(kind=wp) :: x real(kind=wp) :: y real(kind=wp) :: dy public  subroutine dsplnt (xa, ya, y2a, n, x, y, dy, ddy) Arguments Type Intent Optional Attributes Name real(kind=wp) :: xa (n) real(kind=wp) :: ya (n) real(kind=wp) :: y2a (n) integer :: n real(kind=wp) :: x real(kind=wp) :: y real(kind=wp) :: dy real(kind=wp) :: ddy","tags":"","loc":"module\\spline.html"},{"title":"Utils – FRTS project","text":"Uses kind_module Contents Functions sys_time Functions public  function sys_time () Arguments None Return Value real(kind=wp)","tags":"","loc":"module\\utils.html"},{"title":"writer_module – FRTS project","text":"Uses kind_module Contents Subroutines write_v_array write_x_array write_matrix write_array write_distribution Subroutines public  subroutine write_v_array (v, a, time, array_name) сохраняет массивы расределения и скорости Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: v (:,:) real(kind=wp), intent(in) :: a (:,:,:) real(kind=wp), intent(in) :: time character(len=*), intent(in) :: array_name public  subroutine write_x_array (x, arr, time, array_name) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:,:) real(kind=wp), intent(in) :: arr (:,:) real(kind=wp), intent(in) :: time character(len=*), intent(in) :: array_name public  subroutine write_matrix (arr, time, array_name) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: arr (:,:) real(kind=wp), intent(in) :: time character(len=*), intent(in) :: array_name public  subroutine write_array (arr, N, array_name) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: arr (*) integer, intent(in) :: N character(len=*), intent(in) :: array_name public  subroutine write_distribution (arr, N, time) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: arr (*) integer, intent(in) :: N real(kind=wp), intent(in) :: time","tags":"","loc":"module\\writer_module.html"},{"title":"FokkerPlanck1D_mod – FRTS project","text":"Uses iso_fortran_env savelyev_solver_module Contents Interfaces FokkerPlanck1D Derived Types FokkerPlanck1D Functions FokkerPlanck1D_constructor Subroutines FokkerPlanck1D_print FokkerPlanck1D_init_zero_diffusion FokkerPlanck1D_init_diffusion FokkerPlanck1D_solve_time_step burying_procedure Interfaces public        interface FokkerPlanck1D public  function FokkerPlanck1D_constructor (e, v_lim, v, f) result(this) Arguments Type Intent Optional Attributes Name real(kind=dp), value :: e real(kind=dp), value :: v_lim real(kind=dp), value :: v (:) real(kind=dp), value :: f (:) Return Value type( FokkerPlanck1D ) Derived Types type, public :: FokkerPlanck1D Components Type Visibility Attributes Name Initial real(kind=dp), public :: enorm = 0 real(kind=dp), public :: v_lim = 0 real(kind=dp), public, allocatable :: v (:) real(kind=dp), public, allocatable :: f (:) integer, public :: i0 = 0 real(kind=dp), public :: alfa2 = 0 integer, public :: n = 0 real(kind=dp), public :: h = 0 real(kind=dp), public, allocatable :: d1 (:) real(kind=dp), public, allocatable :: d2 (:) real(kind=dp), public, allocatable :: d3 (:) Constructor public\n\n                    \n                    function FokkerPlanck1D_constructor (e, v_lim, v, f) Type-Bound Procedures procedure\n                    ,                  public\n                  :: print => FokkerPlanck1D_print Subroutine procedure\n                    ,                  public\n                  :: solve_time_step => FokkerPlanck1D_solve_time_step Subroutine procedure\n                    ,                  public\n                  :: init_zero_diffusion => FokkerPlanck1D_init_zero_diffusion Subroutine procedure\n                    ,                  public\n                  :: init_diffusion => FokkerPlanck1D_init_diffusion Subroutine Functions public  function FokkerPlanck1D_constructor (e, v_lim, v, f) result(this) Arguments Type Intent Optional Attributes Name real(kind=dp), value :: e real(kind=dp), value :: v_lim real(kind=dp), value :: v (:) real(kind=dp), value :: f (:) Return Value type( FokkerPlanck1D ) Subroutines public  subroutine FokkerPlanck1D_print (this) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(in) :: this public  subroutine FokkerPlanck1D_init_zero_diffusion (this) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this public  subroutine FokkerPlanck1D_init_diffusion (this, dif) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this real(kind=dp), intent(in), dimension(:) :: dif public  subroutine FokkerPlanck1D_solve_time_step (this, dt, nt) !!!!!!!!!!   solve problem   !!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this real(kind=dp), intent(in) :: dt integer, intent(in) :: nt public  subroutine burying_procedure (v, f0, df0) write( , )'#1 j,k,ibeg=',j,k,ibeg\nwrite( , )'#1 v(ibeg)=',vj(ibeg),' f1/f2=',fout1/fout2 Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v (:) real(kind=8), intent(inout) :: f0 (:) real(kind=8), intent(inout), optional :: df0 (:)","tags":"","loc":"module\\fokkerplanck1d_mod.html"},{"title":"maxwell – FRTS project","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses constants kind_module Contents Variables i0 vij fij0 fij dfij dij Functions funmaxwell fmaxw_classic fmaxw_ext fmaxw psiq erfcc Subroutines init_vi init_fmaxw_classic init_fmaxw_ext Variables Type Visibility Attributes Name Initial integer, public, parameter :: i0 = 1002 real(kind=wp), public :: vij (i0,100) real(kind=wp), public :: fij0 (i0,100,2) real(kind=wp), public :: fij (i0,100,2) real(kind=wp), public :: dfij (i0,100,2) real(kind=wp), public :: dij (i0,100,2) Functions public  function funmaxwell (v, dfunmaxwell) Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: dfunmaxwell Return Value doubleprecision public  function fmaxw_classic (v, alfa2, dfmaxw) Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: alfa2 real(kind=wp) :: dfmaxw Return Value doubleprecision public  function fmaxw_ext (v, alfa2, dfmaxw) Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: alfa2 real(kind=wp) :: dfmaxw Return Value doubleprecision public  function fmaxw (v, alfa2, dfmaxw) Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: alfa2 real(kind=wp) :: dfmaxw Return Value doubleprecision public  function psiq (v, alfa2) ! psiq=exp(ksiV 2) erfcc(ksiV) exp(-0.25/alfa2) Arguments Type Intent Optional Attributes Name double precision :: v double precision :: alfa2 Return Value doubleprecision public  function erfcc (x) Arguments Type Intent Optional Attributes Name double precision :: x Return Value double precision Subroutines public  subroutine init_vi (vclt, vi) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vclt real(kind=wp), intent(out) :: vi (i0) public  subroutine init_fmaxw_classic (vclt, enorm, fi, dfi) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vclt real(kind=wp), intent(in) :: enorm real(kind=wp), intent(out) :: fi (i0) real(kind=wp), intent(out) :: dfi (i0) public  subroutine init_fmaxw_ext (vclt, enorm, fi, dfi) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vclt real(kind=wp), intent(in) :: enorm real(kind=wp), intent(out) :: fi (i0) real(kind=wp), intent(out) :: dfi (i0)","tags":"","loc":"module\\maxwell.html"},{"title":"plasma – FRTS project","text":"Uses kind_module Contents Variables ngrid nspl tcur rm b_tor0 b_tor r0 z0 rh1 con tem temi zeff afld rh rha drhodr delta ell gamm amy tet1 tet2 xmi cnye cnyi xsz vt0 cnstvc ww cltn vperp cnstal zza zze valfa vpmax vk sk ipsy ncoef cdl cly cgm cmy coeffs y2dn y2tm y2tmi y2zeff ncheb chebne chebdne chebddne enorm fst Functions fn fvt fn1 fn2 ft fti zefff obeom ploshad gaussint Subroutines init_plasma init_parameters find_volums_and_surfaces calc_enorm init_maxwell Variables Type Visibility Attributes Name Initial integer, public :: ngrid ASTRA radial grid number integer, public :: nspl ASTRA radial grid number real(kind=wp), public :: tcur время (придумать название для переменной получше) real(kind=wp), public :: rm minor radius in mid-plane, cm real(kind=wp), public :: b_tor0 временно нужно две переменных, тоже нужно исправить real(kind=wp), public :: b_tor временно нужно две переменных, тоже нужно исправить real(kind=wp), public :: r0 real(kind=wp), public :: z0 real(kind=wp), public :: rh1 real(kind=wp), public, dimension(:), allocatable :: con real(kind=wp), public, dimension(:), allocatable :: tem real(kind=wp), public, dimension(:), allocatable :: temi real(kind=wp), public, dimension(:), allocatable :: zeff real(kind=wp), public, dimension(:), allocatable :: afld real(kind=wp), public, dimension(:), allocatable :: rh real(kind=wp), public, dimension(:), allocatable :: rha real(kind=wp), public, dimension(:), allocatable :: drhodr real(kind=wp), public, dimension(:), allocatable :: delta real(kind=wp), public, dimension(:), allocatable :: ell real(kind=wp), public, dimension(:), allocatable :: gamm real(kind=wp), public, dimension(:), allocatable :: amy real(kind=wp), public :: tet1 бывший common /a0a2/ real(kind=wp), public :: tet2 бывший common /a0a2/ real(kind=wp), public :: xmi real(kind=wp), public :: cnye real(kind=wp), public :: cnyi real(kind=wp), public :: xsz real(kind=wp), public :: vt0 real(kind=wp), public :: cnstvc real(kind=wp), public :: ww real(kind=wp), public :: cltn real(kind=wp), public :: vperp (50,100) real(kind=wp), public :: cnstal real(kind=wp), public :: zza real(kind=wp), public :: zze real(kind=wp), public :: valfa real(kind=wp), public :: vpmax real(kind=wp), public :: vk (100) real(kind=wp), public :: sk (100) integer, public, parameter :: ipsy = 5 ipsy = number of polinomial decomposition coefficients\nused for interpolation of Zakharov's moments. integer, public, parameter :: ncoef = 5 ipsy = number of polinomial decomposition coefficients\nused for interpolation of Zakharov's moments. real(kind=wp), public, dimension(ipsy) :: cdl real(kind=wp), public, dimension(ipsy) :: cly real(kind=wp), public, dimension(ipsy) :: cgm real(kind=wp), public, dimension(ipsy) :: cmy real(kind=wp), public, dimension(ipsy) :: coeffs real(kind=wp), public :: y2dn (501) бывший common /a0l3/ real(kind=wp), public :: y2tm (501) бывший common /a0l3/ real(kind=wp), public :: y2tmi (501) бывший common /a0l3/ real(kind=wp), public :: y2zeff (501) бывший common /a0l5/ integer, public :: ncheb real(kind=wp), public :: chebne (50) бывший common/ne_cheb real(kind=wp), public :: chebdne (50) бывший common/ne_cheb real(kind=wp), public :: chebddne (50) бывший common/ne_cheb real(kind=wp), public :: enorm (100) em поле и еще что-то real(kind=wp), public :: fst (100) em поле и еще что-то Functions public  function fn (x) plasma  density,  cm&#94;-3 Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) public  function fvt (r) нет описания Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: r Return Value real(kind=wp) public  function fn1 (x, fnp) plasma density and its derivative Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(out) :: fnp Return Value real(kind=wp) public  function fn2 (r, fnp, fnpp) plasma density and its first and second derivatives Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: r real(kind=wp), intent(out) :: fnp real(kind=wp), intent(out) :: fnpp Return Value real(kind=wp) public  function ft (x) electron temperature, erg\n     ft=y            ! kev Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) public  function fti (x) ion temperature, kev Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) public  function zefff (x) z_effective profile Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) public  function obeom (ptet, pa) Arguments Type Intent Optional Attributes Name real :: ptet real :: pa Return Value real(kind=wp) public  function ploshad (ptet, pa) Arguments Type Intent Optional Attributes Name real :: ptet real :: pa Return Value real(kind=wp) public  function gaussint (f, a, b, r, eps) что-то про гаусс Arguments Type Intent Optional Attributes Name real(kind=wp) :: f real(kind=wp) :: a real(kind=wp) :: b real(kind=wp) :: r real(kind=wp) :: eps Return Value real(kind=wp) Subroutines public  subroutine init_plasma (NA1, ABC, BTOR, RTOR, UPDWN, GP2, AMETR, RHO, SHIF, ELON, TRIA, MU, NE, TE, TI, ZEF, UPL) variant\n amy=(btor/q) rho (drho/dr) is a function of \"minor radius\" r=rh(i).\n Poloidal magnetic field: B_pol=amy(r)*sqrt(g22/g), where g is\n determinant of 3D metric tensor and g22 is the (22) element of\n the tensor, normalized on ABC&#94;4 and ABC&#94;2, correspondingly. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: NA1 real(kind=wp), intent(in) :: ABC real(kind=wp), intent(in) :: BTOR real(kind=wp), intent(in) :: RTOR real(kind=wp), intent(in) :: UPDWN real(kind=wp), intent(in) :: GP2 real(kind=wp), dimension(*) :: AMETR real(kind=wp), dimension(*) :: RHO real(kind=wp), dimension(*) :: SHIF real(kind=wp), dimension(*) :: ELON real(kind=wp), dimension(*) :: TRIA real(kind=wp), dimension(*) :: MU real(kind=wp), dimension(*) :: NE real(kind=wp), dimension(*) :: TE real(kind=wp), dimension(*) :: TI real(kind=wp), dimension(*) :: ZEF real(kind=wp), dimension(*) :: UPL public  subroutine init_parameters () !!!!!!      ptkev=ft(zero)/0.16d-8  !Te in keV\n      ccurnr=pqe pqe 0.333d-9/pme Arguments None public  subroutine find_volums_and_surfaces () Arguments None public  subroutine calc_enorm () fst(j)=pn xlogj c0 4/pi4/vt 3 Arguments None public  subroutine init_maxwell () Arguments None","tags":"","loc":"module\\plasma.html"},{"title":"spectrum_mod – FRTS project","text":"Uses kind_module Contents Interfaces spectrum Derived Types spectrum_point spectrum Functions spectrum_constructor get_positive_part_method get_negative_part_method read_spectrum make_spline_approximation Subroutines calc_max_power_method divide_spectrum Interfaces public        interface spectrum public  function spectrum_constructor (size) result(this) Arguments Type Intent Optional Attributes Name integer, value :: size Return Value type( spectrum ) Derived Types type, public :: spectrum_point Components Type Visibility Attributes Name Initial real(kind=wp), public :: nz real(kind=wp), public :: ny real(kind=wp), public :: Ntor Ntau=-Ntor real(kind=wp), public :: Npol Ntet=Npol real(kind=wp), public :: power power type, public :: spectrum Components Type Visibility Attributes Name Initial integer, public :: size size of spectrum real(kind=wp), public :: input_power power of spectrum real(kind=wp), public :: power_ratio доля входной мощности real(kind=wp), public :: max_power real(kind=wp), public :: sum_power суммарная power integer, public :: direction направление спектра   +1 или -1 или 0 - полный type( spectrum_point ), public, allocatable :: data (:) Constructor public\n\n                    \n                    function spectrum_constructor (size) Type-Bound Procedures procedure\n                    ,                  public\n                  :: get_positive_part => get_positive_part_method Function procedure\n                    ,                  public\n                  :: get_negative_part => get_negative_part_method Function procedure\n                    ,                  public\n                  :: calc_max_power => calc_max_power_method Subroutine Functions public  function spectrum_constructor (size) result(this) Arguments Type Intent Optional Attributes Name integer, value :: size Return Value type( spectrum ) public  function get_positive_part_method (this) result(spectr) Arguments Type Intent Optional Attributes Name class( spectrum ), intent(in) :: this Return Value type( spectrum ) public  function get_negative_part_method (this) result(spectr) Arguments Type Intent Optional Attributes Name class( spectrum ), intent(in) :: this Return Value type( spectrum ) public  function read_spectrum (file_name) result(spectr) Arguments Type Intent Optional Attributes Name character(len=*), value :: file_name Return Value type( spectrum ) public  function make_spline_approximation (spectr) result(appx_spectr) approximation of input LH spectrum Arguments Type Intent Optional Attributes Name type( spectrum ), intent(in) :: spectr Return Value type( spectrum ) Subroutines public  subroutine calc_max_power_method (this) Arguments Type Intent Optional Attributes Name class( spectrum ), intent(inout) :: this public  subroutine divide_spectrum (spectr, pos_spectr, neg_spectr) деление спектра на две части Arguments Type Intent Optional Attributes Name type( spectrum ), intent(in) :: spectr type( spectrum ), intent(out) :: pos_spectr type( spectrum ), intent(out) :: neg_spectr","tags":"","loc":"module\\spectrum_mod.html"},{"title":"spectrum1D – FRTS project","text":"Uses iso_fortran_env spectrum_mod Contents Variables full_spectrum pos_spectr neg_spectr ispl plaun ynzm0 pm0 ynzm pm pabs Functions create_spectrum Subroutines read_positive_spectrum read_negative_spectrum spectrum_approximation copy_to_spectrum_1D write_spectrum Variables Type Visibility Attributes Name Initial type( spectrum ), public :: full_spectrum type( spectrum ), public :: pos_spectr type( spectrum ), public :: neg_spectr integer, public :: ispl size of spectrum real(kind=wp), public :: plaun power of spectrum real(kind=wp), public :: ynzm0 (1001) real(kind=wp), public :: pm0 (1001) real(kind=wp), public :: ynzm (1001) бывший common /a0a1/ ynzm(1001),pm(1001) real(kind=wp), public :: pm (1001) бывший common /a0a1/ ynzm(1001),pm(1001) real(kind=wp), public :: pabs бывший common /a0gh/ pabs Functions public  function create_spectrum () result(spectr) Arguments None Return Value type( spectrum ) Subroutines public  subroutine read_positive_spectrum (file_name, p_in) Arguments Type Intent Optional Attributes Name character :: file_name real(kind=wp) :: p_in public  subroutine read_negative_spectrum (file_name, p_in) Arguments Type Intent Optional Attributes Name character :: file_name real(kind=wp) :: p_in public  subroutine spectrum_approximation (ispectr) approximation of input LH spectrum Arguments Type Intent Optional Attributes Name integer, intent(in) :: ispectr public  subroutine copy_to_spectrum_1D (spectr) Arguments Type Intent Optional Attributes Name type( spectrum ) :: spectr public  subroutine write_spectrum (ispectr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ispectr","tags":"","loc":"module\\spectrum1d.html"},{"title":"trajectory – FRTS project","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses kind_module Contents Variables length mpnt nrefj dland dcoll perpn dalf vel jrad iww tetai xnpar izz mbeg mend mbad rbeg tetbeg xnrbeg xmbeg yn3beg Subroutines view Variables Type Visibility Attributes Name Initial integer, public, parameter :: length = 5000000 integer, public, parameter :: mpnt = 10000 integer, public :: nrefj (mpnt) common/refl/nrefj(mpnt) real(kind=wp), public :: dland (length) real(kind=wp), public :: dcoll (length) real(kind=wp), public :: perpn (length) real(kind=wp), public :: dalf (length) real(kind=wp), public :: vel (length) real(kind=wp), public :: jrad (length) real(kind=wp), public :: iww (length) real(kind=wp), public :: tetai (length) real(kind=wp), public :: xnpar (length) бывший common/agh/xnpar,vel,dland,dcoll,dalf,perpn,tetai,jrad,iww,izz real(kind=wp), public :: izz (length) бывший common/agh/xnpar,vel,dland,dcoll,dalf,perpn,tetai,jrad,iww,izz real(kind=wp), public :: mbeg (mpnt) real(kind=wp), public :: mend (mpnt) real(kind=wp), public :: mbad (mpnt) real(kind=wp), public :: rbeg (mpnt) real(kind=wp), public :: tetbeg (mpnt) common/viewdat/mbeg,mend,mbad,rbeg,tetbeg,xnrbeg,xmbeg,yn3beg real(kind=wp), public :: xnrbeg (mpnt) common/viewdat/mbeg,mend,mbad,rbeg,tetbeg,xnrbeg,xmbeg,yn3beg real(kind=wp), public :: xmbeg (mpnt) common/viewdat/mbeg,mend,mbad,rbeg,tetbeg,xnrbeg,xmbeg,yn3beg real(kind=wp), public :: yn3beg (mpnt) common/viewdat/mbeg,mend,mbad,rbeg,tetbeg,xnrbeg,xmbeg,yn3beg Subroutines public  subroutine view (tview, iview, nnz, ntet) !writing trajectories into a file\n          pintld=-dland(i) (dflf+dfrt)/2d0\n          pdec1=-pdecv df Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: tview integer, intent(in) :: iview integer, intent(in) :: nnz integer, intent(in) :: ntet","tags":"","loc":"module\\trajectory.html"},{"title":"current – FRTS project","text":"Uses kind_module Contents Variables dql pdl vzmin vzmax fcoll dens eta dq1 dq2 pdc pda ppv1 ppv2 pdfast dqi0 dncount Subroutines find_achieved_radial_points dfind Variables Type Visibility Attributes Name Initial real(kind=wp), public :: dql (101,100) real(kind=wp), public :: pdl (100) real(kind=wp), public :: vzmin (100) real(kind=wp), public :: vzmax (100) real(kind=wp), public :: fcoll (100) real(kind=wp), public :: dens (100) real(kind=wp), public :: eta (100) real(kind=wp), public :: dq1 (101,100) real(kind=wp), public :: dq2 (101,100) real(kind=wp), public :: pdc (100) real(kind=wp), public :: pda (100) real(kind=wp), public :: ppv1 real(kind=wp), public :: ppv2 real(kind=wp), public :: pdfast (100) real(kind=wp), public :: dqi0 (50,100) real(kind=wp), public :: dncount (101,100) Subroutines public  subroutine find_achieved_radial_points (nvpt) find achieved radial points jbeg-jend Arguments Type Intent Optional Attributes Name integer, intent(in) :: nvpt public  subroutine dfind (j, i, v, powpr, pil, pic, pia, df, decv, refr, vlf, vrt, ifast) !        adde=zze (dd/dens(j)) weight\n!        e2perp(i,j)=e2perp(i,j)+adde Read more… Arguments Type Intent Optional Attributes Name integer :: j integer :: i real :: v real :: powpr real :: pil real :: pic real :: pia real :: df real :: decv real :: refr real :: vlf real :: vrt integer :: ifast","tags":"","loc":"module\\current.html"},{"title":"power – FRTS project","text":"Contents None","tags":"","loc":"module\\power.html"},{"title":"FluxSurface_mod – FRTS project","text":"все что связанно с магнитными поверхностями Uses kind_module Contents Derived Types FluxSurface Derived Types type, public :: FluxSurface класс магнитной поверхности Components Type Visibility Attributes Name Initial integer, public :: index номер магнитной поверхности real(kind=wp), public :: r радиус real(kind=wp), public :: vmax vmax=cltn/vto real(kind=wp), public :: vt наверно тепловая скорость электронов????? vt=fvt(r) integer, public :: ipt размер vgrid real(kind=wp), public, allocatable :: vgrid (:) real(kind=wp), public, allocatable :: vr_grid (:) бываший vrj real(kind=wp), public, allocatable :: diffusion (:) бывший dijk(i,j,k) или dj(i)","tags":"","loc":"module\\fluxsurface_mod.html"},{"title":"FokkerPlanck_module – FRTS project","text":"calculation of distribution functions at time t1=t+dtau !! Uses kind_module Contents Subroutines fokkerplanck_compute init_diffusion Subroutines public  subroutine fokkerplanck_compute (time, TAU) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: time real(kind=wp), intent(in) :: TAU public  subroutine init_diffusion (h, n, vj, dj, d1, d2, d3) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: h integer, intent(in) :: n real(kind=wp), intent(in), dimension(:) :: vj real(kind=wp), intent(in), dimension(:) :: dj real(kind=wp), intent(out), dimension(:) :: d1 real(kind=wp), intent(out), dimension(:) :: d2 real(kind=wp), intent(out), dimension(:) :: d3","tags":"","loc":"module\\fokkerplanck_module.html"},{"title":"iteration_result_mod – FRTS project","text":"Uses kind_module Contents Derived Types IterationResult Subroutines iteration_result_print iteration_result_save Derived Types type, public :: IterationResult Components Type Visibility Attributes Name Initial integer, public :: number iteration number 'iteration=',iterat integer, public :: spectr_direction 'ispectr=',ispectr real(kind=wp), public :: P_launched P_launched, MW=',plaun real(kind=wp), public :: P_landau 'P_landau, MW=',ol real(kind=wp), public :: P_coll 'P_coll, MW=',oc real(kind=wp), public :: P_alph 'P_alph, MW=',oa real(kind=wp), public :: alphas_power 'Alphas power, MW=',fuspow real(kind=wp), public :: P_fast real(kind=wp), public :: P_lost real(kind=wp), public :: P_not_accounted real(kind=wp), public :: P_landau_strong_absorption real(kind=wp), public :: P_landau_weak_absorption real(kind=wp), public :: P_turns real(kind=wp), public :: efficiency real(kind=wp), public :: avedens real(kind=wp), public :: r0 real(kind=wp), public :: eta_eff real(kind=wp), public :: residual невязка 'nevyazka=', pchg Type-Bound Procedures procedure\n                    ,                  public\n                  :: print => iteration_result_print Subroutine procedure\n                    ,                  public\n                  :: save => iteration_result_save Subroutine Subroutines public  subroutine iteration_result_print (this) Arguments Type Intent Optional Attributes Name class( IterationResult ), intent(in) :: this public  subroutine iteration_result_save (this, time_stamp) save Iteration Result to file Arguments Type Intent Optional Attributes Name class( IterationResult ), intent(in) :: this real(kind=wp), intent(in) :: time_stamp","tags":"","loc":"module\\iteration_result_mod.html"},{"title":"iterator_mod – FRTS project","text":"Uses kind_module Contents Variables vmid vz1 vz2 ibeg iend vrj dj djnew dj2 d2j vvj vdfj vgrid dfundv nvpt ipt1 ipt2 ipt kpt1 kpt3 iterat psum4 plost pnab Subroutines init_iteration recalculate_f_for_a_new_mesh Variables Type Visibility Attributes Name Initial real(kind=wp), public :: vmid (100) real(kind=wp), public :: vz1 (100) real(kind=wp), public :: vz2 (100) integer, public :: ibeg (100) integer, public :: iend (100) real(kind=wp), public :: vrj (101) real(kind=wp), public :: dj (101) real(kind=wp), public :: djnew (1001) real(kind=wp), public :: dj2 (101) real(kind=wp), public :: d2j (101) real(kind=wp), public, dimension(:), allocatable :: vvj real(kind=wp), public, dimension(:), allocatable :: vdfj real(kind=wp), public :: vgrid (101,100) common/gridv/vgrid(101,100),dfundv(101,100) real(kind=wp), public :: dfundv (101,100) common/gridv/vgrid(101,100),dfundv(101,100) integer, public :: nvpt common/gridv/nvpt integer, public :: ipt1 integer, public :: ipt2 integer, public :: ipt integer, public, parameter :: kpt1 = 20 integer, public, parameter :: kpt3 = 20 integer, public :: iterat real(kind=wp), public :: psum4 common /vvv2/ psum4 real(kind=wp), public :: plost common /a0a4/ plost,pnab real(kind=wp), public :: pnab common /a0a4/ plost,pnab Subroutines public  subroutine init_iteration () Arguments None public  subroutine recalculate_f_for_a_new_mesh (ispectr) recalculate f' for a new mesh\n!         if(vrj(i).gt.vvj(i0)) exit Arguments Type Intent Optional Attributes Name integer, intent(in) :: ispectr","tags":"","loc":"module\\iterator_mod.html"},{"title":"manager_mod – FRTS project","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses kind_module Contents Variables yn3 iroot ivar Functions rini Subroutines manager Variables Type Visibility Attributes Name Initial real(kind=wp), public :: yn3 common /abefo/ yn3 integer, public :: iroot common /beo/ iroot integer, public :: ivar common /bdeo/ ivar Functions public  function rini (xm, tet, xnr, point, hr, ifail) xm=yn dsqrt(g22)         !given yn=(N jpol) at Nfi=0\nyn3=yn*dsqrt(g33)       !if given Nfi at Nteta=0 Arguments Type Intent Optional Attributes Name real(kind=wp) :: xm real(kind=wp) :: tet real(kind=wp) :: xnr type( spectrum_point ) :: point real(kind=wp) :: hr integer :: ifail Return Value real(kind=wp) Subroutines public  subroutine manager (iterat, iw0, ntet, spectr) Arguments Type Intent Optional Attributes Name integer :: iterat integer :: iw0 integer :: ntet type( spectrum ) :: spectr","tags":"","loc":"module\\manager_mod.html"},{"title":"0_kind_module.f90 – FRTS project","text":"Contents Modules kind_module Source Code 0_kind_module.f90 Source Code !***************************************************************************************** !> author: Jacob Williams ! !  Define the numeric kinds. module kind_module use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none private !integer,parameter,public :: wp = real32     !! single precision reals integer , parameter , public :: wp = real64 !! double precision reals !integer,parameter,public :: wp = real128    !! quad precision reals end module kind_module !*****************************************************************************************","tags":"","loc":"sourcefile\\0_kind_module.f90.html"},{"title":"1_approximation.f90 – FRTS project","text":"Contents Modules approximation Source Code 1_approximation.f90 Source Code module approximation !! polinomial approximation use kind_module implicit none contains !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! real ( wp ) function polin ( k , x ) implicit none integer k real ( wp ) x polin = 1 d0 if ( k . gt . 1 ) polin = x ** ( k - 1 ) return end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! real ( wp ) function polin1 ( k , x ) implicit none integer k real ( wp ) x polin1 = x ** k return end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! real ( wp ) function polin2 ( k , x ) implicit none integer k real ( wp ) x polin2 = x ** ( k + 1 ) return end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine approx ( x , y , n , f , m , b ) ! !     y(i)=y(x(i))  the data to be approximated !     n             number of points in the input data !     m             number of coefficients of decomposition !                   over base functions \"f(k,x)\" : !                          y(x)=sum_1&#94;m [b(k)*f(k,x)] !     b(i)          found decomposition coefficients ! implicit real * 8 ( a - h , o - z ) integer , parameter :: np = 20 real ( wp ), parameter :: zero = 0.d0 real ( wp ) a ( np , np ), indx ( np ) real ( wp ) y ( n ), x ( n ), b ( * ) integer i , j , k , m , n if ( m . gt . np ) then write ( * , * ) 'index error subroutine \"approx\"' return end if do j = 1 , m do k = 1 , j a ( k , j ) = zero do i = 1 , n a ( k , j ) = a ( k , j ) + f ( j , x ( i )) * f ( k , x ( i )) end do end do end do do k = 2 , m do j = 1 , k - 1 a ( k , j ) = a ( j , k ) end do end do do k = 1 , m b ( k ) = zero do i = 1 , n b ( k ) = b ( k ) + y ( i ) * f ( k , x ( i )) end do end do call ludcmp ( a , m , np , indx , d ) call lubksb ( a , m , np , indx , b ) end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine ludcmp ( a , n , np , indx , d ) implicit real * 8 ( a - h , o - z ) integer , parameter :: nmax = 501 real ( wp ), parameter :: tiny = 1.d-20 , zero = 0.d0 real ( wp ) a ( np , np ), indx ( n ), vv ( nmax ) integer i , j , k , m , n , np , imax d = 1.d0 do i = 1 , n aamax = zero do j = 1 , n if ( dabs ( a ( i , j )). gt . aamax ) aamax = dabs ( a ( i , j )) end do if ( aamax . eq . zero ) pause 'singular matrix.' vv ( i ) = 1.d0 / aamax end do do j = 1 , n if ( j . gt . 1 ) then do i = 1 , j - 1 sum = a ( i , j ) if ( i . gt . 1 ) then do k = 1 , i - 1 sum = sum - a ( i , k ) * a ( k , j ) end do a ( i , j ) = sum endif end do endif aamax = zero do i = j , n sum = a ( i , j ) if ( j . gt . 1 ) then do k = 1 , j - 1 sum = sum - a ( i , k ) * a ( k , j ) end do a ( i , j ) = sum endif dum = vv ( i ) * dabs ( sum ) if ( dum . ge . aamax ) then imax = i aamax = dum endif end do if ( j . ne . imax ) then do k = 1 , n dum = a ( imax , k ) a ( imax , k ) = a ( j , k ) a ( j , k ) = dum end do d =- d vv ( imax ) = vv ( j ) endif indx ( j ) = imax if ( j . ne . n ) then if ( a ( j , j ). eq . zero ) a ( j , j ) = tiny dum = 1.d0 / a ( j , j ) do i = j + 1 , n a ( i , j ) = a ( i , j ) * dum end do endif end do if ( a ( n , n ). eq . zero ) a ( n , n ) = tiny return end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine lubksb ( a , n , np , indx , b ) implicit real * 8 ( a - h , o - z ) real ( wp ), parameter :: zero = 0.d0 real ( wp ) a ( np , np ), indx ( n ), b ( n ) integer i , j , ii , ll , n , np ii = 0 do i = 1 , n ll = indx ( i ) sum = b ( ll ) b ( ll ) = b ( i ) if ( ii . ne . 0 ) then do j = ii , i - 1 sum = sum - a ( i , j ) * b ( j ) end do else if ( sum . ne . zero ) then ii = i endif b ( i ) = sum end do do i = n , 1 , - 1 sum = b ( i ) if ( i . lt . n ) then do j = i + 1 , n sum = sum - a ( i , j ) * b ( j ) end do endif b ( i ) = sum / a ( i , i ) end do return end real ( wp ) function fdf ( x , c , n , df ) real ( wp ) x , c ( n ), df integer n , j real ( wp ) p , dp p = c ( n ) dp = 0.d0 do j = n - 1 , 1 , - 1 dp = dp * x + p p = p * x + c ( j ) end do fdf = p df = dp end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! real ( wp ) function fdfddf ( x , c , n , df , ddf ) real ( wp ) x , c ( n ), df , ddf integer n , j real ( wp ) p , dp , ddp p = c ( n ) dp = 0 d0 ddp = 0 d0 do j = n - 1 , 1 , - 1 ddp = ddp * x + 2 d0 * dp dp = dp * x + p p = p * x + c ( j ) end do fdfddf = p df = dp ddf = ddp end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! end module approximation","tags":"","loc":"sourcefile\\1_approximation.f90.html"},{"title":"1_chang_cooper_solver.f90 – FRTS project","text":"Contents Modules chang_cooper_module Source Code 1_chang_cooper_solver.f90 Source Code module chang_cooper_module use kind_module implicit none contains subroutine chang_cooper_solver ( alfa2 , nt , h , dt , n , ybeg , yend , d1 , d2 , d3 , y ) ! схема Ченга-Купера для уравнения Фоккера-Планка implicit none real ( wp ), intent ( in ) :: alfa2 integer , intent ( in ) :: nt , n real ( wp ), intent ( in ) :: h , dt real ( wp ), intent ( in ) :: ybeg , yend real ( wp ), intent ( in ) :: d1 ( n + 1 ), d2 ( n + 1 ), d3 ( n + 1 ) real ( wp ), intent ( inout ) :: y ( n + 2 ) integer i , it , iz real ( wp ) xx ( n + 1 ), a ( n ), b ( n ), c ( n ), f ( n ) real ( wp ) y1 ( n ) !print *, 'TK abc n = ', n do i = 1 , n + 1 xx ( i ) = h / 2.d0 + h * dble ( i - 1 ) !+shift end do do i = 1 , n y1 ( i ) = y ( i + 1 ) end do do it = 1 , nt !call ABCcoef(a,b,c,f,y1,dt,n,ybeg,yend,x,xx,h,D1) call chang_cooper_abcoef ( alfa2 , a , b , c , f , y1 , dt , n , ybeg , yend , xx , h , d1 ) call tridag ( a , b , c , f , y1 , n ) !do i=1,n !    if (y1(i).lt.0.d0) then !        if (y1(i) > epsilon(y1(i))) then !            y1(i)=0.d0 !        else !            write(*,*) n, i, 'y(i)=',y1(i),' lt negative epsilon=',epsilon(y1(i)) !            !pause !            !stop !        endif !    endif !enddo iz = n do i = 1 , n if ( y1 ( i ). lt . epsilon ( yend )) then iz = i !print *, epsilon(yend) !print *, iz, n, yend, y1(i) exit endif enddo do i = iz , n y1 ( i ) = yend enddo end do do i = 1 , n y ( i + 1 ) = y1 ( i ) end do end subroutine ! -- subroutine chang_cooper_abcoef ( alfa2 , A , B , C , f , Y , dt , n , ybeg , yend , xx , h , df ) implicit none real ( wp ), intent ( in ) :: alfa2 real ( wp ), intent ( inout ) :: a ( n ), b ( n ), c ( n ), f ( n ), y ( n + 2 ) integer , intent ( in ) :: n real ( wp ), intent ( in ) :: dt , ybeg , yend , h real ( wp ), intent ( in ) :: xx ( n + 1 ) real ( wp ), intent ( in ) :: df ( n + 1 ) integer i real ( wp ) z , r , tmp1 , tmp2 , tmp3 r = dt / h do i = 1 , n tmp1 = dlt ( xx ( i ), h , df ( i ), alfa2 ) * B1 ( xx ( i ), alfa2 ) A ( i ) =- r * ( C1 ( xx ( i ), df ( i )) / h - tmp1 ) tmp2 = C1 ( xx ( i + 1 ), df ( i + 1 )) / h - dlt ( xx ( i + 1 ), h , df ( i + 1 ), alfa2 ) * B1 ( xx ( i + 1 ), alfa2 ) tmp3 = ( 1.d0 - dlt ( xx ( i ), h , df ( i ), alfa2 )) * B1 ( xx ( i ), alfa2 ) B ( i ) = r * ( tmp2 + tmp3 + C1 ( xx ( i ), df ( i )) / h ) + 1.d0 tmp1 = ( 1.d0 - dlt ( xx ( i + 1 ), h , df ( i + 1 ), alfa2 )) * B1 ( xx ( i + 1 ), alfa2 ) C ( i ) =- r * ( tmp1 + C1 ( xx ( i + 1 ), df ( i + 1 )) / h ) f ( i ) = Y ( i ) enddo f ( 1 ) = f ( 1 ) - A ( 1 ) * ybeg f ( n ) = f ( n ) - C ( n ) * yend !yend in either way=0 all the time contains function B1 ( xx , alfa2 ) result ( res ) implicit none real ( wp ) xx , alfa2 , beta , res res = - alfa2 + 1.d0 / ( xx * xx ) end function function C1 ( xx , dif ) result ( res ) implicit none real ( wp ) xx , dif , res res = dif + 1.d0 / ( xx * xx * xx ) end function function dlt ( xx , h , dif , alfa2 ) result ( res ) implicit none real ( wp ) res real ( wp ) xx , h , dif , alfa2 real ( wp ) w w = h * B1 ( xx , alfa2 ) / C1 ( xx , dif ) res = 1.d0 / w - 1.d0 / ( dexp ( w ) - 1.d0 ) end function end !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc end module Chang_Cooper_module","tags":"","loc":"sourcefile\\1_chang_cooper_solver.f90.html"},{"title":"1_chebyshev.f90 – FRTS project","text":"Contents Modules chebyshev Source Code 1_chebyshev.f90 Source Code module chebyshev use kind_module implicit none contains SUBROUTINE chebft1 ( a , b , c , n , func ) ! Chebyshev fit: Given a function func, lower and upper limits ! of the interval [a,b], and a maximum degree n, this routine ! computes the n coefficients c(k) such that func(x) approximately = ! SUMM_(k=1)&#94;(k=n)[c(k)*T(k-1)(y)]-c(1)/2, where y and x are related by ! (5.8.10). This routine is to be used with moderately large n ! (e.g., 30 or 50), the array of cs subsequently to be truncated ! at the smaller value m such that c(m+1) and subsequent elements ! are negligible. Parameters: Maximum expected value of n, and ð. implicit none INTEGER n , NMAX real ( wp ) a , b , c ( n ), func , PI EXTERNAL func PARAMETER ( NMAX = 50 , PI = 3.141592653589793d0 ) INTEGER j , k real ( wp ) bma , bpa , fac , y , f ( NMAX ) real ( wp ) sum bma = 0.5d0 * ( b - a ) bpa = 0.5d0 * ( b + a ) do k = 1 , n y = cos ( PI * ( k - 0.5d0 ) / n ) f ( k ) = func ( y * bma + bpa ) end do fac = 2.d0 / n do j = 1 , n sum = 0.d0 do k = 1 , n sum = sum + f ( k ) * cos (( PI * ( j - 1 )) * (( k - 0.5d0 ) / n )) end do c ( j ) = fac * sum end do return END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! FUNCTION chebev ( a , b , c , m , x ) ! Chebyshev evaluation: All arguments are input. ! c(1:m) is an array of Chebyshev coefficients, the first m elements ! of c output from chebft (which must have been called with ! the same a and b). The Chebyshev polynomial evaluated ! and the result is returned as the function value. implicit none INTEGER m real ( wp ) chebev , a , b , x , c ( m ) INTEGER j real ( wp ) d , dd , sv , y , y2 if (( x - a ) * ( x - b ). gt . 0.d0 ) pause 'x not in range in chebev' d = 0.d0 dd = 0.d0 y = ( 2.d0 * x - a - b ) / ( b - a ) y2 = 2.d0 * y do j = m , 2 , - 1 sv = d d = y2 * d - dd + c ( j ) dd = sv end do chebev = y * d - dd + 0.5d0 * c ( 1 ) return END !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SUBROUTINE chder ( a , b , c , cder , n ) ! Given a,b,c(1:n), as output from routine chebft(), and given n, ! the desired degree of approximation (length of c to be used), ! this routine returns the array cder(1:n), the Chebyshev ! coefficients of the derivative of the function whose coefficients ! are c(1:n). implicit none INTEGER n real ( wp ) a , b , c ( n ), cder ( n ) INTEGER j real ( wp ) con cder ( n ) = 0.d0 cder ( n - 1 ) = 2 * ( n - 1 ) * c ( n ) do j = n - 2 , 1 , - 1 cder ( j ) = cder ( j + 2 ) + 2 * j * c ( j + 1 ) end do con = 2.d0 / ( b - a ) do j = 1 , n cder ( j ) = cder ( j ) * con end do return END end module chebyshev","tags":"","loc":"sourcefile\\1_chebyshev.f90.html"},{"title":"1_constants.f90 – FRTS project","text":"Contents Modules constants Source Code 1_constants.f90 Source Code module constants !! модуль с математическими и физическими константами use kind_module implicit none real ( wp ), parameter :: zero = 0.0_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: two = 2.0_wp real ( wp ), parameter :: one_third = 1.0_wp / 3.0_wp real ( wp ), parameter :: tiny = 1.e-100_wp real ( wp ), parameter :: tin = 1e-7_wp real ( wp ), parameter :: pi = acos ( - one ) !! число Пи = 3.1415.... real ( wp ), parameter :: pi2 = 2.0_wp * pi real ( wp ), parameter :: pi4 = 4.0_wp * pi real ( wp ), parameter :: piq = sqrt ( pi ) real ( wp ), parameter :: talfa = 3.5_wp !! alpha particles' birth energy, MeV real ( wp ), parameter :: zalfa = 2.0_wp !! alpha particles' electrical charge real ( wp ), parameter :: xmalfa = 4.0_wp !! alpha particles' atomic mass real ( wp ), parameter :: clt = 3.0e+10_wp !! скорость света real ( wp ), parameter :: pme = 9.11e-28_wp real ( wp ), parameter :: pme_e = 9.11e-28 real ( wp ), parameter :: pqe = 4.803e-10_wp real ( wp ), parameter :: xlog = 1 6.0_wp + dlog ( 1 6.0_wp ) real ( wp ), parameter :: c0 = sqrt ( pi4 * pqe ** 2 / pme ) real ( wp ), parameter :: c1 = pqe / pme / clt real ( wp ), parameter :: xsgs = 1e+13_wp real ( wp ), parameter :: xwtt = 1e-7_wp real ( wp ), parameter :: cnst1 = 0.2965924106e-6_wp !! cnst1=(m_e/m_p)**2, CGS real ( wp ), parameter :: cnst2 = 0.359680922e-35_wp !! cnst2=(m_e/e)**2,  CGS contains subroutine show_constants () print * , '---------------------------------------' print * , \"zero       = \" , zero print * , \"one        = \" , one print * , \"two        = \" , two print * , \"one_third  = \" , one_third print * , \"tiny       = \" , tiny print * , \"tin        = \" , tin print * print * , \"4*ATAN     = \" , 4.d0 * datan ( 1.d0 ) print * , \"pi         = \" , pi print * , \"pi2        = \" , pi2 print * , \"pi4        = \" , pi4 print * , \"piq        = \" , piq print * print * , \"talfa      = \" , talfa print * , \"zalfa      = \" , zalfa print * , \"xmalfa     = \" , xmalfa print * , \"clt        = \" , clt print * print * , \"pme_e      = \" , pme_e print * , \"pme        = \" , pme print * , \"9.11d-28   = \" , 9.11d-28 print * , \"pqe        = \" , pqe print * , \"xlog       = \" , xlog print * , \"c0         = \" , c0 print * , \"c1         = \" , c1 print * , \"xsgs       = \" , xsgs print * , \"xwtt       = \" , xwtt print * print * , \"cnst1  = \" , cnst1 print * , \"cnst2  = \" , cnst2 print * , '---------------------------------------' end subroutine show_constants end module constants","tags":"","loc":"sourcefile\\1_constants.f90.html"},{"title":"1_rt_parameters.f90 – FRTS project","text":"Contents Modules rt_parameters Source Code 1_rt_parameters.f90 Source Code module rt_parameters use kind_module implicit none !   physical parameters real ( wp ) :: freq !! Freq,     RF frequency, GHz real ( wp ) :: xmi1 !!  Mi1/Mp,  relative mass of ions 1 real ( wp ) :: zi1 !! charge of ions 1 real ( wp ) :: xmi2 !! Mi2/Mp,  relative mass of ions 2 real ( wp ) :: zi2 !! charge of ions 2 real ( wp ) :: dni2 !!  0.03   Ni2/Ni1, relative density of ions 2 real ( wp ) :: xmi3 !!  Mi3/Mp,  relative mass of ions 3 real ( wp ) :: zi3 !!  charge of ions 3 real ( wp ) :: dni3 !!  Ni3/Ni1, relative density of ions 3 !!!!!!!!!!!!!  parameters for alphas calculations !!! integer :: itend0 !! itend0,   if = 0, no alphas real ( wp ) :: energy !! energy,   max. perp. energy of alphas (MeV) real ( wp ) :: factor !! factor,   factor in alpha source real ( wp ) :: dra !! dra,      relative alpha source broadening (dr/a) integer :: kv !! kv,       V_perp  greed number !!!!!!!!!!!!! numerical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!! integer :: nr !! nr,  radial grid number  <= 505 real ( wp ) :: hmin1 !! hmin1, rel.(hr) min. step in the Fast comp. mode, <1.d0 real ( wp ) :: rrange !! rrange,   rel.(hr) size of a 'turning' point region, <1.d0 real ( wp ) :: eps !! eps,      accuracy real ( wp ) :: hdrob !! hdrob,    h4 correction, real ( wp ) :: cleft !! cleft,    left Vz plato border shift (<1) real ( wp ) :: cright !! cright,   right Vz plato border shift (>1) real ( wp ) :: cdel !! cdel,     (left part)/(Vz plato size) real ( wp ) :: rbord !! rbord,    relative radius of reflection, <1. real ( wp ) :: pchm !! pchm,     threshold between 'strong' and weak' absorption, <1. real ( wp ) :: pabs0 !! pabs,     part of remaining power interp. as absorption real ( wp ) :: pgiter !! pgiter,   relative accuracy to stop iterations integer :: ni1 !! ni1,      grid number in the left part of Vz plato integer :: ni2 !! ni2,      grid number in the right part of Vz plato integer :: niterat !! niterat,  maximal number of iterations integer :: nmaxm ( 4 ) !! nmaxm(1), permitted reflections at 0 iteration !! nmaxm(2), permitted reflections at 1 iteration !! nmaxm(3), permitted reflections at 2 iteration !! nmaxm(4), permitted reflections at 3 iteration integer :: maxstep2 !! maxstep2, maximal steps' number in Fast comp. mode integer :: maxstep4 !! maxstep4, maximal steps' number in Slow comp. mode !!!!!!!!!!!!!  options !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! integer :: ipri !! ipri, printing output monitoring: 0,1,2,3,4 integer :: iw !! iw, initial mode (slow=1, fast=-1) integer :: ismth !! ismth, if=0, no smoothing in Ne(rho),Te(rho),Ti(rho) integer :: ismthalf !! ismthalf,  if=0, no smoothing in D_alpha(vperp) integer :: ismthout !! ismthout,  if=0, no smoothing in output profiles integer :: inew !! inew=0 for usual tokamak&Ntor_grill; 1 or 2 for g' in ST&Npol_grill integer :: itor !! itor,      +-1, Btor direction in right coord{drho,dteta,dfi} integer :: i_pol !! ipol,      +-1, Bpol direction in right coord{drho,dteta,dfi} !!!!!!!!!!!!!  grill parameters and input LH spectrum !!!!!!!!!!!! real ( wp ) :: zplus !! Zplus,    upper grill corner in centimeters real ( wp ) :: zminus !! Zminus,   lower grill corner in centimeters integer :: ntet !! ntet,     theta grid number integer :: nnz !! nnz,      N_phi grid number integer :: spectrum_type !! spectrum type 1 - 1D, 2 = 2D, 3, scatter contains subroutine show_parameters () print * , \"Freq = \" , freq print * , \"xmi1 = \" , xmi1 print * , \"zi1 = \" , zi1 print * , \"xmi2 = \" , xmi2 print * , \"zi2 = \" , zi2 print * , \"dni2 = \" , dni2 print * , \"---------- grill parameters and input LH spectrum \" print * , \"zplus = \" , zplus print * , \"zminus = \" , zminus print * , \"ntet = \" , ntet print * , \"nnz = \" , nnz end subroutine show_parameters subroutine read_parameters ( file_name ) implicit none integer , parameter :: iunit = 20 character ( * ) file_name print * , file_name open ( iunit , file = file_name ) !!!!!!!!!!!!!  read  physical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! read ( iunit , * ) read ( iunit , * ) freq read ( iunit , * ) xmi1 read ( iunit , * ) zi1 read ( iunit , * ) xmi2 read ( iunit , * ) zi2 read ( iunit , * ) dni2 read ( iunit , * ) xmi3 read ( iunit , * ) zi3 read ( iunit , * ) dni3 !!!!!!!!!!!!!  read parameters for alphas calculation !!!!!!!!!!!!!!!!!!! read ( iunit , * ) read ( iunit , * ) itend0 read ( iunit , * ) energy read ( iunit , * ) factor read ( iunit , * ) dra read ( iunit , * ) kv !!!!!!!!!!!!!  read  numerical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!! read ( iunit , * ) read ( iunit , * ) nr read ( iunit , * ) hmin1 read ( iunit , * ) rrange read ( iunit , * ) eps read ( iunit , * ) hdrob read ( iunit , * ) cleft read ( iunit , * ) cright read ( iunit , * ) cdel read ( iunit , * ) rbord read ( iunit , * ) pchm read ( iunit , * ) pabs0 read ( iunit , * ) pgiter read ( iunit , * ) ni1 read ( iunit , * ) ni2 read ( iunit , * ) niterat read ( iunit , * ) nmaxm ( 1 ) read ( iunit , * ) nmaxm ( 2 ) read ( iunit , * ) nmaxm ( 3 ) read ( iunit , * ) nmaxm ( 4 ) read ( iunit , * ) maxstep2 read ( iunit , * ) maxstep4 !!!!!!!!!!!!!  read  options !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! read ( iunit , * ) read ( iunit , * ) ipri read ( iunit , * ) iw read ( iunit , * ) ismth read ( iunit , * ) ismthalf read ( iunit , * ) ismthout read ( iunit , * ) inew read ( iunit , * ) itor !Btor direction in right-hand {drho,dteta,dfi} read ( iunit , * ) i_pol !Bpol direction in right-hand {drho,dteta,dfi} !!!!!!!!!!!!!  read grill parameters and input LH spectrum !!!!!!!!!!!! read ( iunit , * ) read ( iunit , * ) zplus read ( iunit , * ) zminus read ( iunit , * ) ntet read ( iunit , * ) nnz read ( iunit , * ) spectrum_type close ( iunit ) print * , 'checking initial parameters' !!!!!!!!!!!!! checking initial parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( kv . gt . 50 ) kv = 50 if ( nr . gt . 100 ) nr = 100 if ( ni1 . eq . 0 ) ni1 = 20 if ( ni2 . eq . 0 ) ni2 = 20 if ( ni1 + ni2 . gt . 100 ) then ni1 = 60 ni2 = 40 end if if ( nnz * ntet . gt . 10000 ) then nnz = 250 ntet = 40 pause 'nnz and ntet changed, because nnz*ntet>10000' end if call show_parameters end subroutine read_parameters end module rt_parameters","tags":"","loc":"sourcefile\\1_rt_parameters.f90.html"},{"title":"1_savelyev_solver.f90 – FRTS project","text":"Contents Modules savelyev_solver_module Source Code 1_savelyev_solver.f90 Source Code module savelyev_solver_module use kind_module implicit none PRIVATE :: q , k contains subroutine savelyev_solver ( alfa2 , nt , h , dt , n , ybeg , yend , d1 , d2 , d3 , y ) ! разностная схема Савельева для уравнения Фоккера-Планка implicit none real ( wp ), intent ( in ) :: alfa2 integer , intent ( in ) :: nt , n real ( wp ), intent ( in ) :: h , dt real ( wp ), intent ( in ) :: ybeg , yend real ( wp ), intent ( in ) :: d1 ( n + 1 ), d2 ( n + 1 ), d3 ( n + 1 ) real ( wp ), intent ( inout ) :: y ( n ) integer i , it real ( wp ) xx ( n + 1 ), a ( n ), b ( n ), c ( n ), f ( n ) do i = 1 , n + 1 xx ( i ) = h / 2.d0 + h * dble ( i - 1 ) !+shift end do do it = 1 , nt call savelyev_abccoef ( alfa2 , a , b , c , f , y , dt , n , ybeg , yend , xx , h , d1 , d2 , d3 ) call tridag ( a , b , c , f , y , n ) end do end subroutine !!!!!!! -- fill abc matrix subroutine savelyev_abccoef ( alfa2 , a , b , c , f , y , dt , n , ybeg , yend , xx , h , d1 , d2 , d3 ) implicit none real ( wp ), intent ( in ) :: alfa2 real ( wp ), intent ( inout ) :: a ( n ), b ( n ), c ( n ), f ( n ), y ( n ) real ( wp ), intent ( in ) :: dt integer , intent ( in ) :: n real ( wp ), intent ( in ) :: ybeg , yend , h real ( wp ), intent ( in ) :: xx ( n + 1 ) real ( wp ), intent ( in ) :: d1 ( n + 1 ), d2 ( n + 1 ), d3 ( n + 1 ) integer i , iunit , iunit2 real ( wp ) a1 ( n ), b1 ( n ), c1 ( n ), f1 ( n ), a2 ( n ), b2 ( n ), c2 ( n ), f2 ( n ) real ( wp ) kinv , rs , rmink , rplusk , q , qf , r1 , rmink2 , rplusk2 , kinv2 real ( wp ) r , kappa , sum , bmin , bplus , sum2 , sum3 , sum4 real ( wp ) dc , as ( n + 1 ), k , k2 , d external kinv , rs , rmink , rplusk , q , kinv2 , rmink2 , rplusk2 , d sum = ( kinv ( xx ( 1 ) - h / 2 d0 , d2 ( 1 ), alfa2 ) + kinv ( xx ( 1 ) + h / 2 d0 , d3 ( 1 ), alfa2 )) * h / 2 d0 as ( 1 ) = h / sum sum = ( kinv ( xx ( 2 ) - h / 2 d0 , d2 ( 2 ), alfa2 ) + kinv ( xx ( 2 ) + h / 2 d0 , d3 ( 2 ), alfa2 )) * h / 2 d0 as ( 2 ) = h / sum r = h / 2 d0 * dabs ( rs ( xx ( 1 ) + h / 2 d0 , d3 ( 1 ), alfa2 )) / k ( xx ( 1 ) + h / 2 d0 , d3 ( 1 )) kappa = 1 d0 / ( 1 d0 + r ) sum = ( rmink ( xx ( 1 ), d1 ( 1 ), alfa2 ) + rmink ( xx ( 2 ), d1 ( 2 ), alfa2 )) * h / 2 d0 bmin = sum / h sum = ( rplusk ( xx ( 1 ), d1 ( 1 ), alfa2 ) + rplusk ( xx ( 2 ), d1 ( 2 ), alfa2 )) * h / 2 d0 bplus = sum / h sum = qf ( xx ( 2 )) - qf ( xx ( 1 )) dc = sum / h a ( 1 ) = as ( 1 ) * ( kappa / h ** 2 - bmin / h ) c ( 1 ) = as ( 2 ) * ( kappa / h ** 2 + bplus / h ) b ( 1 ) = - ( 1 d0 / dt + a ( 1 ) + c ( 1 ) + dc ) f ( 1 ) = - y ( 1 ) / dt - a ( 1 ) * ybeg do i = 2 , n sum = ( kinv ( xx ( i + 1 ) - h / 2 d0 , d2 ( i + 1 )) + kinv ( xx ( i + 1 ) + h / 2 d0 , d3 ( i + 1 ))) sum = sum * h / 2 d0 as ( i + 1 ) = h / sum r = h / 2 d0 * dabs ( rs ( xx ( i ) + h / 2 d0 , alfa2 )) / k ( xx ( i ) + h / 2 d0 , d3 ( i )) kappa = 1 d0 / ( 1 d0 + r ) sum = ( rmink ( xx ( i ), d1 ( i ), alfa2 ) + rmink ( xx ( i + 1 ), d1 ( i + 1 ), alfa2 )) * h / 2 d0 bmin = sum / h sum = ( rplusk ( xx ( i ), d1 ( i ), alfa2 ) + rplusk ( xx ( i + 1 ), d1 ( i + 1 ), alfa2 )) * h / 2 d0 bplus = sum / h sum = qf ( xx ( i + 1 )) - qf ( xx ( i )) dc = sum / h a ( i ) = as ( i ) * ( kappa / h ** 2 - bmin / h ) c ( i ) = as ( i + 1 ) * ( kappa / h ** 2 + bplus / h ) b ( i ) = - ( 1 d0 / dt + a ( i ) + c ( i ) + dc ) f ( i ) = - y ( i ) / dt end do f ( n ) = f ( n ) - c ( n ) * yend a ( 1 ) = 0 d0 c ( n ) = 0 d0 end real ( wp ) function rplusk ( x , dif , alfa2 ) implicit none integer iunit real ( wp ) x , k , rs , dif , d , razn real ( wp ) alfa2 rplusk = 0.5d0 * ( rs ( x , alfa2 ) + dabs ( rs ( x , alfa2 ))) / k ( x , dif ) end real ( wp ) function rplusk2 ( x , dif , alfa2 ) implicit none integer iunit real ( wp ) x , k2 , rs , dif , d , razn real ( wp ) alfa2 rplusk2 = 0.5d0 * ( rs ( x , alfa2 ) + dabs ( rs ( x , alfa2 ))) / k2 ( x , dif ) end real ( wp ) function rmink ( x , dif , alfa2 ) implicit none integer iunit real ( wp ) x , k , rs , dif , d , razn real ( wp ) alfa2 rmink = 0.5d0 * ( rs ( x , alfa2 ) - dabs ( rs ( x , alfa2 ))) / k ( x , dif ) end real ( wp ) function rmink2 ( x , dif , alfa2 ) implicit none integer iunit real ( wp ) x , k2 , rs , dif , d , razn real ( wp ) alfa2 rmink2 = 0.5d0 * ( rs ( x , alfa2 ) - dabs ( rs ( x , alfa2 ))) / k2 ( x , dif ) end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! real ( wp ) function rs ( x , alfa2 ) implicit none real ( wp ) x real ( wp ) alfa2 !common/ef/ alfa2 rs = 1 d0 / x ** 2 - alfa2 end real ( wp ) function q ( x ) implicit none real ( wp ) x q = 2 d0 / x ** 3 end real ( wp ) function qf ( x ) implicit none real ( wp ) x qf =- 1 d0 / x ** 2 end real ( wp ) function k ( x , dif ) implicit none integer iunit real ( wp ) x , dif , d , razn k = dif + 1 d0 / x ** 3 end real ( wp ) function k2 ( x , dif ) implicit none integer iunit real ( wp ) x , dif , d , razn k2 = d ( x ) + 1 d0 / x ** 3 end real ( wp ) function kinv ( x , dif ) implicit none integer iunit real ( wp ) x , dif , razn , d kinv = x ** 3 / ( dif * x ** 3 + 1 d0 ) end real ( wp ) function kinv2 ( x , dif ) implicit none integer iunit real ( wp ) x , dif , razn , d , kino kinv2 = x ** 3 / ( d ( x ) * x ** 3 + 1 d0 ) end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine tridag ( a , b , c , r , u , n ) implicit none integer , intent ( in ) :: n real ( wp ), intent ( in ) :: a ( n ), b ( n ), c ( n ), r ( n ) real ( wp ), intent ( inout ) :: u ( n ) integer , parameter :: nmax = 1000000 integer j real ( wp ) bet , gam ( nmax ) if ( b ( 1 ). eq . 0.d0 ) pause 'tridag: rewrite equations' bet = b ( 1 ) u ( 1 ) = r ( 1 ) / bet do j = 2 , n gam ( j ) = c ( j - 1 ) / bet bet = b ( j ) - a ( j ) * gam ( j ) if ( bet . eq . 0.d0 ) then write ( * , * ) 'b(j)=' , b ( j ), 'a(j)=' , a ( j ), 'gam(j)=' , gam ( j ) pause 'tridag failed' end if u ( j ) = ( r ( j ) - a ( j ) * u ( j - 1 )) / bet end do do j = n - 1 , 1 , - 1 u ( j ) = u ( j ) - gam ( j + 1 ) * u ( j + 1 ) end do end subroutine end module savelyev_solver_module","tags":"","loc":"sourcefile\\1_savelyev_solver.f90.html"},{"title":"1_spline.f90 – FRTS project","text":"Contents Modules spline Source Code 1_spline.f90 Source Code module spline use kind_module implicit none contains subroutine splne ( x , y , n , y2 ) integer , parameter :: nn = 1001 real ( wp ), parameter :: zero = 0 d0 integer n real ( wp ) x ( n ), y ( n ), y2 ( n ), u ( nn ) integer i , k real ( wp ) p , qn , un , sig if ( n . gt . nn ) stop 'n>nn in splne!' y2 ( 1 ) = zero u ( 1 ) = zero do i = 2 , n - 1 sig = ( x ( i ) - x ( i - 1 )) / ( x ( i + 1 ) - x ( i - 1 )) p = sig * y2 ( i - 1 ) + 2.d0 y2 ( i ) = ( sig - 1.d0 ) / p u ( i ) = ( 6.d0 * (( y ( i + 1 ) - y ( i )) / ( x ( i + 1 ) - x ( i )) - ( y ( i ) - y ( i - 1 )) / ( x ( i ) - x ( i - 1 ))) / ( x ( i + 1 ) - x ( i - 1 )) - sig * u ( i - 1 )) / p end do qn = zero un = zero y2 ( n ) = ( un - qn * u ( n - 1 )) / ( qn * y2 ( n - 1 ) + 1.d0 ) do k = n - 1 , 1 , - 1 y2 ( k ) = y2 ( k ) * y2 ( k + 1 ) + u ( k ) end do return end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine splnt ( xa , ya , y2a , n , x , y , dy ) real ( wp ), parameter :: zero = 0 d0 integer n real ( wp ) xa ( n ), ya ( n ), y2a ( n ) integer k , klo , khi real ( wp ) x , h , a , b , aa , bb , hh , ax , bx , y , dy klo = 1 khi = n do while ( khi - klo . gt . 1 ) k = ( khi + klo ) / 2 if ( xa ( k ). gt . x ) then khi = k else klo = k endif end do h = xa ( khi ) - xa ( klo ) if ( h . eq . zero ) then write ( * , * ) 'bad x input in splnt(), x=' , x write ( * , * ) 'klo=' , klo , ' kho=' , khi stop end if a = ( xa ( khi ) - x ) / h b = ( x - xa ( klo )) / h aa = a ** 2 bb = b ** 2 hh = h ** 2 / 6 d0 ax =- 1 d0 / h bx =- ax y = a * ya ( klo ) + b * ya ( khi ) + ( a * ( aa - 1 d0 ) * y2a ( klo ) + b * ( bb - 1 d0 ) * y2a ( khi )) * hh dy = ax * ya ( klo ) + bx * ya ( khi ) + ax * (( 3.d0 * aa - 1 d0 ) * y2a ( klo ) - ( 3.d0 * bb - 1 d0 ) * y2a ( khi )) * hh end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine dsplnt ( xa , ya , y2a , n , x , y , dy , ddy ) real ( wp ), parameter :: zero = 0 d0 integer n real ( wp ) xa ( n ), ya ( n ), y2a ( n ) integer k , klo , khi real ( wp ) x , h , a , b , aa , bb , hh , ax , bx , y , dy , ddy klo = 1 khi = n do while ( khi - klo . gt . 1 ) k = ( khi + klo ) / 2 if ( xa ( k ). gt . x ) then khi = k else klo = k endif end do h = xa ( khi ) - xa ( klo ) if ( h . eq . zero ) then write ( * , * ) 'bad x input in splnt(), x=' , x write ( * , * ) 'klo=' , klo , ' kho=' , khi stop end if a = ( xa ( khi ) - x ) / h b = ( x - xa ( klo )) / h aa = a ** 2 bb = b ** 2 hh = h ** 2 / 6 d0 ax =- 1 d0 / h bx =- ax y = a * ya ( klo ) + b * ya ( khi ) + ( a * ( aa - 1 d0 ) * y2a ( klo ) + b * ( bb - 1 d0 ) * y2a ( khi )) * hh dy = ax * ya ( klo ) + bx * ya ( khi ) + ax * (( 3.d0 * aa - 1 d0 ) * y2a ( klo ) - ( 3.d0 * bb - 1 d0 ) * y2a ( khi )) * hh ddy = 6.d0 * ax * ax * ( a * y2a ( klo ) + b * y2a ( khi )) * hh end end module spline","tags":"","loc":"sourcefile\\1_spline.f90.html"},{"title":"1_utils.f90 – FRTS project","text":"Contents Modules Utils Source Code 1_utils.f90 Source Code module Utils use kind_module contains function sys_time () ! ** return system time implicit none real ( wp ) sys_time integer count , count_rate , count_max call system_clock ( count , count_rate , count_max ) sys_time = count * 1.0 / count_rate return end end  module Utils","tags":"","loc":"sourcefile\\1_utils.f90.html"},{"title":"1_writer_module.f90 – FRTS project","text":"Contents Modules writer_module Source Code 1_writer_module.f90 Source Code module writer_module use kind_module implicit none contains subroutine write_v_array ( v , a , time , array_name ) !! сохраняет массивы расределения и скорости implicit none real ( wp ), intent ( in ) :: v (:,:) real ( wp ), intent ( in ) :: a (:,:,:) real ( wp ), intent ( in ) :: time character ( len =* ), intent ( in ) :: array_name real ( wp ), allocatable :: gv (:), ga (:) integer i , N , nshape ( 3 ) character ( 120 ) fname integer , parameter :: iu = 21 if ( MOD ( INT ( time * 100000 ), 10 ) /= 0 ) then return end if nshape = shape ( a ) print * , 'write arr:' , array_name , nshape N = nshape ( 2 ) print * , N write ( fname , '(\"lhcd/\", A,\"/\", f9.7,\".dat\")' ) array_name , time print * , fname open ( iu , file = fname , position = \"append\" ) do i = 1 , N gv = glue_v_axis ( v (:, i )) write ( iu , '(2012(ES22.14))' ) gv (:) deallocate ( gv ) ga = glue_arrays ( a (:, i , 1 ), a (:, i , 2 )) write ( iu , '(2012(ES22.14))' ) ga (:) deallocate ( ga ) end do close ( iu ) contains function glue_v_axis ( a ) result ( g ) implicit none real ( wp ), intent ( in ) :: a (:) real ( wp ), allocatable :: g (:) integer i , N N = size ( a ) allocate ( g ( - N : N )) g ( - N : - 1 ) = - a ( N : 1 : - 1 ) g ( 1 : N ) = a (:) g ( 0 ) = 0 end function function glue_arrays ( a , b ) result ( g ) implicit none real ( wp ), intent ( in ) :: a (:), b (:) real ( wp ), allocatable :: g (:) integer i , N N = size ( a ) allocate ( g ( - N : N )) g ( - N : - 1 ) = a ( N : 1 : - 1 ) g ( 1 : N ) = b (:) g ( 0 ) = ( a ( 1 ) + b ( 1 )) / 2 d0 end function end subroutine subroutine write_x_array ( x , arr , time , array_name ) implicit none real ( wp ), intent ( in ) :: x (:,:) real ( wp ), intent ( in ) :: arr (:,:) real ( wp ), intent ( in ) :: time character ( len =* ), intent ( in ) :: array_name integer i , N , nshape ( 2 ) character ( 120 ) fname integer , parameter :: iu = 21 nshape = shape ( arr ) print * , 'write arr:' , array_name , nshape N = nshape ( 2 ) print * , N write ( fname , '(\"lhcd/\", A,\"/xar\", f9.7,\".dat\")' ) array_name , time print * , fname open ( iu , file = fname , position = \"append\" ) do i = 1 , N write ( iu , '(2012(ES22.14))' ) x (: , i ) write ( iu , '(2012(ES22.14))' ) arr (:, i ) end do close ( iu ) end subroutine subroutine write_matrix ( arr , time , array_name ) implicit none real ( wp ), intent ( in ) :: arr (:,:) real ( wp ), intent ( in ) :: time character ( len =* ), intent ( in ) :: array_name integer i , N , nshape ( 2 ) character ( 120 ) fname integer , parameter :: iu = 21 nshape = shape ( arr ) print * , 'write_matrix:' , array_name , nshape N = nshape ( 1 ) print * , N write ( fname , '(\"lhcd/\", A,\"/\", f9.7,\".dat\")' ) array_name , time print * , fname open ( iu , file = fname , position = \"append\" ) do i = 1 , N write ( iu , ' ( I4.4, 100(ES21.14))' ) i , arr ( i , :) end do close ( iu ) end subroutine subroutine write_array ( arr , N , array_name ) implicit none real ( wp ), intent ( in ) :: arr ( * ) integer , intent ( in ) :: N character ( len =* ), intent ( in ) :: array_name integer i integer , parameter :: iunit = 21 character ( 80 ) fname print * , 'write_array:' , array_name , N write ( fname , '(\"lhcd/distribution/\", A,\".dat\")' ) array_name print * , fname open ( iunit , file = fname , position = \"append\" ) do i = 1 , n write ( iunit , * ) i , arr ( i ) end do close ( iunit ) end subroutine subroutine write_distribution ( arr , N , time ) implicit none real ( wp ), intent ( in ) :: arr ( * ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: time integer i integer itime integer , parameter :: iunit = 20 character ( 120 ) fname itime = INT ( time * 100000 ) !print *, N, time, itime, MOD(itime, 10) if ( MOD ( itime , 10 ) == 0 ) then write ( fname , '(\"lhcd/distribution/\", f9.7,\".dat\")' ) time !print *, fname open ( iunit , file = fname , position = \"append\" ) do i = 1 , N if ( arr ( i ) > 0 ) then write ( iunit , * ) i , arr ( i ) else exit end if end do close ( iunit ) end if end subroutine end module writer_module","tags":"","loc":"sourcefile\\1_writer_module.f90.html"},{"title":"2_FokkerPlanck1D.f90 – FRTS project","text":"Contents Modules FokkerPlanck1D_mod Source Code 2_FokkerPlanck1D.f90 Source Code module FokkerPlanck1D_mod ! the module name defines the namespace use , intrinsic :: iso_fortran_env , only : sp => real32 , dp => real64 use savelyev_solver_module implicit none type FokkerPlanck1D !- solver of FP eq !integer          :: direction = 0 !- direction real ( dp ) :: enorm = 0 !- электрическое поле real ( dp ) :: v_lim = 0 !- верхняя граница скорости электронов real ( dp ), allocatable :: v (:) !- сетка скоростей real ( dp ), allocatable :: f (:) !- распределение integer :: i0 = 0 !- size of distribution grid real ( dp ) :: alfa2 = 0 !- поле со знаком integer :: n = 0 !- size of local grid real ( dp ) :: h = 0 !- step of local grid real ( dp ), allocatable :: d1 (:), d2 (:), d3 (:) !- диффузия contains procedure :: print => FokkerPlanck1D_print procedure :: solve_time_step => FokkerPlanck1D_solve_time_step procedure :: init_zero_diffusion => FokkerPlanck1D_init_zero_diffusion procedure :: init_diffusion => FokkerPlanck1D_init_diffusion end type FokkerPlanck1D interface FokkerPlanck1D module procedure :: FokkerPlanck1D_constructor end interface FokkerPlanck1D contains function FokkerPlanck1D_constructor ( e , v_lim , v , f ) result ( this ) !- конструктор для FokkerPlanck1D implicit none type ( FokkerPlanck1D ) :: this real ( dp ), value :: e , v_lim , v (:), f (:) integer :: n real ( dp ) :: h real ( dp ), parameter :: h0 = 0.1d0 !this%inst_field1 = cmplx(0.,0.) this % enorm = abs ( e ) this % v_lim = v_lim this % v = v this % f = f this % i0 = size ( v ) this % alfa2 = e n = v_lim / h0 - 1 h = v_lim / dble ( n + 1 ) if ( h . gt . h0 ) then n = n + 1 h = v_lim / dble ( n + 1 ) end if this % n = n this % h = h end function FokkerPlanck1D_constructor subroutine FokkerPlanck1D_print ( this ) class ( FokkerPlanck1D ), intent ( in ) :: this print * , 'e = ' , this % enorm , 'i0 =' , this % i0 end subroutine FokkerPlanck1D_print subroutine FokkerPlanck1D_init_zero_diffusion ( this ) implicit none class ( FokkerPlanck1D ), intent ( inout ) :: this integer :: n n = this % n allocate ( this % d1 ( n + 1 ), this % d2 ( n + 1 ), this % d3 ( n + 1 )) this % d1 (:) = 0 d0 this % d2 (:) = 0 d0 this % d3 (:) = 0 d0 end subroutine FokkerPlanck1D_init_zero_diffusion subroutine FokkerPlanck1D_init_diffusion ( this , dif ) !- инициализация диффузии для схемы савельева implicit none class ( FokkerPlanck1D ), intent ( inout ) :: this integer :: n real ( dp ), dimension (:), intent ( in ) :: dif real ( dp ), dimension (:), allocatable :: xx real ( dp ) h integer :: i0 integer i , klo , khi , ierr , klo1 , khi1 integer klo2 , klo3 , khi2 , khi3 , ierr1 , ierr2 , ierr3 n = this % n h = this % h allocate ( this % d1 ( n + 1 ), this % d2 ( n + 1 ), this % d3 ( n + 1 )) i0 = this % i0 allocate ( xx ( n + 1 )) do i = 1 , n + 1 xx ( i ) = h / 2.d0 + h * dble ( i - 1 ) !+shift end do do i = 1 , n + 1 call lock ( this % v , i0 , xx ( i ), klo1 , khi1 , ierr1 ) call lock ( this % v , i0 , xx ( i ) - h / 2 d0 , klo2 , khi2 , ierr2 ) call lock ( this % v , i0 , xx ( i ) + h / 2 d0 , klo3 , khi3 , ierr3 ) if ( ierr1 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo1=' , klo1 , 'khi1=' , khi1 , 'i=' , i write ( * , * ) 'vj(1)=' , this % v ( 1 ), ' vj(i0)=' , this % v ( i0 ) pause stop end if if ( ierr2 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo2=' , klo2 , 'khi2=' , khi2 , 'i=' , i write ( * , * ) 'vj(1)=' , this % v ( 1 ), ' vj(i0)=' , this % v ( i0 ) pause stop end if if ( ierr3 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo3=' , klo3 , 'khi3=' , khi3 , 'i=' , i write ( * , * ) 'vj(1)=' , this % v ( 1 ), ' vj(i0)=' , this % v ( i0 ) pause stop end if this % d1 ( i ) = dif ( klo1 ) this % d2 ( i ) = dif ( klo2 ) this % d3 ( i ) = dif ( klo3 ) end do end subroutine FokkerPlanck1D_init_diffusion subroutine FokkerPlanck1D_solve_time_step ( this , dt , nt ) implicit none class ( FokkerPlanck1D ), intent ( inout ) :: this integer , intent ( in ) :: nt real ( dp ), intent ( in ) :: dt !real*8, intent (inout), optional :: dfj0(:) real ( dp ), parameter :: zero = 0.d0 real ( dp ) y ( this % n + 2 ), x ( this % n + 2 ) real ( dp ), dimension (:), allocatable :: fj , dfj , givi integer i , ii , it , ibeg , klo , khi , ierr , klo1 , khi1 real ( dp ) shift , ybeg , yend , tend , dff !!!!!! grid !!!!!!!!! !!  shift=h*0.1d0 !0.01d0 do i = 1 , this % n + 2 x ( i ) = this % h * dble ( i - 1 ) !+shift end do do i = 1 , this % n + 1 call lock ( this % v , this % i0 , x ( i + 1 ), klo , khi , ierr ) if ( ierr . eq . 1 ) then write ( * , * ) 'lock error #1 in finction fokkerplanck' write ( * , * ) 'j=' , 123 , ' v=' , x ( i + 1 ) write ( * , * ) 'vj(1)=' , this % v ( 1 ), ' vj(i0)=' , this % v ( this % i0 ) pause stop end if call linf ( this % v , this % f , x ( i + 1 ), y ( i ), klo , khi ) end do ybeg = this % f ( 1 ) !boundary conditions yend = this % f ( this % i0 ) !zero !print *, ' yend =', yend !!!!!!!!!!!!   solve problem   !!!!!!!!!!!!!!!!!!!!!!!!!! call savelyev_solver ( this % alfa2 , nt , this % h , dt , this % n , ybeg , yend , this % d1 , this % d2 , this % d3 , y ) !call teplova_khavin_solver(this%alfa2, nt, this%h, dt, this%n, ybeg, yend, this%d1,this%d2,this%d3, y) allocate ( fj ( this % n + 2 )) fj ( 1 ) = ybeg fj ( this % n + 2 ) = yend do i = 1 , this % n fj ( i + 1 ) = y ( i ) end do do i = 2 , this % i0 - 1 if ( this % v ( i ). lt . this % v_lim ) then call lock ( x , this % n + 2 , this % v ( i ), klo , khi , ierr ) if ( ierr . eq . 1 ) then write ( * , * ) 'lock error #2 in finction fokkerplanck' write ( * , * ) 'j=' , 123 , ' vij=' , this % v ( i ) write ( * , * ) 'x(1)=' , x ( 1 ), ' x(n+2)=' , x ( this % n + 2 ) pause stop end if call linf ( x , fj , this % v ( i ), this % f ( i ), klo , khi ) else this % f ( i ) = zero end if end do deallocate ( fj ) !if (present(dfj0)) then !    call burying_procedure(vj, fj0, dfj0) !else !    call burying_procedure(vj, fj0) !end if end subroutine FokkerPlanck1D_solve_time_step subroutine burying_procedure ( v , f0 , df0 ) ! процедура закапывания implicit none real * 8 , intent ( in ) :: v (:) real * 8 , intent ( inout ) :: f0 (:) real * 8 , intent ( inout ), optional :: df0 (:) integer i , ii , i0 , ibeg real * 8 , allocatable :: f (:), df (:) real * 8 fout1 , fout2 i0 = size ( f0 ) allocate ( f ( i0 ), df ( i0 )) f (:) = f0 (:) df (:) = 0 d0 do i = 2 , i0 - 1 df ( i ) = 0.5d0 * ( f ( i + 1 ) - f ( i - 1 )) / v ( 2 ) end do df ( 1 ) = 0 d0 df ( i0 ) = ( f ( i0 ) - f ( i0 - 1 )) / v ( 2 ) !   сдвиг расределения вправо. зачем-то ??? ii = 0 ibeg = 0 do i = i0 - 1 , 1 , - 1 if ( df ( i ). gt . 0 d0 ) then !          write(*,*) '#1 positive derivs' !          write(*,*) '#1 df>0: i,j,k=',i,j,k !          write(*,*) '#1 dfj(i),i,j,k=',dfj(i),i,j,k !          write(*,*) f0 ( i ) = f0 ( i + 1 ) if ( present ( df0 )) then df0 ( i ) = df0 ( i + 1 ) end if ii = i end if if ( f0 ( i ). lt . f0 ( i + 1 )) then f0 ( i ) = f0 ( i + 1 ) if ( present ( df0 )) then df0 ( i ) = df0 ( i + 1 ) end if ii = i end if end do if ( ibeg . gt . 0 ) then call integral ( ibeg , i0 , v , f , fout1 ) f (:) = f0 (:) if ( present ( df0 )) then df (:) = df0 (:) end if call integral ( ibeg , i0 , v , f , fout2 ) f0 ( ibeg : i0 ) = f ( ibeg : i0 ) * fout1 / fout2 if ( present ( df0 )) then df0 ( ibeg : i0 ) = df ( ibeg : i0 ) * fout1 / fout2 end if !!      write(*,*)'#1 j,k,ibeg=',j,k,ibeg !!      write(*,*)'#1 v(ibeg)=',vj(ibeg),' f1/f2=',fout1/fout2 end if deallocate ( f , df ) ibeg = ii end subroutine end module FokkerPlanck1D_mod","tags":"","loc":"sourcefile\\2_fokkerplanck1d.f90.html"},{"title":"2_maxwell.f90 – FRTS project","text":"Contents Modules maxwell Source Code 2_maxwell.f90 Source Code module maxwell use kind_module use constants , only : zero implicit none integer , parameter :: i0 = 1002 real ( wp ) vij ( i0 , 100 ), fij0 ( i0 , 100 , 2 ), fij ( i0 , 100 , 2 ) real ( wp ) dfij ( i0 , 100 , 2 ), dij ( i0 , 100 , 2 ) contains subroutine init_vi ( vclt , vi ) real ( wp ), intent ( in ) :: vclt real ( wp ), intent ( out ) :: vi ( i0 ) real ( wp ) vmax integer i vmax = 2.d0 * vclt do i = 1 , i0 vi ( i ) = dble ( i - 1 ) * vmax / dble ( i0 - 1 ) end do end subroutine subroutine init_fmaxw_classic ( vclt , enorm , fi , dfi ) real ( wp ), intent ( in ) :: vclt , enorm real ( wp ), intent ( out ) :: fi ( i0 ), dfi ( i0 ) real ( wp ) vi , vmax integer i vmax = 2.d0 * vclt do i = 1 , i0 vi = dble ( i - 1 ) * vmax / dble ( i0 - 1 ) if ( vi < vclt ) then fi ( i ) = fmaxw_classic ( vi , enorm , dfi ( i )) else fi ( i ) = zero dfi ( i ) = zero end if end do end subroutine subroutine init_fmaxw_ext ( vclt , enorm , fi , dfi ) real ( wp ), intent ( in ) :: vclt , enorm real ( wp ), intent ( out ) :: fi ( i0 ), dfi ( i0 ) real ( wp ) vi , vmax integer i vmax = 2.d0 * vclt do i = 1 , i0 vi = dble ( i - 1 ) * vmax / dble ( i0 - 1 ) if ( vi < vclt ) then fi ( i ) = fmaxw_ext ( vi , enorm , dfi ( i )) else fi ( i ) = zero dfi ( i ) = zero end if end do end subroutine double precision function funmaxwell ( v , dfunmaxwell ) implicit none real ( wp ) v , dfunmaxwell , arg , pi2sqrt parameter ( pi2sqrt = 2.506628274631d0 ) arg =- 0.5d0 * v ** 2 funmaxwell = dexp ( arg ) / pi2sqrt dfunmaxwell =- v * funmaxwell end double precision function fmaxw_classic ( v , alfa2 , dfmaxw ) implicit none real ( wp ) v , alfa2 , dfmaxw real ( wp ) arg , alfa , api , b , psiq , f , df real ( wp ) pi2sqrt , pisqrt , zero parameter ( pi2sqrt = 2.506628274631d0 , pisqrt = 1.77245385090552d0 ) parameter ( zero = 0.d0 ) arg =- 0.5d0 * v ** 2 * ( 1.d0 + 0.5d0 * alfa2 * v ** 2 ) fmaxw_classic = dexp ( arg ) / pi2sqrt dfmaxw =- v * ( 1.d0 + alfa2 * v ** 2 ) * fmaxw_classic end double precision function fmaxw_ext ( v , alfa2 , dfmaxw ) implicit none real ( wp ) v , alfa2 , dfmaxw real ( wp ) arg , alfa , api , b , f , df real ( wp ) pi2sqrt , pisqrt , zero parameter ( pi2sqrt = 2.506628274631d0 , pisqrt = 1.77245385090552d0 ) parameter ( zero = 0.d0 ) alfa = dsqrt ( alfa2 ) api = 2.d0 * alfa * dexp ( - 0.25d0 / alfa2 ) / pisqrt b = 2.d0 - erfcc ( 0.5d0 / alfa ) + api f = psiq ( v , alfa2 ) fmaxw_ext = ( f + api ) / b / pi2sqrt df =- v * (( 1.d0 - alfa2 * v ** 2 ) * f + api ) dfmaxw = df / b / pi2sqrt end double precision function fmaxw ( v , alfa2 , dfmaxw ) implicit none real ( wp ) v , alfa2 , dfmaxw real ( wp ) arg , alfa , api , b , f , df real ( wp ) pi2sqrt , pisqrt , zero parameter ( pi2sqrt = 2.506628274631d0 , pisqrt = 1.77245385090552d0 ) parameter ( zero = 0.d0 ) if ( alfa2 . le . zero ) then arg =- 0.5d0 * v ** 2 * ( 1.d0 - 0.5d0 * alfa2 * v ** 2 ) fmaxw = dexp ( arg ) / pi2sqrt dfmaxw =- v * ( 1.d0 - alfa2 * v ** 2 ) * fmaxw else alfa = dsqrt ( alfa2 ) api = 2.d0 * alfa * dexp ( - 0.25d0 / alfa2 ) / pisqrt b = 2.d0 - erfcc ( 0.5d0 / alfa ) + api f = psiq ( v , alfa2 ) fmaxw = ( f + api ) / b / pi2sqrt df =- v * (( 1.d0 - alfa2 * v ** 2 ) * f + api ) dfmaxw = df / b / pi2sqrt end if end double precision function psiq ( v , alfa2 ) !!! psiq=exp(ksiV**2)*erfcc(ksiV)*exp(-0.25/alfa2) implicit none double precision v , alfa2 , df double precision x , t , z , f , asymp , alfa , q , u double precision zero , zmax , pisqrt parameter ( zero = 0.d0 , zmax = 1 0.d0 , pisqrt = 1.77245385090552d0 ) alfa = dsqrt ( alfa2 ) q =- 0.25d0 / alfa2 x = 0.5d0 * ( alfa * v ** 2 - 1.d0 / alfa ) z = abs ( x ) if ( z . gt . zmax ) then !asymptotics f = dexp ( q ) * ( 1.d0 - 0.5d0 / z ** 2 + 0.75d0 / z ** 4 - 1 5.d0 / 8.d0 / z ** 6 ) / z / pisqrt else t = 1.d0 / ( 1.d0 + 0.5d0 * z ) f = t * exp ( q - 1.26551223d0 + t * ( 1.00002368d0 + t * (. 37409196 d0 + t * & &(. 09678418 d0 + t * ( - . 18628806 d0 + t * (. 27886807 d0 + t * ( - 1.13520398d0 + t * & &( 1.48851587d0 + t * ( - . 82215223 d0 + t * . 17087277 d0 ))))))))) end if if ( x . lt . zero ) then u =- 0.5d0 * v ** 2 + 0.25d0 * alfa2 * v ** 4 !u=x**2-0.25d0/alfa2 f = 2.d0 * dexp ( u ) - f end if psiq = f return end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! function erfcc ( x ) implicit none double precision erfcc , x double precision t , z , zero , zmax , pisqrt parameter ( zero = 0.d0 , zmax = 1 0.d0 , pisqrt = 1.77245385090552d0 ) z = abs ( x ) if ( z . gt . zmax ) then !asymptotics erfcc = ( 1.d0 - 0.5d0 / z ** 2 + 0.75d0 / z ** 4 - 1 5.d0 / 8.d0 / z ** 6 ) / z / pisqrt erfcc = exp ( - z * z ) * erfcc else t = 1.d0 / ( 1.d0 + 0.5d0 * z ) erfcc = t * exp ( - z * z - 1.26551223d0 + t * ( 1.00002368d0 + t * (. 37409196 d0 + t * & &(. 09678418 d0 + t * ( - . 18628806 d0 + t * (. 27886807 d0 + t * ( - 1.13520398d0 + t * & &( 1.48851587d0 + t * ( - . 82215223 d0 + t * . 17087277 d0 ))))))))) end if if ( x . lt . zero ) erfcc = 2.d0 - erfcc return end end module maxwell","tags":"","loc":"sourcefile\\2_maxwell.f90.html"},{"title":"2_plasma.f90 – FRTS project","text":"Contents Modules plasma Source Code 2_plasma.f90 Source Code module plasma use kind_module implicit none integer ngrid , nspl !! ASTRA radial grid number real ( wp ) tcur !! время (придумать название для переменной получше) real ( wp ) rm !! minor radius in mid-plane, cm real ( wp ) b_tor0 , b_tor !! временно нужно две переменных, тоже нужно исправить real ( wp ) r0 real ( wp ) z0 real ( wp ) rh1 real ( wp ), dimension (:), allocatable :: con , tem , temi , zeff , afld real ( wp ), dimension (:), allocatable :: rh , rha , drhodr , delta , ell , gamm , amy real ( wp ) tet1 , tet2 !! бывший common /a0a2/ real ( wp ) xmi , cnye , cnyi , xsz , vt0 ! common /a0ef3/ xmi,cnye,cnyi,xsz,vt0 real ( wp ) cnstvc real ( wp ) ww ! common /a0ef2/ ww real ( wp ) cltn ! common /a0ef1/ cltn real ( wp ) vperp ( 50 , 100 ), cnstal , zza , zze , valfa !,kv !common /a0i5/ vperp(50,100),cnstal,zza,zze,valfa!,kv real ( wp ) vpmax real ( wp ) vk ( 100 ), sk ( 100 ) !common /a0i2/ vk(100) integer , parameter :: ipsy = 5 , ncoef = 5 !!   ipsy = number of polinomial decomposition coefficients !!   used for interpolation of Zakharov's moments. real ( wp ), dimension ( ipsy ) :: cdl , cly , cgm , cmy , coeffs real ( wp ) y2dn ( 501 ), y2tm ( 501 ), y2tmi ( 501 ) !! бывший common /a0l3/ real ( wp ) y2zeff ( 501 ) !! бывший common /a0l5/ integer ncheb real ( wp ) chebne ( 50 ), chebdne ( 50 ), chebddne ( 50 ) !! бывший common/ne_cheb real ( wp ) enorm ( 100 ), fst ( 100 ) !! em поле и еще что-то contains subroutine init_plasma ( NA1 , ABC , BTOR , RTOR , UPDWN , GP2 , AMETR , RHO , SHIF , ELON , TRIA , MU , NE , TE , TI , ZEF , UPL ) use constants use approximation use rt_parameters use spline use chebyshev implicit none integer , intent ( in ) :: NA1 real ( wp ), intent ( in ) :: ABC , BTOR , RTOR , UPDWN , GP2 real ( wp ), dimension ( * ) :: AMETR , RHO , SHIF , ELON , TRIA , MU , NE , TE , TI , ZEF , UPL integer i , k integer , parameter :: N = 501 real ( wp ) :: znak_tor , znak_pol , fpol , dfmy ngrid = NA1 nspl = ngrid if (. not . allocated ( rh )) then allocate ( rh ( N ), rha ( N ), drhodr ( N ), con ( N ), tem ( N )) allocate ( temi ( N ), zeff ( N ), afld ( N )) allocate ( delta ( N ), ell ( N ), gamm ( N ), amy ( N )) end if do i = 1 , ngrid rh ( i ) = AMETR ( i ) / ABC rha ( i ) = RHO ( i ) / ABC !/ABC instead of /ROC is not a mistake! delta ( i ) = ( SHIF ( 1 ) - SHIF ( i )) / ABC !FRTC Shafr. shift. defin. ell ( i ) = ELON ( i ) gamm ( i ) = rh ( i ) * TRIA ( i ) con ( i ) = NE ( i ) tem ( i ) = TE ( i ) temi ( i ) = TI ( i ) zeff ( i ) = ZEF ( i ) afld ( i ) = UPL ( i ) / RTOR / GP2 !!variant end do !rh(ngrid)=1.d0 rh1 = rh ( 1 ) !saving the first ASTRA radial grid element rh ( 1 ) = 0.0d0 !shifting the first element to zero rha ( 1 ) = 0.0d0 !shifting the first element to zero delta ( 1 ) = 0.0d0 !putting delta(rh=0.)=0. gamm ( 1 ) = 0.0d0 !putting gamm(rh=0.)=0. b_tor0 = 1.d4 * BTOR * RTOR / ( RTOR + SHIF ( 1 )) !B_tor_(magnetic axis), Gauss rm = 1.d2 * ABC !minor radius in mid-plane, cm r0 = 1.d2 * ( RTOR + SHIF ( 1 )) !x-coordinate of the magnetic axis, cm z0 = 1.d2 * UPDWN !z-coordinate of the magnetic axis, cm !   spline approximation of plasma profiles ! !   shift as a function of \"minor radius\": call approx ( rh , delta , ngrid , polin1 , ipsy - 1 , coeffs ) cdl ( 1 ) = 0.0d0 do k = 2 , ipsy cdl ( k ) = coeffs ( k - 1 ) end do !   triangularity as a function of \"minor radius\": call approx ( rh , gamm , ngrid , polin1 , ipsy - 1 , coeffs ) cgm ( 1 ) = 0.0d0 do k = 2 , ipsy cgm ( k ) = coeffs ( k - 1 ) end do !   ellipticity as a function of \"minor radius\": call approx ( rh , ell , ngrid , polin , ipsy , cly ) !  \"poloidal magnetic field\": call diff ( rh , rha , ngrid , drhodr ) do i = 2 , ngrid amy ( i ) = 1.d4 * BTOR * MU ( i ) * rha ( i ) * drhodr ( i ) !print *, amy(i), BTOR, MU(i) end do !print *, '----------------' amy ( 1 ) = 0.d0 !! amy=(btor/q)*rho*(drho/dr) is a function of \"minor radius\" r=rh(i). !! Poloidal magnetic field: B_pol=amy(r)*sqrt(g22/g), where g is !! determinant of 3D metric tensor and g22 is the (22) element of !! the tensor, normalized on ABC&#94;4 and ABC&#94;2, correspondingly. !! !!  Polinomial approximation of the amy(r): !    inpt2=ngrid-3 call approx ( rh , amy , ngrid - 3 , polin1 , ipsy - 1 , coeffs ) cmy ( 1 ) = 0.d0 do k = 2 , ipsy cmy ( k ) = coeffs ( k - 1 ) end do ! зачем-то меняет знак коэффициентов???? znak_tor = dsign ( 1.d0 , dble ( itor )) b_tor = znak_tor * dabs ( b_tor0 ) fpol = fdf ( 1.d0 , cmy , ncoef , dfmy ) znak_pol = dsign ( 1.d0 , dble ( i_pol )) * dsign ( 1.d0 , fpol ) do i = 1 , ncoef cmy ( i ) = znak_pol * cmy ( i ) end do !!!!!!!!!!!!!!! spline approximation of plasma profiles !!!!!!!!!!!!!!!! call splne ( rh , con , nspl , y2dn ) call splne ( rh , tem , nspl , y2tm ) call splne ( rh , zeff , nspl , y2zeff ) call splne ( rh , temi , nspl , y2tmi ) if ( inew . ne . 0 ) then ncheb = 20 call chebft1 ( zero , 1.d0 , chebne , ncheb , fn ) call chder ( zero , 1.d0 , chebne , chebdne , ncheb ) call chder ( zero , 1.d0 , chebdne , chebddne , ncheb ) end if call init_parameters call find_volums_and_surfaces end subroutine subroutine init_parameters use constants use approximation use rt_parameters implicit none real ( wp ) :: xly , xlyp , arg1 , arg2 real ( wp ) :: hr , dn1 , dn2 , dn3 , sss !!! xly = fdf ( one , cly , ncoef , xlyp ) arg1 = ( zplus - z0 ) / ( xly * rm ) arg2 = ( zminus - z0 ) / ( xly * rm ) if ( dabs ( arg1 ). lt . 1.d0 ) then tet1 = dasin ( arg1 ) ! upper grill corner poloidal coordinate else tet1 = 0.5d0 * pi ! upper grill corner poloidal coordinate end if if ( dabs ( arg2 ). lt . 1.d0 ) then tet2 = dasin ( arg2 ) ! lower grill corner poloidal coordinate else tet2 =- 0.5d0 * pi ! lower grill corner poloidal coordinate end if !------------------------------------------------------------ ! calculate constants !--------------------------------------- hr = 1.d0 / dble ( nr + 1 ) dn1 = 1 d0 / ( zi1 + dni2 * zi2 + dni3 * zi3 ) dn2 = dni2 * dn1 dn3 = dni3 * dn1 sss = zi1 ** 2 * dn1 / xmi1 + zi2 ** 2 * dn2 / xmi2 + zi3 ** 2 * dn3 / xmi3 xmi = 183 6.d0 / sss cnstvc = (. 75 d0 * piq * sss / 183 6.d0 ) ** one_third ww = freq * pi2 * 1.0d+09 cnye = xlog / pi4 cnyi = dsqrt ( 2 d0 ) / ( 3 d0 * piq ) !%for Vt=sqrt(Te/m) vt0 = fvt ( zero ) !!!!!!!!      ptkev=ft(zero)/0.16d-8  !Te in keV cltn = clt / vt0 xsz = clt / ww / rm !ccur=pqe*vt0*0.333d-9 !!      ccurnr=pqe*pqe*0.333d-9/pme rrange = rrange * hr !ToDo если вызывается несколько раз то будут проблемы valfa = 1.d9 * dsqrt ( 1.91582d0 * talfa / xmalfa ) !  valfa (cgs units) = birth velocity zza = cnst1 * ( zalfa / xmalfa / valfa ) ** 2 * ( clt / valfa ) ** 3 / pi zze = cnst2 * 2.d9 * freq cnstal = ( dsqrt ( cnst1 ) / xmalfa / pi ) * ( zalfa * vt0 / valfa ) ** 2 * clt / valfa vpmax = dsqrt ( energy / talfa ) !  \"vpmax\" in valfa velocity units ! end subroutine subroutine find_volums_and_surfaces use constants use rt_parameters implicit none integer j real ( wp ) hr , rxx , vk0 , sk0 !-------------------------------------------------------- ! find volums and surfaces !-------------------------------------------------------- hr = 1.d0 / dble ( nr + 1 ) vk0 = pi2 * hr * rm ** 3 sk0 = hr * rm ** 2 do j = 1 , nr rxx = hr * dble ( j ) vk ( j ) = vk0 * gaussint ( obeom , zero , pi2 , rxx , eps ) sk ( j ) = sk0 * gaussint ( ploshad , zero , pi2 , rxx , eps ) end do end subroutine real ( wp ) function fn ( x ) !! plasma  density,  cm&#94;-3 use constants , only : zero use spline real ( wp ), intent ( in ) :: x real ( wp ) :: pa , r , y , dy real ( wp ), parameter :: alfa = 4.d0 , dr = . 02 d0 pa = dabs ( x ) if ( pa . le . rh ( nspl )) then call splnt ( rh , con , y2dn , nspl , pa , y , dy ) else r = pa - rh ( nspl ) y = con ( nspl ) * dexp ( - alfa * ( r / dr ) ** 2 ) end if fn = y * 1.d+13 !cm&#94;-3 end real ( wp ) function fvt ( r ) !! нет описания real ( wp ), intent ( in ) :: r real ( wp ) :: pt pt = ft ( r ) fvt = sqrt ( pt / 9.11d-28 ) end real ( wp ) function fn1 ( x , fnp ) !! plasma density and its derivative use constants , only : zero use spline real ( wp ), intent ( in ) :: x real ( wp ), intent ( out ) :: fnp real ( wp ) :: r , pa , y1 , y , s , dy , dy1 real ( wp ), parameter :: alfa = 4.d0 , dr = . 02 d0 pa = abs ( x ) if ( pa . le . rh ( nspl )) then call splnt ( rh , con , y2dn , nspl , pa , y , dy ) else call splnt ( rh , con , y2dn , nspl , rh ( nspl ), y1 , dy1 ) r = pa - rh ( nspl ) y = rh ( nspl ) * exp ( - alfa * ( r / dr ) ** 2 ) dy =- 2.d0 * alfa * y * r / dr ** 2 !corrected end if fn1 = y * 1.d+13 !cm&#94;-3 fnp = dy * 1.d+13 end real ( wp ) function fn2 ( r , fnp , fnpp ) !! plasma density and its first and second derivatives use constants , only : zero use chebyshev real ( wp ), intent ( in ) :: r real ( wp ), intent ( out ) :: fnp , fnpp real ( wp ) :: x , y1 , y , s , dy , ddy real ( wp ), parameter :: alfa = 4.d0 , dr = . 02 d0 x = abs ( r ) if ( x . le . 1.d0 ) then y = chebev ( zero , 1.d0 , chebne , ncheb , x ) dy = chebev ( zero , 1.d0 , chebdne , ncheb , x ) ddy = chebev ( zero , 1.d0 , chebddne , ncheb , x ) else y1 = chebev ( zero , 1.d0 , chebne , ncheb , 1.d0 ) s = x - 1.d0 y = y1 * exp ( - alfa * ( s / dr ) ** 2 ) dy =- 2.d0 * alfa * y * s / dr ** 2 ddy =- 2.d0 * alfa * y * ( 1.d0 - 2.d0 * alfa * ( s / dr ) ** 2 ) / dr ** 2 end if fn2 = y !cm&#94;-3 fnp = dy fnpp = ddy end real ( wp ) function ft ( x ) !! electron temperature, erg use constants , only : zero use spline real ( wp ), intent ( in ) :: x real ( wp ) :: pa , r , y , dy real ( wp ), parameter :: alfa = 4.d0 , dr = . 02 d0 pa = abs ( x ) !#@sav if ( pa . le . rh ( nspl )) then call splnt ( rh , tem , y2tm , nspl , pa , y , dy ) else r = pa - rh ( nspl ) y = tem ( nspl ) * exp ( - alfa * ( r / dr ) ** 2 ) end if !!      ft=y            ! kev ft = y * 0.16d-8 ! erg end real ( wp ) function fti ( x ) !! ion temperature, kev use constants , only : zero use spline real ( wp ), intent ( in ) :: x real ( wp ) :: pa , r , y , dy real ( wp ), parameter :: alfa = 4.d0 , dr = . 02 d0 pa = abs ( x ) !#@sav if ( pa . le . rh ( nspl )) then call splnt ( rh , temi , y2tmi , nspl , pa , y , dy ) else r = pa - rh ( nspl ) y = temi ( nspl ) * exp ( - alfa * ( r / dr ) ** 2 ) end if fti = y ! kev end real ( wp ) function zefff ( x ) !! z_effective profile use constants , only : zero use spline real ( wp ), intent ( in ) :: x real ( wp ) :: pa , r , y , dy real ( wp ), parameter :: alfa = 4.d0 , dr = . 02 d0 pa = abs ( x ) !#@sav if ( pa . le . rh ( nspl )) then call splnt ( rh , zeff , y2zeff , nspl , pa , y , dy ) else r = pa - rh ( nspl ) y = zeff ( nspl ) * exp ( - alfa * ( r / dr ) ** 2 ) end if zefff = y end subroutine calc_enorm use constants use rt_parameters , only : nr , inew use spline use maxwell implicit none integer j , klo , khi , ierr real ( wp ) :: efld real ( wp ) :: r , pn , vt , tmp , xlogj , vmax real ( wp ) :: fnr , fnrr , dens !real*8 fn1,fn2 do j = 1 , nr r = dble ( j ) / dble ( nr + 1 ) call lock ( rh , nspl , r , klo , khi , ierr ) if ( ierr . eq . 1 ) then write ( * , * ) 'lock error in saveprofiles, Efield' write ( * , * ) 'j=' , j , ' rh(j)=' , rh ( j ), ' r=' , r pause stop end if call linf ( rh , afld , r , efld , klo , khi ) if ( inew . eq . 0 ) then !vardens pn = fn1 ( r , fnr ) else pn = fn2 ( r , fnr , fnrr ) end if vt = fvt ( r ) tmp = ft ( r ) / 0.16d-8 !Te,  KeV dens = pn / 1.d+13 !10&#94;13 cm&#94;-3 xlogj = dlog ( 5.1527d7 * tmp * 1 6.d0 * dsqrt ( tmp ) / dsqrt ( dens )) enorm ( j ) = ( 3.835d0 / xlogj ) * efld * tmp / dens enorm ( j ) = enorm ( j ) * 5.d0 / ( 5.d0 + zefff ( r )) !!fst(j)=pn*xlogj*c0**4/pi4/vt**3 fst ( j ) = (( 5.d0 + zefff ( r )) / 5.d0 ) * pn * xlogj * c0 ** 4 / pi4 / vt ** 3 end do end subroutine subroutine init_maxwell use constants use rt_parameters , only : nr , inew use spline use maxwell implicit none integer j real ( wp ) r , vclt do j = 1 , nr r = dble ( j ) / dble ( nr + 1 ) vclt = 3.d10 / fvt ( r ) !print *, vclt call init_vi ( vclt , vij (:, j )) call init_fmaxw_classic ( vclt , enorm ( j ), fij (:, j , 1 ), dfij (:, j , 1 )) call init_fmaxw_ext ( vclt , enorm ( j ), fij (:, j , 2 ), dfij (:, j , 2 )) end do fij0 (:,:,:) = fij (:,:,:) dij (:,:,:) = zero end subroutine real ( wp ) function obeom ( ptet , pa ) use constants use approximation implicit real * 8 ( a - h , o - z ) !common /a0befr/ pi,pi2 !common /a0ef1/ cltn !common /a0k/ cdl(10),cly(10),cgm(10),cmy(10),ncoef parameter ( pa0 = 0.d0 ) xdl = fdf ( pa , cdl , ncoef , xdlp ) xly = fdf ( pa , cly , ncoef , xlyp ) xgm = fdf ( pa , cgm , ncoef , xgmp ) xlyv = xlyp * pa + xly cotet = dcos ( ptet ) sitet = dsin ( ptet ) dxdr =- xdlp + cotet - xgmp * sitet ** 2 dxdt =- ( pa + two * xgm * cotet ) * sitet dzdr = xlyv * sitet dzdt = xly * pa * cotet x0 = r0 / rm - xdl + pa * cotet - xgm * sitet ** 2 dxdrdt =- sitet - two * xgmp * sitet * cotet dzdrdt = xlyv * cotet dxdtdt =- pa * cotet - two * xgm * ( cotet ** 2 - sitet ** 2 ) dzdtdt =- xly * pa * sitet x0t = dxdt !-------------------------------------- ! components of metric tensor !-------------------------------------- g11 = dxdr ** 2 + dzdr ** 2 g22 = dxdt ** 2 + dzdt ** 2 g12 = dxdr * dxdt + dzdr * dzdt g33 = x0 ** 2 xj = ( dzdr * dxdt - dxdr * dzdt ) ** 2 !gg=g11*g22-g12*g12 g = xj * g33 obeom = dsqrt ( g ) end real ( wp ) function ploshad ( ptet , pa ) use constants use approximation implicit real * 8 ( a - h , o - z ) !common /a0befr/ pi,pi2 !common /a0ef1/ cltn !common /a0k/ cdl(10),cly(10),cgm(10),cmy(10),ncoef parameter ( pa0 = 0.d0 ) xdl = fdf ( pa , cdl , ncoef , xdlp ) xly = fdf ( pa , cly , ncoef , xlyp ) xgm = fdf ( pa , cgm , ncoef , xgmp ) xlyv = xlyp * pa + xly cotet = dcos ( ptet ) sitet = dsin ( ptet ) dxdr =- xdlp + cotet - xgmp * sitet ** 2 dxdt =- ( pa + two * xgm * cotet ) * sitet dzdr = xlyv * sitet dzdt = xly * pa * cotet x0 = r0 / rm - xdl + pa * cotet - xgm * sitet ** 2 dxdrdt =- sitet - two * xgmp * sitet * cotet dzdrdt = xlyv * cotet dxdtdt =- pa * cotet - two * xgm * ( cotet ** 2 - sitet ** 2 ) dzdtdt =- xly * pa * sitet x0t = dxdt !-------------------------------------- ! components of metric tensor !-------------------------------------- g11 = dxdr ** 2 + dzdr ** 2 g22 = dxdt ** 2 + dzdt ** 2 g12 = dxdr * dxdt + dzdr * dzdt xj = ( dzdr * dxdt - dxdr * dzdt ) ** 2 !gg=g11*g22-g12*g12 ploshad = dsqrt ( xj ) end real ( wp ) function gaussint ( f , a , b , r , eps ) !! что-то про гаусс implicit none real ( wp ) w ( 12 ), x ( 12 ) real ( wp ) f , a , b , r , eps real ( wp ) aa , bb , c1 , c2 , s8 , s16 , u , y , delta integer i !!      save w,x,const !sav# real ( wp ), parameter :: const = 1.0d-12 data w & / 0.101228536290376 , 0.222381034453374 , 0.313706645877887 , & 0.362683783378362 , 0.027152459411754 , 0.062253523938648 , & 0.095158511682493 , 0.124628971255534 , 0.149595988816577 , & 0.169156519395003 , 0.182603415044924 , 0.189450610455069 / data x & / 0.960289856497536 , 0.796666477413627 , 0.525532409916329 , & 0.183434642495650 , 0.989400934991650 , 0.944575023073233 , & 0.865631202387832 , 0.755404408355003 , 0.617876244402644 , & 0.458016777657227 , 0.281603550779259 , 0.095012509837637 / delta = const * dabs ( a - b ) gaussint = 0 d0 aa = a 5 y = b - aa if ( dabs ( y ). le . delta ) return 2 bb = aa + y c1 = 0.5d0 * ( aa + bb ) c2 = c1 - aa s8 = 0 d0 s16 = 0 d0 do i = 1 , 4 u = x ( i ) * c2 s8 = s8 + w ( i ) * ( f ( c1 + u , r ) + f ( c1 - u , r )) end do do i = 5 , 12 u = x ( i ) * c2 s16 = s16 + w ( i ) * ( f ( c1 + u , r ) + f ( c1 - u , r )) end do s8 = s8 * c2 s16 = s16 * c2 if ( dabs ( s16 - s8 ) . gt . eps * ( 1 d0 + dabs ( s16 ))) go to 4 gaussint = gaussint + s16 aa = bb go to 5 4 y = 0.5d0 * y if ( dabs ( y ) . gt . delta ) go to 2 write ( * , 7 ) gaussint = 0 d0 return 7 format ( 1 x , 'gaussint ... too high accuracy required' ) end end module plasma","tags":"","loc":"sourcefile\\2_plasma.f90.html"},{"title":"2_spectrum.f90 – FRTS project","text":"Contents Modules spectrum_mod spectrum1D Source Code 2_spectrum.f90 Source Code module spectrum_mod use kind_module implicit none type spectrum_point real ( wp ) nz !! real ( wp ) ny !! real ( wp ) Ntor !! Ntau=-Ntor real ( wp ) Npol !! Ntet=Npol real ( wp ) power !! power contains end type spectrum_point type spectrum integer size !! size of spectrum real ( wp ) input_power !! power of spectrum real ( wp ) power_ratio !! доля входной мощности real ( wp ) max_power !! real ( wp ) sum_power !! суммарная power integer direction !! направление спектра   +1 или -1 или 0 - полный type ( spectrum_point ), allocatable :: data (:) !! contains procedure :: get_positive_part => get_positive_part_method procedure :: get_negative_part => get_negative_part_method procedure :: calc_max_power => calc_max_power_method end type spectrum interface spectrum module procedure :: spectrum_constructor !module procedure :: read_spectrum end interface spectrum contains function spectrum_constructor ( size ) result ( this ) !- конструктор для spectrum implicit none type ( spectrum ) :: this integer , value :: size this % size = size this % input_power = 0 this % sum_power = 0 allocate ( this % data ( size )) end function spectrum_constructor subroutine calc_max_power_method ( this ) use constants , only : xsgs use rt_parameters , only : ntet implicit none class ( spectrum ), intent ( inout ) :: this type ( spectrum_point ) :: p real ( wp ) max_power , pnorm integer i max_power = 0 pnorm = this % power_ratio * xsgs / ntet print * , 'pnorm =' , pnorm do i = 1 , this % size p = this % data ( i ) p % power = p % power * pnorm p % nz = this % direction * p % nz this % data ( i ) = p if ( p % power > max_power ) max_power = p % power end do this % max_power = max_power print * , 'this%max_power = ' , this % max_power end subroutine function get_positive_part_method ( this ) result ( spectr ) !! implicit none class ( spectrum ), intent ( in ) :: this type ( spectrum ) :: spectr , tmp_spectr type ( spectrum_point ) :: p integer i , n print * , 'read positive' tmp_spectr = spectrum ( this % size ) n = 0 do i = 1 , this % size p = this % data ( i ) if ( p % nz > 0 ) then n = n + 1 tmp_spectr % data ( n ) = p tmp_spectr % sum_power = tmp_spectr % sum_power + p % power end if end do tmp_spectr % size = n spectr = spectrum ( n ) spectr % sum_power = tmp_spectr % sum_power do i = 1 , n spectr % data ( i ) = tmp_spectr % data ( i ) end do spectr % size = n spectr % direction = + 1 spectr % power_ratio = spectr % sum_power / this % sum_power spectr % input_power = spectr % power_ratio * this % input_power print * , this % size , n print * , 'sum_power ' , this % sum_power , spectr % sum_power print * , 'power_ratio ' , this % power_ratio , spectr % power_ratio print * , 'input_power ' , this % input_power , spectr % input_power end function get_positive_part_method function get_negative_part_method ( this ) result ( spectr ) !! implicit none class ( spectrum ), intent ( in ) :: this type ( spectrum ) :: spectr , tmp_spectr type ( spectrum_point ) :: p integer i , n print * , 'negative positive' tmp_spectr = spectrum ( this % size ) n = 0 do i = 1 , this % size p = this % data ( i ) if ( p % nz < 0 ) then n = n + 1 p % nz = - p % nz tmp_spectr % data ( n ) = p tmp_spectr % sum_power = tmp_spectr % sum_power + p % power end if end do tmp_spectr % size = n spectr = spectrum ( n ) spectr % sum_power = tmp_spectr % sum_power do i = 1 , n spectr % data ( i ) = tmp_spectr % data ( n + 1 - i ) end do spectr % size = n spectr % direction = - 1 spectr % power_ratio = spectr % sum_power / this % sum_power spectr % input_power = spectr % power_ratio * this % input_power print * , this % size , n print * , 'sum_power ' , this % sum_power , spectr % sum_power print * , 'power_ratio ' , this % power_ratio , spectr % power_ratio print * , 'input_power ' , this % input_power , spectr % input_power end function get_negative_part_method function read_spectrum ( file_name ) result ( spectr ) !- чтение spectrum из файла implicit none type ( spectrum ) :: spectr character ( len = * ), value :: file_name logical :: res integer i , n , stat real ( wp ) sum_power !integer, value :: size print * , file_name ! Check if the file exists inquire ( file = trim ( file_name ), exist = res ) if (. not . res ) then print * , 'spectrum file not exists' stop end if open ( 20 , file = file_name ) n =- 1 stat = 0 do while ( stat == 0 ) n = n + 1 read ( 20 , * , iostat = stat ) enddo spectr % size = n spectr % input_power = 0 spectr % sum_power = 0 spectr % direction = 0 spectr % power_ratio = 1 sum_power = 0 allocate ( spectr % data ( n )) print * , 'Spectrum size = ' , n rewind ( 20 ) do i = 1 , n read ( 20 , * ) spectr % data ( i )% nz , spectr % data ( i )% ny , spectr % data ( i )% power sum_power = sum_power + spectr % data ( i )% power enddo !sum_power !do i=1,n !    spectr%data(i)%power = spectr%data(i)%power/sum_power !enddo spectr % sum_power = sum_power close ( 20 ) end function read_spectrum subroutine divide_spectrum ( spectr , pos_spectr , neg_spectr ) !! деление спектра на две части implicit none type ( spectrum ), intent ( in ) :: spectr type ( spectrum ), intent ( out ) :: pos_spectr , neg_spectr type ( spectrum ) :: tmp_spectr type ( spectrum_point ) :: p integer i , pos_n , neg_n pos_spectr = spectrum ( spectr % size ) tmp_spectr = spectrum ( spectr % size ) pos_n = 0 neg_n = 0 do i = 1 , spectr % size p = spectr % data ( i ) if ( p % nz > 0 ) then pos_n = pos_n + 1 pos_spectr % data ( pos_n ) = p pos_spectr % sum_power = pos_spectr % sum_power + p % power end if if ( p % nz < 0 ) then neg_n = neg_n + 1 p % nz = - p % nz tmp_spectr % data ( neg_n ) = p tmp_spectr % sum_power = tmp_spectr % sum_power + p % power endif end do pos_spectr % size = pos_n neg_spectr = spectrum ( neg_n ) neg_spectr % sum_power = tmp_spectr % sum_power do i = 1 , neg_n neg_spectr % data ( i ) = tmp_spectr % data ( neg_n + 1 - i ) end do neg_spectr % size = neg_n pos_spectr % direction = + 1 neg_spectr % direction = - 1 pos_spectr % power_ratio = pos_spectr % sum_power / spectr % sum_power neg_spectr % power_ratio = neg_spectr % sum_power / spectr % sum_power pos_spectr % input_power = pos_spectr % power_ratio * spectr % input_power neg_spectr % input_power = neg_spectr % power_ratio * spectr % input_power print * , pos_n , neg_n print * , 'sum_power ' , spectr % sum_power , pos_spectr % sum_power , neg_spectr % sum_power print * , 'power_ratio ' , pos_spectr % power_ratio , neg_spectr % power_ratio print * , 'input_power ' , spectr % input_power , pos_spectr % input_power , neg_spectr % input_power end subroutine function make_spline_approximation ( spectr ) result ( appx_spectr ) !! approximation of input LH spectrum use constants , only : zero , xsgs use spline use rt_parameters , only : nnz , ntet , pabs0 implicit none type ( spectrum ), intent ( in ) :: spectr type ( spectrum ) :: appx_spectr integer :: ispectr , ispl real ( wp ), allocatable :: ynzm0 (:), pm0 (:) real ( wp ), allocatable :: ynzm (:), pm (:) real ( wp ), allocatable :: yn2z (:), powinp (:) integer innz , i real ( wp ) dxx , xx0 , xx1 , xx2 , yy1 , yy2 , pinp real ( wp ) dpw , dpower , pwcurr , ptot , dynn real ( wp ) pmax , pnorm , plaun ispectr = spectr % direction plaun = spectr % input_power ispl = spectr % size allocate ( ynzm ( nnz ), pm ( nnz )) allocate ( ynzm0 ( ispl ), pm0 ( ispl )) allocate ( yn2z ( ispl ), powinp ( ispl )) do i = 1 , spectr % size ynzm0 ( i ) = spectr % data ( i )% nz pm0 ( i ) = spectr % data ( i )% power end do call splne ( ynzm0 , pm0 , ispl , yn2z ) innz = 100 * ispl dxx = ( ynzm0 ( ispl ) - ynzm0 ( 1 )) / innz xx2 = ynzm0 ( 1 ) yy2 = pm0 ( 1 ) pinp = 0 d0 do i = 1 , innz xx1 = xx2 yy1 = yy2 xx2 = xx1 + dxx call splnt ( ynzm0 , pm0 , yn2z , ispl , xx2 , yy2 , dynn ) dpw = . 5 d0 * ( yy2 + yy1 ) * ( xx2 - xx1 ) pinp = pinp + dpw end do dpower = pinp / dble ( nnz ) xx2 = ynzm0 ( 1 ) yy2 = pm0 ( 1 ) pwcurr = zero ptot = zero do i = 1 , nnz - 1 xx0 = xx2 11 continue xx1 = xx2 yy1 = yy2 xx2 = xx1 + dxx call splnt ( ynzm0 , pm0 , yn2z , ispl , xx2 , yy2 , dynn ) dpw = . 5 d0 * ( yy2 + yy1 ) * ( xx2 - xx1 ) if ( pwcurr + dpw . gt . dpower ) then xx2 = xx1 + dxx * ( dpower - pwcurr ) / dpw call splnt ( ynzm0 , pm0 , yn2z , ispl , xx2 , yy2 , dynn ) dpw = . 5 d0 * ( yy2 + yy1 ) * ( xx2 - xx1 ) pwcurr = pwcurr + dpw else pwcurr = pwcurr + dpw go to 11 end if ynzm ( i ) = . 5 d0 * ( xx2 + xx0 ) pm ( i ) = pwcurr ptot = ptot + pwcurr pwcurr = zero end do ynzm ( nnz ) = . 5 d0 * ( ynzm0 ( ispl ) + xx2 ) pm ( nnz ) = pinp - ptot pnorm = plaun * xsgs / ( pinp * ntet ) print * , 'pnorm =' , pnorm pmax =- 1 d + 10 do i = 1 , nnz call splnt ( ynzm0 , pm0 , yn2z , ispl , ynzm ( i ), powinp ( i ), dynn ) !pm(i)=pm(i)*pnorm if ( pm ( i ). gt . pmax ) pmax = pm ( i ) ynzm ( i ) = dble ( ispectr ) * ynzm ( i ) !sav2009 end do !pabs=pabs0*pmax/1.d2 appx_spectr = spectrum ( nnz ) do i = 1 , nnz appx_spectr % data ( i ) = spectrum_point ( nz = ynzm ( i ), ny = 0 , power = pm ( i ), Ntor = 0 , Npol = 0 ) end do appx_spectr % max_power = pmax appx_spectr % direction = ispectr appx_spectr % power_ratio = spectr % power_ratio end function end module spectrum_mod module spectrum1D use , intrinsic :: iso_fortran_env , only : sp => real32 , dp => real64 use spectrum_mod implicit none type ( spectrum ) :: full_spectrum type ( spectrum ) :: pos_spectr , neg_spectr integer :: ispl !! size of spectrum real ( wp ) :: plaun !! power of spectrum real ( wp ) :: ynzm0 ( 1001 ) !+ real ( wp ) :: pm0 ( 1001 ) !+ real ( wp ) :: ynzm ( 1001 ), pm ( 1001 ) !! бывший common /a0a1/ ynzm(1001),pm(1001) real ( wp ) :: pabs !! бывший common /a0gh/ pabs integer , parameter , private :: HEADER_LENGTH = 53 contains subroutine read_positive_spectrum ( file_name , p_in ) implicit none character ( * ) file_name real ( wp ) :: p_in integer , parameter :: iunit = 20 integer :: i , i1 real ( wp ) :: anz , apz open ( iunit , file = file_name ) do i = 1 , HEADER_LENGTH read ( iunit , * ) end do do i = 1 , 10000 read ( iunit , * ) anz , apz if ( apz . eq . - 8888 8.d0 ) then plaun = p_in * anz !input power in positive spectrum exit end if ynzm0 ( i ) = anz pm0 ( i ) = apz i1 = i end do close ( iunit ) ispl = i1 if ( ispl . gt . 4001 ) stop 'too many points in spectrum' end subroutine read_positive_spectrum subroutine read_negative_spectrum ( file_name , p_in ) implicit none character ( * ) file_name real ( wp ) :: p_in integer , parameter :: iunit = 20 integer :: i , i1 real ( wp ) :: anz , apz open ( iunit , file = file_name ) do i = 1 , HEADER_LENGTH read ( iunit , * ) end do apz = 0.d0 do while ( apz . ne . - 8888 8.d0 ) read ( iunit , * ) anz , apz end do read ( iunit , * ) plaun = p_in * ( 1.d0 - anz ) !input power in negative spectrum if ( plaun > 0.d0 ) then do i = 1 , 10000 read ( iunit , * , end = 10 ) ynzm0 ( i ), pm0 ( i ) i1 = i end do end if 10 close ( iunit ) ispl = i1 if ( ispl . gt . 4001 ) stop 'too many points in spectrum' end subroutine read_negative_spectrum subroutine spectrum_approximation ( ispectr ) !! approximation of input LH spectrum use constants , only : zero , xsgs use spline use rt_parameters , only : nnz , ntet , pabs0 implicit none integer , intent ( in ) :: ispectr real ( wp ) yn2z ( 1001 ), powinp ( 1001 ) integer innz , i real ( wp ) dxx , xx0 , xx1 , xx2 , yy1 , yy2 , pinp real ( wp ) dpw , dpower , pwcurr , ptot , dynn real ( wp ) pmax , pnorm call splne ( ynzm0 , pm0 , ispl , yn2z ) innz = 100 * ispl dxx = ( ynzm0 ( ispl ) - ynzm0 ( 1 )) / innz xx2 = ynzm0 ( 1 ) yy2 = pm0 ( 1 ) pinp = 0 d0 do i = 1 , innz xx1 = xx2 yy1 = yy2 xx2 = xx1 + dxx call splnt ( ynzm0 , pm0 , yn2z , ispl , xx2 , yy2 , dynn ) dpw = . 5 d0 * ( yy2 + yy1 ) * ( xx2 - xx1 ) pinp = pinp + dpw end do dpower = pinp / dble ( nnz ) xx2 = ynzm0 ( 1 ) yy2 = pm0 ( 1 ) pwcurr = zero ptot = zero do i = 1 , nnz - 1 xx0 = xx2 11 continue xx1 = xx2 yy1 = yy2 xx2 = xx1 + dxx call splnt ( ynzm0 , pm0 , yn2z , ispl , xx2 , yy2 , dynn ) dpw = . 5 d0 * ( yy2 + yy1 ) * ( xx2 - xx1 ) if ( pwcurr + dpw . gt . dpower ) then xx2 = xx1 + dxx * ( dpower - pwcurr ) / dpw call splnt ( ynzm0 , pm0 , yn2z , ispl , xx2 , yy2 , dynn ) dpw = . 5 d0 * ( yy2 + yy1 ) * ( xx2 - xx1 ) pwcurr = pwcurr + dpw else pwcurr = pwcurr + dpw go to 11 end if ynzm ( i ) = . 5 d0 * ( xx2 + xx0 ) pm ( i ) = pwcurr ptot = ptot + pwcurr pwcurr = zero end do ynzm ( nnz ) = . 5 d0 * ( ynzm0 ( ispl ) + xx2 ) pm ( nnz ) = pinp - ptot pnorm = plaun * xsgs / ( pinp * ntet ) pmax =- 1 d + 10 do i = 1 , nnz call splnt ( ynzm0 , pm0 , yn2z , ispl , ynzm ( i ), powinp ( i ), dynn ) pm ( i ) = pm ( i ) * pnorm if ( pm ( i ). gt . pmax ) pmax = pm ( i ) ynzm ( i ) = dble ( ispectr ) * ynzm ( i ) !sav2009 end do pabs = pabs0 * pmax / 1.d2 end subroutine subroutine copy_to_spectrum_1D ( spectr ) use spectrum_mod implicit none type ( spectrum ) :: spectr type ( spectrum_point ) :: p integer i do i = 1 , spectr % size p = spectr % data ( i ) ynzm0 ( i ) = p % nz pm0 ( i ) = p % power end do plaun = spectr % input_power ispl = spectr % size end subroutine function create_spectrum () result ( spectr ) use spectrum_mod use rt_parameters , only : nnz implicit none type ( spectrum ) :: spectr type ( spectrum_point ) :: p integer i real ( wp ) :: pmax pmax = 0 spectr = spectrum ( nnz ) do i = 1 , nnz p = spectrum_point ( nz = ynzm ( i ), ny = 0 , power = pm ( i ), Ntor = 0 , Npol = 0 ) if ( pm ( i ) > pmax ) pmax = pm ( i ) spectr % data ( i ) = p end do spectr % max_power = pmax end function subroutine write_spectrum ( ispectr ) implicit none integer , intent ( in ) :: ispectr !       call get_unit(iunit) !       if(iunit.eq.0) then !        write(*,*)'no free units up to 299' !        pause !        stop !       end if !       if(ispectr.eq.1) then !        open(iunit,file='lhcd/out/used_spectrP.dat') !       else if(ispectr.eq.-1) then !        open(iunit,file='lhcd/out/used_spectrM.dat') !       end if !       do i=1,nnz !        write(iunit,1008) ynzm(i),powinp(i) !       end do !       write(iunit,*) !      close(iunit) !1008   format (1x,10(e14.7,3x)) end subroutine end module spectrum1D","tags":"","loc":"sourcefile\\2_spectrum.f90.html"},{"title":"2_trajectory.f90 – FRTS project","text":"Contents Modules trajectory Source Code 2_trajectory.f90 Source Code module trajectory use kind_module implicit none integer , parameter :: length = 5000000 integer , parameter :: mpnt = 10000 integer nrefj ( mpnt ) !! common/refl/nrefj(mpnt) real ( wp ) dland ( length ), dcoll ( length ), perpn ( length ), dalf ( length ) real ( wp ) vel ( length ), jrad ( length ), iww ( length ), tetai ( length ) real ( wp ) xnpar ( length ), izz ( length ) !! бывший common/agh/xnpar,vel,dland,dcoll,dalf,perpn,tetai,jrad,iww,izz real ( wp ) mbeg ( mpnt ), mend ( mpnt ), mbad ( mpnt ), rbeg ( mpnt ) !sav2008 real ( wp ) tetbeg ( mpnt ), xnrbeg ( mpnt ), xmbeg ( mpnt ), yn3beg ( mpnt ) !! common/viewdat/mbeg,mend,mbad,rbeg,tetbeg,xnrbeg,xmbeg,yn3beg data mbad / mpnt * 0 / contains !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine view ( tview , iview , nnz , ntet ) !sav2008 !!!writing trajectories into a file use constants use approximation use plasma use rt_parameters , only : nr , itend0 , kv , nmaxm use spectrum1D , only : ynzm , pm implicit real ( wp ) ( a - h , o - z ) real ( wp ), intent ( in ) :: tview integer , intent ( in ) :: iview , nnz , ntet !sav# common / bcef / ynz , ynpopq common / vth / vthc ( length ), poloidn ( length ) real ( wp ) vthcg , npoli common / a0ghp / vlf , vrt , dflf , dfrt integer i , n , itr , ntraj integer jrc , nturn , ib , ie , jr , ifast , idir , iv integer jznak , jdlt , mn , mm , jchek , itet , inz integer , parameter :: unit_bias = 10 integer , parameter :: m = 7 real ( wp ), parameter :: pleft = 1.d-10 !m may be chaged together with name(m) real ( wp ) ptt ( m ), pll ( m ), pcc ( m ), paa ( m ) real ( wp ) pt_c ( m ), pl_c ( m ), pc_c ( m ), pa_c ( m ) character ( 40 ) fname character * 40 name ( m ) save name !sav# data name / 'lhcd/out/1.dat' , 'lhcd/out/2.dat' , 'lhcd/out/3.dat' , 'lhcd/out/4.dat' , 'lhcd/out/5.dat' , 'lhcd/out/rest.dat' , 'lhcd/out/traj.dat' / if ( iview . eq . 0 ) return print * , 'view_time=' , tview print * , name ( m ) write ( fname , '(\"lhcd/out/traj\", f17.15,\".dat\")' ) tview print * , fname name ( m ) = fname print * , name ( m ) htet = zero h = 1 d0 / dble ( nr + 1 ) if ( ntet . ne . 1 ) htet = ( tet2 - tet1 ) / ( ntet - 1 ) open ( 1 , file = 'lhcd/out/lcms.dat' ) write ( 1 , * ) '     R(m)            Z(m)' write ( 1 , * ) xr = 1.d0 xdl = fdf ( xr , cdl , ncoef , xdlp ) xly = fdf ( xr , cly , ncoef , xlyp ) xgm = fdf ( xr , cgm , ncoef , xgmp ) do i = 1 , 101 th = dble ( i - 1 ) * pi2 / dble ( 100 ) cotet = dcos ( th ) sitet = dsin ( th ) xx =- xdl + xr * cotet - xgm * sitet ** 2 zz = xr * xly * sitet x = ( r0 + rm * xx ) / 1 d2 z = ( z0 + rm * zz ) / 1 d2 write ( 1 , 5 ) x , z end do close ( 1 ) open ( 1 , file = 'lhcd/out/npar_crit.dat' ) write ( 1 , * ) '  Npar_crit=sqrt(50/Te(keV))' write ( 1 , * ) write ( 1 , * ) '   rho         Npar_strong absorption' write ( 1 , * ) do i = 1 , 101 xr = dble ( i - 1 ) / dble ( 100 ) tmp = ft ( xr ) / 0.16d-8 !Te,  KeV parn_c = dsqrt ( 50 d0 / tmp ) write ( 1 , 5 ) xr , parn_c end do close ( 1 ) do n = 1 , m open ( n + unit_bias , file = name ( n )) write ( n + unit_bias , * ) close ( n + unit_bias ) open ( n + unit_bias , file = name ( n )) write ( n + unit_bias , 3 ) write ( n + unit_bias , * ) ptt ( n ) = zero pll ( n ) = zero pcc ( n ) = zero paa ( n ) = zero end do ntraj = 0 !sav2008 do itr = 1 , nnz * ntet !sav2008 pow = 1.d0 pl = zero pc = zero pa = zero pdec1 = zero pdec1z = zero pdec3 = zero pdec3z = zero pdecv = zero pintld = zero pintal = zero jrc = nr + 1 jznak =- 1 nturn = 1 if ( mbad ( itr ). eq . 0 ) then ntraj = ntraj + 1 ib = mbeg ( itr ) ie = mend ( itr ) 10 continue do i = ib , ie v = vel ( i ) jr = jrad ( i ) refr = perpn ( i ) npoli = poloidn ( i ) ifast = iww ( i ) vthcg = vthc ( i ) idir = izz ( i ) dek3 = zero th = tetai ( i ) parn = xnpar ( i ) !         xn1=an1(i) !         xn2=an2(i) if ( itend0 . gt . 0 ) then argum = clt / ( refr * valfa ) dek3 = zatukh ( argum , abs ( jr ), vperp , kv ) end if ! old variant ! call raspr(v,abs(jr),iv,df) ! call distr ( v , abs ( jr ), iv , df ) if ( jr . lt . 0 ) then !case of turn jr =- jr !variant          pintld=-dland(i)*df !!          pintld=-dland(i)*(dflf+dfrt)/2d0 pintld = dabs ( dland ( i ) * ( dflf + dfrt ) / 2 d0 ) pdec2 = dexp ( - 2 d0 * dcoll ( i )) pintal = dabs ( dalf ( i ) * dek3 ) else pdec2 = dcoll ( i ) pdecv = dland ( i ) !!          pdec1=-pdecv*df pdec1 = dabs ( pdecv * df ) pdec3 = dabs ( dalf ( i ) * dek3 ) pintld = ( pdec1 + pdec1z ) / 2 d0 * h pintal = ( pdec3 + pdec3z ) / 2 d0 * h pdec1z = pdec1 pdec3z = pdec3 end if powpr = pow powd = pow * dexp ( - 2 d0 * pintld ) powcol = powd * pdec2 powal = powcol * dexp ( - 2 d0 * pintal ) pow = powal pil = pintld pic = . 5 d0 * dabs ( dlog ( pdec2 )) pia = pintal pt = 1.d0 - pow !total absorbed power denom = pil + pic + pia powdamped = 1.d0 - dexp ( - 2.d0 * denom ) domin = powpr * powdamped if ( denom . ne . zero ) then fff = domin / denom pl = pl + dabs ( pil * fff ) !el. Landau absorbed power pc = pc + dabs ( pic * fff ) !el. collisions absorbed power pa = pa + dabs ( pia * fff ) !alpha Landau absorbed power end if xr = h * dble ( jr ) cotet = dcos ( th ) sitet = dsin ( th ) xdl = fdf ( xr , cdl , ncoef , xdlp ) xly = fdf ( xr , cly , ncoef , xlyp ) xgm = fdf ( xr , cgm , ncoef , xgmp ) xx =- xdl + xr * cotet - xgm * sitet ** 2 zz = xr * xly * sitet x = ( r0 + rm * xx ) / 1 d2 z = ( z0 + rm * zz ) / 1 d2 jdlt = jr - jrc jrc = jr if ( jdlt * jznak . lt . 0. and . nturn . lt . m - 1 ) then nturn = nturn + 1 jznak =- jznak end if mn = nturn + unit_bias write ( mn , 7 ) x , z , xr , th , parn , npoli , pt , pl , pc , pa , ifast , idir , itr mm = m + unit_bias write ( mm , 7 ) x , z , xr , th , parn , npoli , pt , pl , pc , vthcg , ifast , idir , itr do n = m , nturn , - 1 pt_c ( n ) = pt pl_c ( n ) = pl pc_c ( n ) = pc pa_c ( n ) = pa end do if ( pt . ge . 1 d0 - pleft ) go to 11 !maximal absorbed power along a ray end do jchek = jrad ( ie + 1 ) if ( jchek . ne . 0 ) then !continue this trajectory ib = idnint ( dland ( ie + 1 )) ie = idnint ( dcoll ( ie + 1 )) goto 10 end if 11 continue do n = 1 , m ptt ( n ) = ptt ( n ) + pt_c ( n ) pll ( n ) = pll ( n ) + pl_c ( n ) pcc ( n ) = pcc ( n ) + pc_c ( n ) paa ( n ) = paa ( n ) + pa_c ( n ) end do if ( itr . lt . nnz * ntet ) then write ( m + unit_bias , * ) write ( nturn + unit_bias , * ) end if end if end do do n = 1 , m close ( n + unit_bias ) end do do n = 1 , m ptt ( n ) = ptt ( n ) / dble ( ntraj ) pll ( n ) = pll ( n ) / dble ( ntraj ) pcc ( n ) = pcc ( n ) / dble ( ntraj ) paa ( n ) = paa ( n ) / dble ( ntraj ) end do open ( 1 , file = 'lhcd/out/info_traj.dat' ) write ( 1 , 20 ) tview write ( 1 , * ) do n = 1 , m - 1 if ( n . lt . m - 1 ) then write ( 1 , 8 ) n , ptt ( n ), pll ( n ), pcc ( n ), paa ( n ) else write ( 1 , 9 ) ptt ( n ), pll ( n ), pcc ( n ), paa ( n ) end if write ( 1 , * ) end do write ( 1 , * ) write ( 1 , 1 ) write ( 1 , * ) itr = 0 do itet = 1 , ntet tetin = tet1 + htet * ( itet - 1 ) do inz = 1 , nnz itr = itr + 1 write ( 1 , 6 ) itr , mbad ( itr ), tetin , ynzm ( inz ), rbeg ( itr ) end do end do close ( 1 ) open ( 1 , file = 'lhcd/out/absorp.dat' ) write ( 1 , 2 ) write ( 1 , * ) do n = 1 , m - 1 if ( n . eq . 1 ) then dpt = ptt ( n ) dpl = pll ( n ) dpc = pcc ( n ) dpa = paa ( n ) else dpt = ptt ( n ) - ptt ( n - 1 ) dpl = pll ( n ) - pll ( n - 1 ) dpc = pcc ( n ) - pcc ( n - 1 ) dpa = paa ( n ) - paa ( n - 1 ) end if write ( 1 , 4 ) n , ptt ( n ), pll ( n ), pcc ( n ), paa ( n ), dpt , dpl , dpc , dpa end do close ( 1 ) 1 format ( 2 x , 'N_traj' , 3 x , 'mbad' , 6 x , 'theta' , 9 x , 'Npar' , 9 x , 'rho_start' ) 2 format ( 'R_pass' , 4 x , 'Ptot' , 6 x , 'Pland' , 6 x , 'Pcoll' , 8 x , 'Pa' , 7 x , 'dPtot' , 6 x , 'dPland' , 5 x , 'dPcoll' , 6 x , 'dPa' ) 3 format ( 5 x , 'R' , 10 x , 'Z' , 11 x , 'rho' , 8 x , 'theta' , 7 x , 'N_par' , 7 x , 'N_pol' , 6 x , 'P_tot' , 7 x , 'P_land' , 6 x , 'P_coll' , 6 x , 'vth' , 4 x , 'slow=1' , 4 x , 'out=1' , 2 x , 'N_traj' , 6 x ) 4 format ( i3 , 5 x , 8 ( f6 . 3 , 5 x )) 5 format ( 6 ( e13 . 6 , 3 x )) 6 format ( 2 ( i6 , 2 x ), 4 ( e13 . 6 , 1 x )) 7 format ( 10 ( e11 . 4 , 1 x ), i5 , 2 x , i5 , 2 x , i5 ) 8 format ( 'after radial pass=' , i3 , 2 x , ' P_tot=' , f6 . 3 , 2 x , ' P_land=' , f5 . 3 , 2 x , ' P_coll=' , f6 . 3 , 2 x , ' P_a=' , f6 . 3 ) 9 format ( 'Total passes:           P_tot=' , f6 . 3 , 2 x , ' P_land=' , f5 . 3 , 2 x , ' P_coll=' , f6 . 3 , 2 x , ' P_a=' , f6 . 3 ) 20 format ( 'written time slice (seconds) =' , f9 . 3 ) end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! end module trajectory","tags":"","loc":"sourcefile\\2_trajectory.f90.html"},{"title":"3_current_and_power.f90 – FRTS project","text":"Contents Modules current power Source Code 3_current_and_power.f90 Source Code module current use kind_module implicit none real ( wp ) :: dql ( 101 , 100 ) !! real ( wp ) :: pdl ( 100 ) !! real ( wp ) :: vzmin ( 100 ) !! real ( wp ) :: vzmax ( 100 ) !common /a0i3/ dql(101,100),pdl(100),vzmin(100),vzmax(100) real ( wp ) :: fcoll ( 100 ) real ( wp ) :: dens ( 100 ) real ( wp ) :: eta ( 100 ) !common /a0i4/ fcoll(100),dens(100),eta(100) real ( wp ) :: dq1 ( 101 , 100 ) real ( wp ) :: dq2 ( 101 , 100 ) real ( wp ) :: pdc ( 100 ) real ( wp ) :: pda ( 100 ) real ( wp ) :: ppv1 , ppv2 !common/vvv1/dq1(101,100),dq2(101,100),pdc(100),pda(100),ppv1,ppv2 real ( wp ) :: pdfast ( 100 ) !common /vvv3/ pdfast(100) real ( wp ) :: dqi0 ( 50 , 100 ) !common /alph/ dqi0(50,100) real ( wp ) :: dncount ( 101 , 100 ) !common/findsigma/dncount(101,100) contains subroutine find_achieved_radial_points ( nvpt ) !!  find achieved radial points jbeg-jend use rt_parameters , only : nr implicit none integer , intent ( in ) :: nvpt integer i , j , jbeg , jend , nvmin , nvach nvmin = 1 !minimum counted events at a given radius rho jbeg = 1 jend = 0 do j = 1 , nr nvach = 0 do i = 1 , nvpt nvach = nvach + dncount ( i , j ) end do if ( nvach . lt . nvmin ) then if ( jend . eq . 0 ) jbeg = jbeg + 1 else jend = j end if end do if ( jend . eq . 0. or . jbeg . ge . jend ) then write ( * , * ) 'failure: jbeg=' , jbeg , ' jend=' , jend pause stop end if end subroutine subroutine dfind ( j , i , v , powpr , pil , pic , pia , df , decv , refr , vlf , vrt , ifast ) use constants use plasma use rt_parameters implicit real * 8 ( a - h , o - z ) integer i , j , ifast , k !common /a0i3/ dql(101,100),pdl(100),vzmin(100),vzmax(100) !common /a0i4/ fcoll(100),dens(100),eta(100) !common/vvv1/dq1(101,100),dq2(101,100),pdc(100),pda(100),ppv1,ppv2 !common /vvv3/ pdfast(100) !common /alph/ dqi0(50,100) !common/findsigma/dncount(101,100) if ( v . gt . cltn ) return if ( pil . gt . zero ) then if ( v . lt . vzmin ( j )) vzmin ( j ) = v if ( v . gt . vzmax ( j )) vzmax ( j ) = v end if pchgl = zero pchgc = zero pchga = zero denom = pil + pic + pia powlandau = 1.d0 - dexp ( - 2.d0 * pil ) powdamped = 1.d0 - dexp ( - 2.d0 * denom ) domin = powpr * powdamped if ( denom . ne . zero ) then !!       pchgl=powpr*(1.d0-dexp(-2d0*pil)) !!       pchgc=powpr*dexp(-2d0*pil)*dabs(-2d0*pic) !!       pchga=powpr*dexp(-2d0*pil)*dabs(-2d0*pia) fff = domin / denom pchgl = dabs ( pil * fff ) pchgc = dabs ( pic * fff ) pchga = dabs ( pia * fff ) end if dd = zero if ( pil . eq . zero ) go to 1 !no Landau absorption if ( powlandau . gt . pchm ) then !strong absorption ppv1 = ppv1 + pchgl if ( dabs ( df ). gt . tiny ) then dd = dabs ( - pchgl / vk ( j ) / ( df * 1.d10 )) dncount ( i , j ) = dncount ( i , j ) + 1.d0 else dd = zero end if dq1 ( i , j ) = dq1 ( i , j ) + dd else ! weak absorption ppv2 = ppv2 + pchgl dd = dabs ( 2.d0 * decv * powpr * 1.d-10 / vk ( j )) dncount ( i , j ) = dncount ( i , j ) + 1.d0 dq2 ( i , j ) = dq2 ( i , j ) + dd end if 1 continue dql ( i , j ) = dql ( i , j ) + dd pdl ( j ) = pdl ( j ) + pchgl pdc ( j ) = pdc ( j ) + pchgc pda ( j ) = pda ( j ) + pchga if ( ifast . eq . - 1 ) pdfast ( j ) = pdfast ( j ) + pchgl + pchgc + pchga if ( itend0 . gt . 0 ) then parn = cltn / v dvz = vrt - vlf dnpar = cltn * dvz / v ** 2 weight = ( refr ** 2 - eta ( j )) ** 2 / ( refr ** 2 * parn ** 3 ) !!!        adde=zze*(dd/dens(j))*weight !!!        e2perp(i,j)=e2perp(i,j)+adde addd = zza * ( dd / dens ( j )) * weight / fcoll ( j ) / refr ** 3 arg = clt / ( refr * valfa ) do k = 1 , kv if ( vperp ( k , j ). gt . arg ) then hevis = dsqrt (( vperp ( k , j ) - arg ) * ( vperp ( k , j ) + arg )) adda = addd * hevis dqi0 ( k , j ) = dqi0 ( k , j ) + adda * dnpar end if end do end if return end end module current module power implicit none contains end module power","tags":"","loc":"sourcefile\\3_current_and_power.f90.html"},{"title":"3_flux_surface_mod.f90 – FRTS project","text":"Contents Modules FluxSurface_mod Source Code 3_flux_surface_mod.f90 Source Code module FluxSurface_mod !! все что связанно с магнитными поверхностями use kind_module type FluxSurface !! класс магнитной поверхности integer :: index !! номер магнитной поверхности real ( wp ) :: r !! радиус real ( wp ) :: vmax !! vmax=cltn/vto real ( wp ) :: vt !! наверно тепловая скорость электронов????? vt=fvt(r) integer :: ipt !! размер vgrid real ( wp ), allocatable :: vgrid (:) !! real ( wp ), allocatable :: vr_grid (:) !! бываший vrj real ( wp ), allocatable :: diffusion (:) !! бывший dijk(i,j,k) или dj(i) !   complex         :: inst_field1 contains !procedure :: set   => set_e !procedure :: print => e_print end type FluxSurface end module FluxSurface_mod","tags":"","loc":"sourcefile\\3_flux_surface_mod.f90.html"},{"title":"3_FokkerPlanck.f90 – FRTS project","text":"Contents Modules FokkerPlanck_module Source Code 3_FokkerPlanck.f90 Source Code module FokkerPlanck_module use kind_module implicit none contains !! calculation of distribution functions at time t1=t+dtau !! subroutine fokkerplanck_compute ( time , TAU ) use FokkerPlanck1D_mod use Utils use rt_parameters use writer_module use maxwell use plasma , only : fvt , enorm , fst implicit none type ( FokkerPlanck1D ) fp_test real ( wp ), intent ( in ) :: time , TAU real ( wp ) t , dtstep , dtau !integer nr !common /a0ab/ nr integer , parameter :: ntau = 10 !integer i0 !parameter(i0=1002) !real(wp) vij,fij0,fij,dfij,dij,enorm,fst !common/lh/vij(i0,100),fij0(i0,100,2),fij(i0,100,2),dfij(i0,100,2), dij(i0,100,2),enorm(100),fst(100) integer n , i , j , it , nt , k real ( wp ) xend , h , dt real ( wp ) znak , alfa2 , dt0 , h0 , r !common/ef/ alfa2 real ( wp ) d0 integer jindex , kindex common / dddql / d0 , jindex , kindex parameter ( dt0 = 0.1d0 , h0 = 0.1d0 ) real time1 , time2 dtstep = TAU / dble ( ntau ) !seconds print * , 'fokkerplanck_compute' write ( * , * ) 'time=' , time , ' dt=' , dtstep time1 = sys_time () do j = 1 , nr jindex = j ! common/dddql/ dtau = dtstep * fst ( j ) nt = 1 if ( dtau . gt . dt0 ) then nt = 1 + dtau / dt0 end if dt = dtau / nt r = dble ( j ) / dble ( nr + 1 ) xend = 3.d10 / fvt ( r ) do k = 1 , 2 znak = 2.d0 * dble ( k ) - 3.d0 fp_test = FokkerPlanck1D ( znak * enorm ( j ), xend , vij (:, j ), fij0 (:, j , k )) call fp_test % init_zero_diffusion do i = 1 , ntau call fp_test % solve_time_step ( dt , nt ) !call fokkerplanck1D_iter(alfa2, h, n, dt, nt, xend, d1, d2, d3, vij(:,j), fij0(:,j,k), out_fj) end do fij0 (:, j , k ) = fp_test % f fp_test = FokkerPlanck1D ( znak * enorm ( j ), xend , vij (:, j ), fij (:, j , k )) call fp_test % init_diffusion ( dij (:, j , k )) do i = 1 , ntau call fp_test % solve_time_step ( dt , nt ) !call fokkerplanck1D_iter(alfa2, h, n, dt, nt, xend, d1, d2, d3, vij(:,j), fij(:,j,k),out_fj, dfij(:,j,k)) end do fij (:, j , k ) = fp_test % f end do call write_distribution ( fij0 (:, j , 2 ), i0 , time ) !call write_distribution(out_fj, n, time) end do write ( * , * ) 'fokkerplanck nr= ' , nr , ' ntau =' , ntau , 'nt =' , nt call write_v_array ( vij , fij0 (:, 1 : nr ,:), time , 'maxwell' ) call write_v_array ( vij , dij (:, 1 : nr ,:), time , 'diffusion' ) !call write_matrix(dij(1:i0,1:nr,1), time, 'diffusion') time2 = sys_time () - time1 print * , 'fokkerplanck_new eval time: ' , time2 end subroutine init_diffusion ( h , n , vj , dj , d1 , d2 , d3 ) ! инициализация диффузии для схемы савельева implicit none integer , intent ( in ) :: n real ( wp ), intent ( in ) :: h real ( wp ), dimension (:), intent ( in ) :: vj , dj real ( wp ), dimension (:), intent ( out ) :: d1 , d2 , d3 real ( wp ), dimension (:), allocatable :: xx integer :: i0 integer i , klo , khi , ierr , klo1 , khi1 integer klo2 , klo3 , khi2 , khi3 , ierr1 , ierr2 , ierr3 i0 = size ( vj ) allocate ( xx ( n + 1 )) do i = 1 , n + 1 xx ( i ) = h / 2.d0 + h * dble ( i - 1 ) !+shift end do do i = 1 , n + 1 call lock ( vj , i0 , xx ( i ), klo1 , khi1 , ierr1 ) call lock ( vj , i0 , xx ( i ) - h / 2 d0 , klo2 , khi2 , ierr2 ) call lock ( vj , i0 , xx ( i ) + h / 2 d0 , klo3 , khi3 , ierr3 ) if ( ierr1 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo1=' , klo1 , 'khi1=' , khi1 , 'i=' , i write ( * , * ) 'vj(1)=' , vj ( 1 ), ' vj(i0)=' , vj ( i0 ) pause stop end if if ( ierr2 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo2=' , klo2 , 'khi2=' , khi2 , 'i=' , i write ( * , * ) 'vj(1)=' , vj ( 1 ), ' vj(i0)=' , vj ( i0 ) pause stop end if if ( ierr3 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo3=' , klo3 , 'khi3=' , khi3 , 'i=' , i write ( * , * ) 'vj(1)=' , vj ( 1 ), ' vj(i0)=' , vj ( i0 ) pause stop end if d1 ( i ) = dj ( klo1 ) d2 ( i ) = dj ( klo2 ) d3 ( i ) = dj ( klo3 ) end do end subroutine end module FokkerPlanck_module","tags":"","loc":"sourcefile\\3_fokkerplanck.f90.html"},{"title":"3_iteration_result.f90 – FRTS project","text":"Contents Modules iteration_result_mod Source Code 3_iteration_result.f90 Source Code module iteration_result_mod use kind_module implicit none type IterationResult integer :: number !! iteration number 'iteration=',iterat integer :: spectr_direction !! 'ispectr=',ispectr real ( wp ) :: P_launched !!P_launched, MW=',plaun real ( wp ) :: P_landau !!'P_landau, MW=',ol real ( wp ) :: P_coll !! 'P_coll, MW=',oc real ( wp ) :: P_alph !!'P_alph, MW=',oa real ( wp ) :: alphas_power !!'Alphas power, MW=',fuspow real ( wp ) :: P_fast !write(*,*) 'P_fast (landau+coll), MW=',of real ( wp ) :: P_lost !write(*,*) 'P_lost, MW=',plost/xsgs real ( wp ) :: P_not_accounted !write(*,*) 'P_not accounted, MW=',pnab/xsgs real ( wp ) :: P_landau_strong_absorption !write(*,*) 'P_landau (strong absorption), MW=',ppv1/xsgs real ( wp ) :: P_landau_weak_absorption !write(*,*) 'P_landau (weak absorption), MW=',ppv2/xsgs real ( wp ) :: P_turns !write(*,*) 'P_turns, MW=', psum4/xsgs real ( wp ) :: efficiency !write(*,*) 'efficiency, I(MA)/P(MW)=',oi/plaun !sav2008 !call integral(1,nspl,rh,con,avedens) !sav2010 real ( wp ) :: avedens real ( wp ) :: r0 !write (*,*) '<Ne>, m&#94;-3=',avedens*1.d19,' R, m=',r0*1.d-2 real ( wp ) :: eta_eff !eta_eff=1.d17*avedens*r0*oi/plaun !write (*,*) 'eta_eff=<Ne>*R*I/P, A/(W*m&#94;2)=',eta_eff !sav2010 real ( wp ) :: residual !! невязка 'nevyazka=', pchg contains procedure :: print => iteration_result_print procedure :: save => iteration_result_save end type IterationResult contains subroutine iteration_result_print ( this ) class ( IterationResult ), intent ( in ) :: this print * , ' ---------' print * , 'ITERATION:' print * , 'iteration=' , this % number print * , 'ispectr=' , this % spectr_direction print * , 'P_launched, MW=' , this % P_launched print * , 'P_landau, MW=' , this % P_landau print * , 'P_coll, MW=' , this % P_coll print * , 'P_alph, MW=' , this % P_alph print * , 'Alphas power, MW=' , this % alphas_power print * , 'P_fast (landau+coll), MW=' , this % P_fast print * , 'P_lost, MW=' , this % P_lost print * , 'P_not accounted, MW=' , this % P_not_accounted print * , 'P_landau (strong absorption), MW=' , this % P_landau_strong_absorption print * , 'P_landau (weak absorption), MW=' , this % P_landau_weak_absorption print * , 'P_turns, MW=' , this % P_turns print * , 'efficiency, I(MA)/P(MW)=' , this % efficiency !call integral(1,nspl,rh,con,avedens) !sav2010 print * , '<Ne>, m&#94;-3=' , this % avedens , ' R, m=' , this % r0 !eta_eff=1.d17*avedens*r0*oi/plaun print * , 'eta_eff=<Ne>*R*I/P, A/(W*m&#94;2)=' , this % eta_eff print * , 'nevyazka=' , this % residual end subroutine iteration_result_print subroutine iteration_result_save ( this , time_stamp ) !! save Iteration Result to file class ( IterationResult ), intent ( in ) :: this real ( wp ), intent ( in ) :: time_stamp character ( 120 ) fname integer , parameter :: iu = 20 write ( fname , '(\"lhcd/rt-result/\", f9.7,\".dat\")' ) time_stamp print * , fname open ( iu , file = fname , position = \"append\" ) if ( this % number == 1 ) then write ( 20 , '(18A21)' ) 'iteration' , 'direction' , 'P_launched' , & 'P_landau' , 'P_coll' , 'P_alph' , 'alphas_power' , 'P_fast' , 'P_lost' , & 'P_not_accounted' , 'P_landau_strong_abs' , 'P_landau_weak_abs' , & 'P_turns' , 'efficiency' , 'avedens' , 'r0' , 'eta_eff' , 'residual' endif write ( 20 , '(2(I21), 16(ES21.14))' ) this % number , this % spectr_direction , & this % P_launched , this % P_landau , this % P_coll , this % P_alph , & this % alphas_power , this % P_fast , this % P_lost , this % P_not_accounted , & this % P_landau_strong_absorption , this % P_landau_weak_absorption , & this % P_turns , this % efficiency , this % avedens , this % r0 , & this % eta_eff , this % residual close ( iu ) end subroutine end module iteration_result_mod","tags":"","loc":"sourcefile\\3_iteration_result.f90.html"},{"title":"3_iterator_module.f90 – FRTS project","text":"Contents Modules iterator_mod Source Code 3_iterator_module.f90 Source Code module iterator_mod use kind_module implicit none real ( wp ) :: vmid ( 100 ), vz1 ( 100 ), vz2 ( 100 ) integer :: ibeg ( 100 ), iend ( 100 ) real ( wp ) :: vrj ( 101 ), dj ( 101 ), djnew ( 1001 ) real ( wp ) :: dj2 ( 101 ), d2j ( 101 ) real ( wp ), dimension (:), allocatable :: vvj , vdfj real ( wp ) :: vgrid ( 101 , 100 ), dfundv ( 101 , 100 ) !!common/gridv/vgrid(101,100),dfundv(101,100) integer :: nvpt !!common/gridv/nvpt integer :: ipt1 , ipt2 , ipt integer , parameter :: kpt1 = 20 , kpt3 = 20 integer :: iterat real ( wp ) :: psum4 !!common /vvv2/ psum4 real ( wp ) plost , pnab !!common /a0a4/ plost,pnab contains subroutine init_iteration use constants , only : zero use rt_parameters , only : itend0 use current use plasma , only : cltn implicit none ppv1 = zero ppv2 = zero psum4 = zero pnab = zero plost = zero dql = zero dq1 = zero dq2 = zero dncount = zero vzmin = cltn vzmax =- cltn pdl = zero pdc = zero pda = zero pdfast = zero if ( itend0 . gt . 0 ) then dqi0 = zero end if end subroutine recalculate_f_for_a_new_mesh ( ispectr ) !!   recalculate f' for a new mesh use constants , only : zero use rt_parameters , only : nr , ni1 , ni2 use plasma , only : vt0 , fvt , cltn use current , only : vzmin , vzmax use maxwell , only : i0 , vij , dfij implicit none integer , intent ( in ) :: ispectr integer i , j , k real ( wp ) :: cdel , dfout integer :: klo , khi , ierr real ( wp ) :: r , hr , vt , vto , vmax real ( wp ) :: v1 , v2 , vp1 , vp2 hr = 1.d0 / dble ( nr + 1 ) k = ( 3 - ispectr ) / 2 do j = 1 , nr r = hr * dble ( j ) vt = fvt ( r ) vto = vt / vt0 if ( iterat . gt . 0 ) then v1 = dmin1 ( vzmin ( j ), vz1 ( j )) v2 = dmax1 ( vzmax ( j ), vz2 ( j )) else v1 = vzmin ( j ) v2 = vzmax ( j ) end if vmax = cltn / vto vp1 = v1 / vto vp2 = v2 / vto call gridvel ( vp1 , vp2 , vmax , cdel , ni1 , ni2 , ipt1 , kpt3 , vrj ) do i = 1 , i0 vvj ( i ) = vij ( i , j ) vdfj ( i ) = dfij ( i , j , k ) !=dfundv(i,j)*vto**2 end do do i = 1 , ipt call lock ( vvj , i0 , vrj ( i ), klo , khi , ierr ) if ( ierr . eq . 1 ) then !!!         if(vrj(i).gt.vvj(i0)) exit write ( * , * ) 'lock error in new v-mesh' write ( * , * ) 'j=' , j , ' i0=' , i0 write ( * , * ) 'vvj(1)=' , vvj ( 1 ), ' vvj(i0)=' , vvj ( i0 ) write ( * , * ) 'i=' , i , ' vrj(i)=' , vrj ( i ) write ( * , * ) pause 'next key = stop' stop end if call linf ( vvj , vdfj , vrj ( i ), dfout , klo , khi ) vgrid ( i , j ) = vrj ( i ) * vto dfundv ( i , j ) = dfout / vto ** 2 if ( dfundv ( i , j ). gt . zero ) dfundv ( i , j ) = zero end do vz1 ( j ) = v1 vz2 ( j ) = v2 end do end subroutine end module iterator_mod","tags":"","loc":"sourcefile\\3_iterator_module.f90.html"},{"title":"3_manager.f90 – FRTS project","text":"Contents Modules manager_mod Source Code 3_manager.f90 Source Code module manager_mod use kind_module implicit none real ( wp ) :: yn3 !! common /abefo/ yn3 integer :: iroot !!common /beo/ iroot integer :: ivar !!common /bdeo/ ivar contains !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine manager ( iterat , iw0 , ntet , spectr ) use constants use plasma use rt_parameters , only : nr , ipri , iw , nmaxm , pabs0 !use spectrum1D, only: ynzm, pm use trajectory use spectrum_mod use iterator_mod , only : plost , pnab implicit none type ( spectrum ) spectr type ( spectrum_point ) point real ( wp ) pabs integer iznzap ( mpnt ), iwzap ( mpnt ), irszap ( mpnt ) real ( wp ) rzap ( mpnt ), tetzap ( mpnt ), xmzap ( mpnt ), yn3zap ( mpnt ) !common /a0a1/ ynzm(1001),pm(1001) !common /a0a2/ tet1,tet2 ! real(wp) plost,pnab !common /a0a4/ plost,pnab real ( wp ) rzz , tetzz , xmzz common / abc / rzz , tetzz , xmzz , iznzz , iwzz , irszz common / abcd / irs common / abcde / izn common / abcdg / iabsorp !common /abefo/ yn3 real ( wp ) pow common / acg / pow !common /a0gh/ pabs common / aef2 / icall1 , icall2 common / ag / inak , lenstor , lfree !common/refl/nrefj(mpnt) integer lenstor , ntet , irs , iout , itr , inak , nnj , n_it integer maxref , iterat , nmax0 , ibad , itet , nref integer nbad1 , nbad2 , icall1 , icall2 , inz integer iw0 , ifail , iabsirp , inak0 , ib , ie , izn integer lfree , nmax , iabsorp , i , nb1 , nb2 integer iznzz , iwzz , irszz real ( wp ) htet , hr , yn , rin , xmin , rstart real ( wp ) xnr , powexit , dltpow , pow1 , pgamma , xm real ( wp ) tetin0 , tetin , tet pabs = spectr % max_power * pabs0 / 1.d2 print * , 'pabs =' , pabs , spectr % max_power , pabs0 lenstor = length htet = zero hr = 1.d0 / dble ( nr + 1 ) !sav2008 if ( ntet . ne . 1 ) htet = ( tet2 - tet1 ) / ( ntet - 1 ) irs = 1 iout = 0 mbeg ( 1 ) = 1 itr = 0 inak = 0 nnj = 0 do n_it = 0 , 3 nnj = nnj + nmaxm ( n_it + 1 ) end do maxref = nnj if ( iterat . lt . 3 ) nmax0 = nmaxm ( iterat + 1 ) if ( iterat . ge . 3 ) nmax0 = nmaxm ( 4 ) if ( ipri . gt . 1 ) then write ( * , 1001 ) iterat + 1 write ( * , 1002 ) end if ibad = 0 !-------------------------------------- ! begin outer loop on teta !-------------------------------------- do itet = 1 , ntet nref = 0 nbad1 = 0 nbad2 = 0 icall1 = 0 icall2 = 0 tetin = tet1 + htet * ( itet - 1 ) !-------------------------------------- ! begin inner loop on nz !-------------------------------------- do inz = 1 , spectr % size itr = itr + 1 !ipri          if(ipri.eq.4)  write(23,*) point = spectr % data ( inz ) if ( iterat . eq . 0 ) then !----------------------------------------- !    find initial radius for a trajectory !    on the 1th iteration !----------------------------------------- yn = point % nz pow = point % power !yn=ynzm(inz) !sav2008, yn is introduced !pow=pm(inz) irs = 1 iw = iw0 rin = rini ( xmin , tetin , xnr , point , hr , ifail ) if ( ifail . eq . 1 ) then if ( ipri . gt . 1 ) write ( * , * ) 'error: no roots' iabsorp = - 1 inak0 = inak go to 10 end if rbeg ( itr ) = rin !sav2008 tetbeg ( itr ) = tetin !sav2008 xnrbeg ( itr ) = xnr !sav2008 xmbeg ( itr ) = xmin !sav2008 yn3beg ( itr ) = yn3 !sav2008 else if ( mbad ( itr ). ne . 0 ) then plost = plost + point % power go to 31 end if ib = mbeg ( itr ) ie = mend ( itr ) powexit = point % power dltpow = pabs call dqliter ( dltpow , ib , ie , hr , powexit , iout ) if ( nmax0 . eq . 0 ) then ib = mbeg ( itr ) ie = mend ( itr ) pow1 = powexit pgamma = 1.d0 - pow1 / point % power powexit = pow1 / pgamma dltpow = powexit - pow1 + pabs call dqliter ( dltpow , ib , ie , hr , powexit , iout ) powexit = powexit - dltpow + pabs if ( powexit . lt . zero ) powexit = zero go to 30 end if if ( iout . eq . 0 ) then go to 30 else tetin = tetzap ( itr ) xmin = xmzap ( itr ) rin = rzap ( itr ) yn3 = yn3zap ( itr ) pow = powexit irs = irszap ( itr ) iw = iwzap ( itr ) izn = iznzap ( itr ) jrad ( ie + 1 ) = 1 dland ( ie + 1 ) = lfree inak = lfree - 1 end if end if !--------------------------------------- ! initial parameters for a trajectory !--------------------------------------- xm = xmin rstart = rin !sav2008 tet = tetin nmax = nmax0 iabsorp = 0 inak0 = inak !------------------------------------- ! call ray tracing !------------------------------------- call traj ( xm , tet , rstart , nmax , nb1 , nb2 , itet , inz , pabs ) !sav2009 nbad1 = nbad1 + nb1 nbad2 = nbad2 + nb2 nrefj ( itr ) = nrefj ( itr ) + nmax powexit = pow nref = nref + nmax 10 if ( iabsorp . lt . 0 ) then !------------------------------------- !    encounted problems !------------------------------------- if ( inak . eq . lenstor - 1 ) then write ( * , * ) 'fix maximal length' nmax0 = 0 do i = 1 , 4 nmaxm ( i ) = 0 end do iout = 1 goto 20 end if if ( ipri . gt . 1 ) then tetin0 = tet1 + htet * ( itet - 1 ) write ( * , 111 ) tetin0 , point % nz 111 format ( 1 x , 'traj. with tet0=' , f10 . 5 , 1 x , ', Ninput=' , f10 . 5 , 1 x , 'failed' ) end if mbad ( itr ) = 1 plost = plost + pow inak = inak0 mend ( itr ) = inak - 1 goto 30 end if !--------------------------------------- ! remember end point of trajectory !--------------------------------------- rzap ( itr ) = rzz tetzap ( itr ) = tetzz xmzap ( itr ) = xmzz yn3zap ( itr ) = yn3 iznzap ( itr ) = iznzz iwzap ( itr ) = iwzz irszap ( itr ) = irszz if ( iterat . eq . 0 ) then if ( itr . gt . 1 ) mbeg ( itr ) = mend ( itr - 1 ) + 2 mend ( itr ) = inak jrad ( mend ( itr ) + 1 ) = 0 lfree = mend ( itr ) + 2 inak = lfree - 1 end if 20 continue if ( iout . ne . 0 ) then dcoll ( ie + 1 ) = inak jrad ( inak + 1 ) = 0 lfree = inak + 2 end if if ( nrefj ( itr ). gt . maxref . and . pow . gt . pabs ) then !forced absorp if ( pow . ge . point % power ) go to 30 !sav2008 ib = mbeg ( itr ) ie = mend ( itr ) pow1 = pow pgamma = 1.d0 - pow1 / point % power powexit = pow1 / pgamma dltpow = powexit - pow1 + pabs call dqliter ( dltpow , ib , ie , hr , powexit , iout ) powexit = powexit - dltpow + pabs if ( powexit . lt . zero ) powexit = zero end if 30 continue pnab = pnab + powexit 31 continue end do if ( ipri . gt . 1 ) write ( * , 1003 ) itet , icall1 , icall2 , nref , lfree - 1 , nbad1 , nbad2 print * , 'itr =' , itr end do 1001 format ( 30 x , i4 , ' iteration' ) 1002 format ( 6 x , 'n' , 5 x , 'call2' , 6 x , 'call4' , 6 x , 'nrefl' , 4 x , 'last' , 5 x , 'bad2' , 5 x , 'bad4' ) 1003 format ( 3 x , i4 , 2 ( 1 x , i10 ), 2 x , i7 , 2 x , i8 , 2 ( 1 x , i7 ), 2 ( 2 x , i7 )) 1004 format ( 1 x , i8 ) 1005 format ( 1 x , i5 ) 1006 format ( e14 . 7 ) end real ( wp ) function rini ( xm , tet , xnr , point , hr , ifail ) !sav2009 use constants , only : zero use rt_parameters , only : inew use spectrum_mod implicit none type ( spectrum_point ) :: point real ( wp ) xm , tet , xnr , hr integer ifail , ntry real ( wp ) :: vgrp ( 3 ), vph ( 3 ) real ( wp ) :: ynz , ynpopq common / bcef / ynz , ynpopq real ( wp ) :: g11 , g12 , g22 , g33 , gg , g , si , co common / metrika / g11 , g12 , g22 , g33 , gg , g , si , co !sav2009 real ( wp ) :: pa , prt , prm real ( wp ) :: f1 , f2 real ( wp ), parameter :: rhostart = 1.d0 integer , parameter :: ntry_max = 5 ifail = 1 rini = zero ntry = 0 pa = rhostart do while ( ntry . lt . ntry_max . and . pa . ge . 2 d0 * hr ) pa = rhostart - hr * dble ( ntry ) - 1.d-4 ntry = ntry + 1 ivar = 1 call disp2 ( pa , xm , tet , xnr , prt , prm ) if ( inew . gt . 0 ) then !g' in ST and poloidal grill direction !yn3 = zero                 !Nfi=0 !xm = yn*dsqrt(g22)/si      !given Npar at Nfi=0 yn3 = point % ny ** dsqrt ( g33 ) / co xm = point % nz * dsqrt ( g22 ) / si !!              xm=yn*dsqrt(g22)         !given yn=(N*jpol) at Nfi=0 else !usual tokamak and toroidal grill direction !xm = zero               !N2=0 !yn3 = yn*dsqrt(g33)/co  !if given Npar at Nteta=0 !!              yn3=yn*dsqrt(g33)       !if given Nfi at Nteta=0 yn3 = point % nz * dsqrt ( g33 ) / co xm = point % ny * dsqrt ( g22 ) / si end if ivar = 0 iroot = 2 call disp2 ( pa , xm , tet , xnr , f1 , f2 ) if ( f1 . ge . zero . and . f2 . ge . zero ) then rini = pa ifail = 0 return end if end do end end module manager_mod","tags":"","loc":"sourcefile\\3_manager.f90.html"},{"title":"drivencurrent95.f90 – FRTS project","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Contents Functions currlhcd d Subroutines drivencurrent95 lhcurrent currlhcd_old ddc qromb polint trapzd Source Code drivencurrent95.f90 Source Code subroutine drivencurrent95 ( outj , sigmaj , UPL , NRD , NA1 , TIME , TAU , ROC , RTOR , GP2 ) !! ****************************************************************** !!   outj(i)  = LH driven current density, MA/m&#94;2 !!   dndt(i)  = d&#94;2Jr1/dt&#94;2/E, MA/m&#94;2/sec&#94;2/(V/m), ~runaway d(el.density)/dt/E !!   djdt(i)  = dJr2/dt, time drivative of runaway current Jr2, MA/m&#94;2/sec !!   outjrun(i)  = LH driven runaway current density, MA/m&#94;2 !!   outnerun(i) = runaway electron density/10&#94;19 m&#94;-3 !! ****************************************************************** use FokkerPlanck_module implicit none ! variables imported from ASTRA integer NRD ! NRD     501 - Maximum size of the radial grid integer NA1 ! NA1     Edge grid point number: ROC=RHO(NA1) double precision TIME , TAU , RTOR , ROC , GP2 double precision UPL ( NRD ) ! real * 8 outj ( NRD ), sigmaj ( NRD ), afld ( NRD ), dtau integer i , inpt , ispectr real * 8 , dimension (:), allocatable :: outjp , outjm , ohjp , ohjm real * 8 dt , cup , cup0 , cum , cum0 , cp , cm , cp0 , cm0 , aiint real * 8 , parameter :: zero = 0.d0 , eps = 1.d-2 ! inpt = NA1 allocate ( outjp ( inpt ), outjm ( inpt ), ohjp ( inpt ), ohjm ( inpt )) do i = 1 , inpt afld ( i ) = UPL ( i ) / RTOR / GP2 !!variant end do ! !!!!!!!!!!!!! starting LH current calculation !!!!!!!!!!!!!!!!! outj = zero outjp = zero outjm = zero ohjp = zero ohjm = zero cup = zero cum = zero cp = zero cm = zero cup0 = zero cum0 = zero cp0 = zero cm0 = zero ! !!positive spectrum: ispectr = 1 call lhcurrent ( outjp , ohjp , cup , cup0 , inpt , ispectr ) if ( cup0 . ne . zero ) then cp0 = aiint ( ohjp , roc ) if ( cp0 . ne . zero ) then do i = 1 , inpt ohjp ( i ) = cup0 * ohjp ( i ) / cp0 end do end if end if if ( cup . ne . zero ) then cp = aiint ( outjp , roc ) if ( cp . ne . zero ) then do i = 1 , inpt outjp ( i ) = cup * outjp ( i ) / cp end do end if end if !!negative spectrum: ispectr =- 1 call lhcurrent ( outjm , ohjm , cum , cum0 , inpt , ispectr ) if ( cum0 . ne . zero ) then cm0 = aiint ( ohjm , roc ) if ( cm0 . ne . zero ) then do i = 1 , inpt ohjm ( i ) = cum0 * ohjm ( i ) / cm0 end do end if end if if ( cum . ne . zero ) then cm = aiint ( outjm , roc ) if ( cm . ne . zero ) then do i = 1 , inpt outjm ( i ) = cum * outjm ( i ) / cm end do end if end if do i = 1 , inpt outj ( i ) = outjp ( i ) + outjm ( i ) sigmaj ( i ) = zero if ( dabs ( afld ( i )). gt . eps ) then sigmaj ( i ) = ( ohjp ( i ) + ohjm ( i )) / afld ( i ) end if !!!!       write(*,*) i,outj(i) end do ! write ( * , * ) 'time=' , time write ( * , * ) 'cup=' , cup , ' cp=' , cp write ( * , * ) 'cum=' , cum , ' cm=' , cm write ( * , * ) 'cup0=' , cup0 , ' cp0=' , cp0 write ( * , * ) 'cum0=' , cum0 , ' cm0=' , cm0 write ( * , * ) 'sigma driven current, MA=' , cp0 + cm0 write ( * , * ) 'driven current, MA=' , cup + cum write ( * , * ) ! call fokkerplanck_compute ( time , TAU ) ! deallocate ( outjp , outjm , ohjp , ohjm ) ! end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine lhcurrent ( outj , ohj , cuj , cujoh , inpt , ispectr ) !!      implicit real*8 (a-h,o-z) use plasma , only : rh , rh1 , fn1 , fn2 , fvt , sk use maxwell use rt_parameters , only : nr , inew implicit none real * 8 outj ( * ), ohj ( * ), cuj , cujoh , curs , curs0 , curdir real * 8 currn , pqe , vt0 , ccur , cfull , cfull0 real * 8 r , pn , fnr , fnrr , vt , vto !,rh1 integer klo , khi , ierr , nrr , i , j , inpt , ispectr , ismthout !common /a0ab/ nr !real*8 y2dn,y2tm,y2tmi !common /a0l3/ y2dn(501),y2tm(501),y2tmi(501) !integer inew !common /cnew/ inew !est !sav2008 real * 8 zv1 , zv2 , fout common / plosh / zv1 ( 100 , 2 ), zv2 ( 100 , 2 ) !,sk(100) integer k !parameter(i0=1002) !real*8 vij,fij0,fij,dfij,dij,enorm,fst !common/lh/ vij(i0,100), fij0(i0,100,2), fij(i0,100,2), dfij(i0,100,2), dij(i0,100,2), enorm(100), fst(100) real * 8 , dimension (:), allocatable :: vj , fj , fj0 , cur , cur0 , currnt , rxx , wrk parameter ( ismthout = 1 ) interface function currlhcd ( v , f ) result ( curs ) implicit none real * 8 v (:), f (:) real * 8 curs end function end interface allocate ( vj ( i0 ), fj ( i0 ), fj0 ( i0 ), cur ( nr ), cur0 ( nr ), currnt ( nr + 2 ), rxx ( nr + 2 ), wrk ( nr + 2 )) !--------------------------------------------------- ! initial constants !--------------------------------------------------- pqe = 4.803e-10 vt0 = fvt ( zero ) ccur = pqe * vt0 * 0.333d-9 curdir =- dble ( ispectr ) ! cfull = zero cfull0 = zero k = ( 3 - ispectr ) / 2 do j = 1 , nr do i = 1 , i0 vj ( i ) = vij ( i , j ) !Vpar/Vt fj0 ( i ) = fij0 ( i , j , k ) fj ( i ) = fij ( i , j , k ) - fij0 ( i , j , k ) end do r = dble ( j ) / dble ( nr + 1 ) if ( inew . eq . 0 ) then !vardens pn = fn1 ( r , fnr ) else pn = fn2 ( r , fnr , fnrr ) end if vt = fvt ( r ) vto = vt / vt0 curs = currlhcd ( vj , fj ) cur ( j ) = curs * pn * ccur * curdir * vto !Ampere/cm2 cfull = cfull + cur ( j ) * sk ( j ) curs0 = currlhcd ( vj , fj0 ) cur0 ( j ) = curs0 * pn * ccur * curdir * vto !Ampere/cm2 cfull0 = cfull0 + cur0 ( j ) * sk ( j ) end do cuj = cfull * 1 d - 6 !driven current, MA cujoh = cfull0 * 1 d - 6 !driven current, MA !!      write(*,*) !!      write(*,*)'ccur',ccur,' curdir=',curdir,' nr=',nr !!      write(*,*)'cu_out, MA=',cu_out,' cfull, A=',cfull !!           close(111) !      pause !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! currn = cur ( 1 ) ! Jstoped, A/cm&#94;2 currnt ( 1 ) = currn * 1.d-2 ! Jstoped, MA/m&#94;2 rxx ( 1 ) = zero do j = 1 , nr rxx ( j + 1 ) = dble ( j ) / dble ( nr + 1 ) currn = cur ( j ) ! Jstopped, A/cm&#94;2 currnt ( j + 1 ) = currn * 1.d-2 ! Jstoped, MA/m&#94;2 end do nrr = nr + 2 rxx ( nrr ) = 1.d0 currnt ( nr + 2 ) = zero ! if ( ismthout . ne . 0 ) then do i = 1 , nrr wrk ( i ) = currnt ( i ) end do call fsmoth4 ( rxx , wrk , nrr , currnt ) end if ! rh ( 1 ) = rh1 if ( rh ( inpt ). gt . 1 d0 ) rh ( inpt ) = 1.d0 do j = 1 , inpt call lock2 ( rxx , nrr , rh ( j ), klo , khi , ierr ) if ( ierr . ne . 0 ) then write ( * , * ) 'lock2 error in current profile for ASTRA' write ( * , * ) 'ierr=' , ierr , ' j=' , j , ' rh(j)=' , rh ( j ) write ( * , * ) 'rxx(1)=' , rxx ( 1 ), ' rxx(nrr)=' , rxx ( nrr ) pause end if call linf ( rxx , currnt , rh ( j ), fout , klo , khi ) outj ( j ) = fout end do rh ( 1 ) = zero !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! currn = cur0 ( 1 ) ! Jstoped, A/cm&#94;2 currnt ( 1 ) = currn * 1.d-2 ! Jstoped, MA/m&#94;2 rxx ( 1 ) = zero do j = 1 , nr rxx ( j + 1 ) = dble ( j ) / dble ( nr + 1 ) currn = cur0 ( j ) ! Jstopped, A/cm&#94;2 currnt ( j + 1 ) = currn * 1.d-2 ! Jstoped, MA/m&#94;2 end do nrr = nr + 2 rxx ( nrr ) = 1.d0 currnt ( nr + 2 ) = zero ! if ( ismthout . ne . 0 ) then do i = 1 , nrr wrk ( i ) = currnt ( i ) end do call fsmoth4 ( rxx , wrk , nrr , currnt ) end if ! rh ( 1 ) = rh1 if ( rh ( inpt ). gt . 1 d0 ) rh ( inpt ) = 1.d0 do j = 1 , inpt call lock2 ( rxx , nrr , rh ( j ), klo , khi , ierr ) if ( ierr . ne . 0 ) then write ( * , * ) '#2 lock2 error in current profile for ASTRA' write ( * , * ) 'ierr=' , ierr , ' j=' , j , ' rh(j)=' , rh ( j ) write ( * , * ) 'rxx(1)=' , rxx ( 1 ), ' rxx(nrr)=' , rxx ( nrr ) pause end if call linf ( rxx , currnt , rh ( j ), fout , klo , khi ) ohj ( j ) = fout end do rh ( 1 ) = zero !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! deallocate ( vj , fj , fj0 , cur , cur0 , currnt , rxx , wrk ) end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! function currlhcd ( v , f ) result ( curs ) implicit none real * 8 v (:), f (:) real * 8 curs integer i0 , k real * 8 vl , vr , fl , fr curs = 0.d0 i0 = size ( v ) do k = 1 , i0 - 1 vl = v ( k ) vr = v ( k + 1 ) fl = f ( k ) fr = f ( k + 1 ) curs = curs + ( fl * vl + fr * vr ) / 2 d0 * ( vr - vl ) end do end subroutine currlhcd_old ( i0 , v , f , f0 , curs , curs0 ) implicit none integer i0 , k real * 8 v ( * ), f ( * ), f0 ( * ), curs , curs0 real * 8 vl , vr , fl , fr , zero parameter ( zero = 0.d0 ) curs = zero curs0 = zero do k = 1 , i0 - 1 vl = v ( k ) vr = v ( k + 1 ) fl = f ( k ) fr = f ( k + 1 ) curs = curs + ( fl * vl + fr * vr ) / 2 d0 * ( vr - vl ) fl = f0 ( k ) fr = f0 ( k + 1 ) curs0 = curs0 + ( fl * vl + fr * vr ) / 2 d0 * ( vr - vl ) end do end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine ddc ( diffusion ) use maxwell implicit none common / testf / tcur integer ntau , tc , koltoch , i , j , k , klo real * 8 curtime , tcur real * 16 tau0 , spacing , curtime0 parameter ( tau0 = 3.000990745207882E-002 ) !common/lh/dij(1002,100,2) real * 8 b , b1 , b2 , d , diffusion !      real*8,dimension(:),allocatable:: diffusion integer i1 , iunit6 b1 = 0 b2 = 60 j = 10 k = 1 !      allocate (diffusion(500)) ! write(*,*)'time=',tcur ! do tc=1,koltoch !       spacing=0.008/koltoch !       curtime=tau0+spacing*tc!-0.0002 !      curtime0=curtime+0.000000001 !      if((tcur-curtime)*(tcur-curtime0).lt.zero) then !       if((tcur-0.0301)*(tcur-0.0302).lt.zero) then !       open(iunit6,file='lhcd/distribution/ddc.dat',position=\"append\") !      do i1=1,500 !      b=b1+(b2/500)*(i1-1) !      diffusion(i1)=d(b) !       do i=1,1001 !        write(iunit6,*) i, diffusion !       end do !      write(iunit6,*) !       close(iunit6) !       end if ! end do ! !     deallocate(diffusion) end real * 8 function d ( x ) use maxwell implicit none !integer i0 !parameter(i0=1002) !real*8 vij,fij0,fij,dfij,dij,enorm,fst !common/lh/vij(i0,100),fij0(i0,100,2),fij(i0,100,2),dfij(i0,100,2),dij(i0,100,2),enorm(100),fst(100) real * 8 , dimension (:), allocatable :: vvj , ddj integer klo , khi , ierr real * 8 d0 , x integer jindex , kindex , k , j , i common / dddql / d0 , jindex , kindex d = zero if ( d0 . eq . zero ) return j = jindex if ( x . ge . vij ( i0 , j )) return k = kindex allocate ( vvj ( i0 ), ddj ( i0 )) !      write(*,*)'function d(x): k=',k,' j=',j do i = 1 , i0 vvj ( i ) = vij ( i , j ) ddj ( i ) = dij ( i , j , k ) end do call lock ( vvj , i0 , x , klo , khi , ierr ) if ( ierr . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , j , ' v=' , x write ( * , * ) 'vj(1)=' , vvj ( 1 ), ' vj(i0)=' , vvj ( i0 ) pause stop end if d = ddj ( klo ) !!\tcall ddc(d) !!!      call linf(vvj,ddj,x,d,klo,khi) ! !      write(*,*)'klo=',klo,' khi=',khi !      write(*,*)'vj(klo)=',vvj(klo),' vj(khi)=',vvj(khi) !      write(*,*)'x=',x,' d=',d ! deallocate ( vvj , ddj ) end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine qromb ( func , a , b , ss ) implicit none integer jmax , jmaxp , k , km double precision a , b , func , ss , eps external func parameter ( eps = 1.d-6 , jmax = 200 , jmaxp = jmax + 1 , k = 5 , km = k - 1 ) !u    uses polint,trapzd integer j double precision dss , h ( jmaxp ), s ( jmaxp ) h ( 1 ) = 1.d0 do 11 j = 1 , jmax call trapzd ( func , a , b , s ( j ), j ) if ( j . ge . k ) then call polint ( h ( j - km ), s ( j - km ), k , 0.d0 , ss , dss ) if ( abs ( dss ). le . eps * abs ( ss )) return endif s ( j + 1 ) = s ( j ) h ( j + 1 ) = 0.25d0 * h ( j ) 11 continue pause 'too many steps in qromb' end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine polint ( xa , ya , n , x , y , dy ) implicit none integer n , nmax double precision dy , x , y , xa ( n ), ya ( n ) parameter ( nmax = 10 ) integer i , m , ns double precision den , dif , dift , ho , hp , w , c ( nmax ), d ( nmax ) ns = 1 dif = abs ( x - xa ( 1 )) do 11 i = 1 , n dift = abs ( x - xa ( i )) if ( dift . lt . dif ) then ns = i dif = dift endif c ( i ) = ya ( i ) d ( i ) = ya ( i ) 11 continue y = ya ( ns ) ns = ns - 1 do 13 m = 1 , n - 1 do 12 i = 1 , n - m ho = xa ( i ) - x hp = xa ( i + m ) - x w = c ( i + 1 ) - d ( i ) den = ho - hp if ( den . eq . 0.d0 ) pause 'failure in polint' den = w / den d ( i ) = hp * den c ( i ) = ho * den 12 continue if ( 2 * ns . lt . n - m ) then dy = c ( ns + 1 ) else dy = d ( ns ) ns = ns - 1 endif y = y + dy 13 continue return end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine trapzd ( func , a , b , s , n ) implicit none integer n double precision a , b , s , func external func integer it , j double precision del , sum , tnm , x if ( n . eq . 1 ) then s = 0.5d0 * ( b - a ) * ( func ( a ) + func ( b )) else it = 2 ** ( n - 2 ) tnm = it del = ( b - a ) / tnm x = a + 0.5d0 * del sum = 0.d0 do 11 j = 1 , it sum = sum + func ( x ) x = x + del 11 continue s = 0.5d0 * ( s + ( b - a ) * sum / tnm ) endif return end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!","tags":"","loc":"sourcefile\\drivencurrent95.f90.html"}]}